{"version":3,"sources":["../../src/bin/ponder.ts","../../src/utils/extend.ts","../../src/build/service.ts","../../src/common/errors.ts","../../src/build/configAndIndexingFunctions.ts","../../src/utils/chains.ts","../../src/config/networks.ts","../../src/utils/duplicates.ts","../../src/sync/abi.ts","../../src/utils/lowercase.ts","../../../common/src/promiseWithResolvers.ts","../../../common/src/dedupe.ts","../../../common/src/queue.ts","../../src/utils/offset.ts","../../src/build/factory.ts","../../src/build/plugin.ts","../../src/build/schema.ts","../../src/build/stacktrace.ts","../../src/build/index.ts","../../src/common/codegen.ts","../../src/common/logger.ts","../../src/common/metrics.ts","../../src/common/options.ts","../../src/common/telemetry.ts","../../src/utils/timer.ts","../../src/utils/wait.ts","../../src/bin/utils/shutdown.ts","../../src/bin/commands/codegen.ts","../../src/bin/commands/dev.ts","../../src/database/index.ts","../../src/sync-store/migrations.ts","../../src/utils/checkpoint.ts","../../src/utils/format.ts","../../src/utils/pg.ts","../../src/utils/print.ts","../../src/utils/pglite.ts","../../src/database/kysely.ts","../../src/ui/app.tsx","../../src/ui/ProgressBar.tsx","../../src/ui/Table.tsx","../../src/ui/service.ts","../../src/indexing-store/historical.ts","../../src/indexing-store/index.ts","../../src/indexing-store/metadata.ts","../../src/indexing-store/realtime.ts","../../src/sync/source.ts","../../src/indexing/service.ts","../../src/indexing/addStackTrace.ts","../../src/indexing/ponderActions.ts","../../src/indexing/index.ts","../../src/sync/fragments.ts","../../src/utils/interval.ts","../../src/sync-store/index.ts","../../src/sync-store/encoding.ts","../../src/sync-realtime/filter.ts","../../src/sync/events.ts","../../src/utils/rpc.ts","../../src/sync-historical/index.ts","../../src/utils/range.ts","../../src/sync-realtime/index.ts","../../src/sync-realtime/bloom.ts","../../src/utils/estimate.ts","../../src/utils/generators.ts","../../src/utils/requestQueue.ts","../../src/sync/index.ts","../../src/sync/transport.ts","../../src/bin/utils/run.ts","../../src/server/index.ts","../../src/hono/index.ts","../../src/server/error.ts","../../src/bin/utils/runServer.ts","../../src/bin/commands/serve.ts","../../src/bin/commands/start.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { readFileSync } from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport type { Prettify } from \"@/types/utils.js\";\nimport { Command } from \"@commander-js/extra-typings\";\nimport dotenv from \"dotenv\";\nimport { codegen } from \"./commands/codegen.js\";\nimport { dev } from \"./commands/dev.js\";\nimport { serve } from \"./commands/serve.js\";\nimport { start } from \"./commands/start.js\";\n\ndotenv.config({ path: \".env.local\" });\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst packageJsonPath = resolve(__dirname, \"../../package.json\");\nconst packageJson = JSON.parse(\n  readFileSync(packageJsonPath, { encoding: \"utf8\" }),\n);\n\nconst ponder = new Command(\"ponder\")\n  .usage(\"<command> [OPTIONS]\")\n  .helpOption(\"-h, --help\", \"Show this help message\")\n  .helpCommand(false)\n  .option(\n    \"--root <PATH>\",\n    \"Path to the project root directory (default: working directory)\",\n  )\n  .option(\n    \"--config <PATH>\",\n    \"Path to the project config file\",\n    \"ponder.config.ts\",\n  )\n  .option(\n    \"-v, --debug\",\n    \"Enable debug logs, e.g. realtime blocks, internal events\",\n  )\n  .option(\n    \"-vv, --trace\",\n    \"Enable trace logs, e.g. db queries, indexing checkpoints\",\n  )\n  .option(\n    \"--log-level <LEVEL>\",\n    'Minimum log level (\"error\", \"warn\", \"info\", \"debug\", or \"trace\", default: \"info\")',\n  )\n  .option(\n    \"--log-format <FORMAT>\",\n    'The log format (\"pretty\" or \"json\")',\n    \"pretty\",\n  )\n  .version(packageJson.version, \"-V, --version\", \"Show the version number\")\n  .configureHelp({ showGlobalOptions: true })\n  .allowExcessArguments(false)\n  .showHelpAfterError()\n  .enablePositionalOptions(false);\n\ntype GlobalOptions = {\n  command: \"dev\" | \"start\" | \"serve\" | \"codegen\";\n} & ReturnType<typeof ponder.opts>;\n\nconst devCommand = new Command(\"dev\")\n  .description(\"Start the development server with hot reloading\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  // NOTE: Do not set a default for hostname. We currently rely on the Node.js\n  // default behavior when passing undefined to http.Server.listen(), which\n  // detects the available interfaces (IPv4 and/or IPv6) and uses them.\n  // Documentation: https://arc.net/l/quote/dnjmtumq\n  .option(\n    \"-H, --hostname <HOSTNAME>\",\n    'Hostname for the web server (default: \"0.0.0.0\" or \"::\")',\n  )\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await dev({ cliOptions });\n  });\n\nconst startCommand = new Command(\"start\")\n  .description(\"Start the production server\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\n    \"-H, --hostname <HOSTNAME>\",\n    'Hostname for the web server (default: \"0.0.0.0\" or \"::\")',\n  )\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await start({ cliOptions });\n  });\n\nconst serveCommand = new Command(\"serve\")\n  .description(\"Start the production HTTP server without the indexer\")\n  .option(\"-p, --port <PORT>\", \"Port for the web server\", Number, 42069)\n  .option(\n    \"-H, --hostname <HOSTNAME>\",\n    'Hostname for the web server (default: \"0.0.0.0\" or \"::\")',\n  )\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await serve({ cliOptions });\n  });\n\nconst codegenCommand = new Command(\"codegen\")\n  .description(\"Generate the schema.graphql file, then exit\")\n  .showHelpAfterError()\n  .action(async (_, command) => {\n    const cliOptions = {\n      ...command.optsWithGlobals(),\n      command: command.name(),\n    } as GlobalOptions & ReturnType<typeof command.opts>;\n    await codegen({ cliOptions });\n  });\n\n// const cache = new Command(\"cache\");\n\n// cache\n//   .command(\"drop\")\n//   .description(\"Dangerously drop all cached RPC data\")\n//   .action(async (_, command) => {\n//     const cliOptions = command.optsWithGlobals() as GlobalOptions &\n//       ReturnType<typeof command.opts>;\n//     console.log(\"ponder db drop\");\n//   });\n\n// ponder.addCommand(cache);\n\n// cli\n//   .command(\"cache prune\", \"Drop stale indexed data tables\")\n//   .action(async (cliOptions: DbOptions) => {\n//     // if (cliOptions.help) process.exit(0);\n//     console.log(\"ponder cache prune\");\n//   });\n\nponder.addCommand(devCommand);\nponder.addCommand(startCommand);\nponder.addCommand(serveCommand);\nponder.addCommand(codegenCommand);\n\nexport type CliOptions = Prettify<\n  GlobalOptions &\n    Partial<\n      ReturnType<typeof devCommand.opts> &\n        ReturnType<typeof startCommand.opts> &\n        ReturnType<typeof serveCommand.opts> &\n        ReturnType<typeof codegenCommand.opts>\n    >\n>;\n\nawait ponder.parseAsync();\n","import type { Prettify } from \"@/types/utils.js\";\n\nexport const extend = <\n  TCreate extends (...params: any[]) => any,\n  TMethods extends { [methodName: string]: (...params: any[]) => unknown },\n>(\n  create: TCreate,\n  _methods: TMethods,\n): ((\n  ...params: Parameters<TCreate>\n) => ReturnType<TCreate> extends Promise<any>\n  ? Promise<Extend<Awaited<ReturnType<TCreate>>, TMethods>>\n  : Extend<ReturnType<TCreate>, TMethods>) => {\n  return (...params: Parameters<TCreate>) => {\n    const service = create(...params);\n\n    if (service instanceof Promise) {\n      return service.then((s) => {\n        const methods: any = {};\n        for (const [methodName, method] of Object.entries(_methods)) {\n          methods[methodName] = (...params: any) => method(s, ...params);\n        }\n\n        return {\n          ...s,\n          ...methods,\n        };\n      });\n    } else {\n      const methods: any = {};\n      for (const [methodName, method] of Object.entries(_methods)) {\n        methods[methodName] = (...params: any) => method(service, ...params);\n      }\n\n      return {\n        ...service,\n        ...methods,\n      };\n    }\n  };\n};\n\nexport type Extend<\n  service,\n  methods extends { [methodName: string]: (...params: any[]) => unknown },\n> = Prettify<\n  service & {\n    [methodName in keyof methods]: Parameters<methods[methodName]> extends [\n      any,\n      ...infer parameters,\n    ]\n      ? (...params: parameters) => ReturnType<methods[methodName]>\n      : never;\n  }\n>;\n","import { createHash } from \"node:crypto\";\nimport crypto from \"node:crypto\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport { BuildError } from \"@/common/errors.js\";\nimport type { Config } from \"@/config/config.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { Schema } from \"@/drizzle/index.js\";\nimport type { SqlStatements } from \"@/drizzle/kit/index.js\";\nimport type { PonderRoutes } from \"@/hono/index.js\";\nimport type { Source } from \"@/sync/source.js\";\nimport { serialize } from \"@/utils/serialize.js\";\nimport { glob } from \"glob\";\nimport type { GraphQLSchema } from \"graphql\";\nimport type { Hono } from \"hono\";\nimport { type ViteDevServer, createServer } from \"vite\";\nimport { ViteNodeRunner } from \"vite-node/client\";\nimport { ViteNodeServer } from \"vite-node/server\";\nimport { installSourcemapsSupport } from \"vite-node/source-map\";\nimport { normalizeModuleId, toFilePath } from \"vite-node/utils\";\nimport viteTsconfigPathsPlugin from \"vite-tsconfig-paths\";\nimport {\n  type IndexingFunctions,\n  type RawIndexingFunctions,\n  safeBuildConfigAndIndexingFunctions,\n} from \"./configAndIndexingFunctions.js\";\nimport { vitePluginPonder } from \"./plugin.js\";\nimport { safeBuildSchema } from \"./schema.js\";\nimport { parseViteNodeError } from \"./stacktrace.js\";\n\nconst BUILD_ID_VERSION = \"1\";\n\nexport type Service = {\n  // static\n  common: Common;\n  indexingRegex: RegExp;\n  apiRegex: RegExp;\n  indexingPattern: string;\n  apiPattern: string;\n\n  // vite\n  viteDevServer: ViteDevServer;\n  viteNodeServer: ViteNodeServer;\n  viteNodeRunner: ViteNodeRunner;\n};\n\ntype BaseBuild = {\n  // Build ID for caching\n  buildId: string;\n  instanceId: string;\n  // Config\n  databaseConfig: DatabaseConfig;\n  sources: Source[];\n  networks: Network[];\n  // Schema\n  schema: Schema;\n  statements: SqlStatements;\n  namespace: string;\n  graphqlSchema: GraphQLSchema;\n};\n\nexport type IndexingBuild = BaseBuild & {\n  indexingFunctions: IndexingFunctions;\n};\n\nexport type ApiBuild = BaseBuild & {\n  app: Hono;\n  routes: PonderRoutes;\n};\n\nexport type BuildResult =\n  | {\n      status: \"success\";\n      indexingBuild: IndexingBuild;\n      apiBuild: ApiBuild;\n    }\n  | { status: \"error\"; error: Error };\n\nexport type BuildResultDev =\n  | {\n      status: \"success\";\n      kind: \"indexing\";\n      indexingBuild: IndexingBuild;\n      apiBuild: ApiBuild;\n    }\n  | {\n      status: \"success\";\n      kind: \"api\";\n      indexingBuild?: never;\n      apiBuild: ApiBuild;\n    }\n  | { status: \"error\"; kind: \"indexing\" | \"api\"; error: Error };\n\ntype IndexingBuildResult =\n  | { status: \"success\"; build: IndexingBuild }\n  | { status: \"error\"; error: Error };\n\ntype ApiBuildResult =\n  | { status: \"success\"; build: ApiBuild }\n  | { status: \"error\"; error: Error };\n\nexport const create = async ({\n  common,\n}: {\n  common: Common;\n}): Promise<Service> => {\n  const escapeRegex = /[.*+?^${}()|[\\]\\\\]/g;\n\n  const escapedIndexingDir = common.options.indexingDir\n    // If on Windows, use a POSIX path for this regex.\n    .replace(/\\\\/g, \"/\")\n    // Escape special characters in the path.\n    .replace(escapeRegex, \"\\\\$&\");\n  const indexingRegex = new RegExp(`^${escapedIndexingDir}/.*\\\\.(ts|js)$`);\n\n  const escapedApiDir = common.options.apiDir\n    // If on Windows, use a POSIX path for this regex.\n    .replace(/\\\\/g, \"/\")\n    // Escape special characters in the path.\n    .replace(escapeRegex, \"\\\\$&\");\n  const apiRegex = new RegExp(`^${escapedApiDir}/.*\\\\.(ts|js)$`);\n\n  const indexingPattern = path\n    .join(common.options.indexingDir, \"**/*.{js,mjs,ts,mts}\")\n    .replace(/\\\\/g, \"/\");\n\n  const apiPattern = path\n    .join(common.options.apiDir, \"**/*.{js,mjs,ts,mts}\")\n    .replace(/\\\\/g, \"/\");\n\n  const viteLogger = {\n    warnedMessages: new Set<string>(),\n    loggedErrors: new WeakSet<Error>(),\n    hasWarned: false,\n    clearScreen() {},\n    hasErrorLogged: (error: Error) => viteLogger.loggedErrors.has(error),\n    info: (msg: string) => {\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n    warn: (msg: string) => {\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n    warnOnce: (msg: string) => {\n      if (viteLogger.warnedMessages.has(msg)) return;\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n      viteLogger.warnedMessages.add(msg);\n    },\n    error: (msg: string) => {\n      viteLogger.hasWarned = true;\n      common.logger.trace({ service: \"build(vite)\", msg });\n    },\n  };\n\n  const viteDevServer = await createServer({\n    root: common.options.rootDir,\n    cacheDir: path.join(common.options.ponderDir, \"vite\"),\n    publicDir: false,\n    customLogger: viteLogger,\n    server: { hmr: false },\n    plugins: [viteTsconfigPathsPlugin(), vitePluginPonder()],\n  });\n\n  // This is Vite boilerplate (initializes the Rollup container).\n  await viteDevServer.pluginContainer.buildStart({});\n\n  const viteNodeServer = new ViteNodeServer(viteDevServer);\n  installSourcemapsSupport({\n    getSourceMap: (source) => viteNodeServer.getSourceMap(source),\n  });\n\n  const viteNodeRunner = new ViteNodeRunner({\n    root: viteDevServer.config.root,\n    fetchModule: (id) => viteNodeServer.fetchModule(id, \"ssr\"),\n    resolveId: (id, importer) => viteNodeServer.resolveId(id, importer, \"ssr\"),\n  });\n\n  return {\n    common,\n    indexingRegex,\n    apiRegex,\n    indexingPattern,\n    apiPattern,\n    viteDevServer,\n    viteNodeServer,\n    viteNodeRunner,\n  };\n};\n\n/**\n * Execute, validate, and build the files the make up a Ponder app.\n * If `watch` is true (dev server), then use vite to re-execute changed files,\n * and validate and build again. This function only re-executes changes files,\n * but doesn't attempt to skip any validation or build steps.\n */\nexport const start = async (\n  buildService: Service,\n  {\n    watch,\n    onBuild,\n  }:\n    | {\n        watch: true;\n        onBuild: (buildResult: BuildResultDev) => void;\n      }\n    | { watch: false; onBuild?: never },\n): Promise<BuildResult> => {\n  const { common } = buildService;\n\n  if (common.options.command !== \"serve\") {\n    // @ts-ignore\n    globalThis.__PONDER_INSTANCE_ID =\n      process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n      crypto.randomBytes(2).toString(\"hex\");\n  }\n\n  // Note: Don't run these in parallel. If there are circular imports in user code,\n  // it's possible for ViteNodeRunner to return exports as undefined (a race condition).\n  const configResult = await executeConfig(buildService);\n  const schemaResult = await executeSchema(buildService);\n  const indexingResult = await executeIndexingFunctions(buildService);\n  const apiResult = await executeApiRoutes(buildService);\n\n  if (configResult.status === \"error\") {\n    return { status: \"error\", error: configResult.error };\n  }\n  if (schemaResult.status === \"error\") {\n    return { status: \"error\", error: schemaResult.error };\n  }\n  if (indexingResult.status === \"error\") {\n    return { status: \"error\", error: indexingResult.error };\n  }\n  if (apiResult.status === \"error\") {\n    return { status: \"error\", error: apiResult.error };\n  }\n\n  let cachedConfigResult = configResult;\n  let cachedSchemaResult = schemaResult;\n  let cachedIndexingResult = indexingResult;\n  let cachedApiResult = apiResult;\n\n  // If watch is false (`ponder start` or `ponder serve`),\n  // don't register  any event handlers on the watcher.\n  if (watch) {\n    // Define the directories and files to ignore\n    const ignoredDirs = [common.options.generatedDir, common.options.ponderDir];\n    const ignoredFiles = [\n      path.join(common.options.rootDir, \"ponder-env.d.ts\"),\n      path.join(common.options.rootDir, \".env.local\"),\n    ];\n\n    const isFileIgnored = (filePath: string) => {\n      const isInIgnoredDir = ignoredDirs.some((dir) => {\n        const rel = path.relative(dir, filePath);\n        return !rel.startsWith(\"..\") && !path.isAbsolute(rel);\n      });\n\n      const isIgnoredFile = ignoredFiles.includes(filePath);\n      return isInIgnoredDir || isIgnoredFile;\n    };\n\n    const onFileChange = async (_file: string) => {\n      if (isFileIgnored(_file)) return;\n\n      // Note that `toFilePath` always returns a POSIX path, even if you pass a Windows path.\n      const file = toFilePath(\n        normalizeModuleId(_file),\n        common.options.rootDir,\n      ).path;\n\n      // Invalidate all modules that depend on the updated files.\n      // Note that `invalidateDepTree` accepts and returns POSIX paths, even on Windows.\n      const invalidated = [\n        ...buildService.viteNodeRunner.moduleCache.invalidateDepTree([file]),\n      ];\n\n      // If no files were invalidated, no need to reload.\n      if (invalidated.length === 0) return;\n\n      // Note that the paths in `invalidated` are POSIX, so we need to\n      // convert the paths in `options` to POSIX for this comparison.\n      // The `srcDir` regex is already converted to POSIX.\n      const hasConfigUpdate = invalidated.includes(\n        common.options.configFile.replace(/\\\\/g, \"/\"),\n      );\n      const hasSchemaUpdate = invalidated.includes(\n        common.options.schemaFile.replace(/\\\\/g, \"/\"),\n      );\n\n      const hasIndexingUpdate = invalidated.some(\n        (file) =>\n          buildService.indexingRegex.test(file) &&\n          !buildService.apiRegex.test(file),\n      );\n      const hasApiUpdate = invalidated.some((file) =>\n        buildService.apiRegex.test(file),\n      );\n\n      // This branch could trigger if you change a `note.txt` file within `src/`.\n      // Note: We could probably do a better job filtering out files in `isFileIgnored`.\n      if (\n        !hasConfigUpdate &&\n        !hasSchemaUpdate &&\n        !hasIndexingUpdate &&\n        !hasApiUpdate\n      ) {\n        return;\n      }\n\n      common.logger.info({\n        service: \"build\",\n        msg: `Hot reload ${invalidated\n          .map((f) => `'${path.relative(common.options.rootDir, f)}'`)\n          .join(\", \")}`,\n      });\n\n      // re-execute anything that would cause the instance id to change\n      if (hasIndexingUpdate || hasSchemaUpdate || hasConfigUpdate) {\n        // @ts-ignore\n        globalThis.__PONDER_INSTANCE_ID =\n          process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n          crypto.randomBytes(2).toString(\"hex\");\n\n        buildService.viteNodeRunner.moduleCache.invalidateDepTree([\n          buildService.common.options.configFile,\n        ]);\n        buildService.viteNodeRunner.moduleCache.invalidateDepTree([\n          buildService.common.options.schemaFile,\n        ]);\n        buildService.viteNodeRunner.moduleCache.invalidateDepTree(\n          glob.sync(buildService.indexingPattern, {\n            ignore: buildService.apiPattern,\n          }),\n        );\n        buildService.viteNodeRunner.moduleCache.deleteByModuleId(\"@/generated\");\n\n        const configResult = await executeConfig(buildService);\n        const schemaResult = await executeSchema(buildService);\n        const indexingResult = await executeIndexingFunctions(buildService);\n\n        if (configResult.status === \"error\") {\n          onBuild({\n            status: \"error\",\n            kind: \"indexing\",\n            error: configResult.error,\n          });\n          return;\n        }\n        if (schemaResult.status === \"error\") {\n          onBuild({\n            status: \"error\",\n            kind: \"indexing\",\n            error: schemaResult.error,\n          });\n          return;\n        }\n        if (indexingResult.status === \"error\") {\n          onBuild({\n            status: \"error\",\n            kind: \"indexing\",\n            error: indexingResult.error,\n          });\n          return;\n        }\n\n        cachedConfigResult = configResult;\n        cachedSchemaResult = schemaResult;\n        cachedIndexingResult = indexingResult;\n      }\n\n      if (hasApiUpdate) {\n        const files = glob.sync(buildService.apiPattern);\n        buildService.viteNodeRunner.moduleCache.invalidateDepTree(files);\n        buildService.viteNodeRunner.moduleCache.deleteByModuleId(\"@/generated\");\n\n        const result = await executeApiRoutes(buildService);\n        if (result.status === \"error\") {\n          onBuild({ status: \"error\", kind: \"api\", error: result.error });\n          return;\n        }\n        cachedApiResult = result;\n      }\n\n      /**\n       * Build and validate updated indexing and api artifacts\n       *\n       * There are a few cases to handle:\n       * 1) config or schema is updated -> rebuild both api and indexing\n       * 2) indexing functions are updated -> rebuild indexing\n       * 3) api routes are updated -> rebuild api\n       *\n       * Note: the api build cannot be successful if the indexing\n       * build fails, this means that any indexing errors are always\n       * propogated to the api build.\n       */\n\n      const indexingBuildResult = await validateAndBuild(\n        buildService,\n        cachedConfigResult,\n        cachedSchemaResult,\n        cachedIndexingResult,\n      );\n      if (indexingBuildResult.status === \"error\") {\n        onBuild({\n          status: \"error\",\n          kind: \"indexing\",\n          error: indexingBuildResult.error,\n        });\n        return;\n      }\n\n      // If schema or config is updated, rebuild both api and indexing\n      if (hasConfigUpdate || hasSchemaUpdate || hasIndexingUpdate) {\n        const apiBuildResult = validateAndBuildApi(\n          buildService,\n          indexingBuildResult.build,\n          cachedApiResult,\n        );\n\n        if (apiBuildResult.status === \"error\") {\n          onBuild({\n            status: \"error\",\n            kind: \"api\",\n            error: apiBuildResult.error,\n          });\n          return;\n        }\n\n        onBuild({\n          status: \"success\",\n          kind: \"indexing\",\n          indexingBuild: indexingBuildResult.build,\n          apiBuild: apiBuildResult.build,\n        });\n      } else {\n        const apiBuildResult = validateAndBuildApi(\n          buildService,\n          indexingBuildResult.build,\n          cachedApiResult,\n        );\n\n        if (apiBuildResult.status === \"error\") {\n          onBuild({\n            status: \"error\",\n            kind: \"api\",\n            error: apiBuildResult.error,\n          });\n          return;\n        }\n\n        onBuild({\n          status: \"success\",\n          kind: \"api\",\n          apiBuild: apiBuildResult.build,\n        });\n      }\n    };\n\n    buildService.viteDevServer.watcher.on(\"change\", onFileChange);\n  }\n\n  // Build and validate initial indexing and server build.\n  // Note: the api build cannot be successful if the indexing\n  // build fails\n\n  const initialBuildResult = await validateAndBuild(\n    buildService,\n    configResult,\n    schemaResult,\n    indexingResult,\n  );\n\n  if (initialBuildResult.status === \"error\") {\n    return {\n      status: \"error\",\n      error: initialBuildResult.error,\n    };\n  }\n\n  const initialApiBuildResult = validateAndBuildApi(\n    buildService,\n    initialBuildResult.build,\n    apiResult,\n  );\n\n  if (initialApiBuildResult.status === \"error\") {\n    return {\n      status: \"error\",\n      error: initialApiBuildResult.error,\n    };\n  }\n\n  return {\n    status: \"success\",\n    indexingBuild: initialBuildResult.build,\n    apiBuild: initialApiBuildResult.build,\n  };\n};\n\nexport const kill = async (buildService: Service): Promise<void> => {\n  await buildService.viteDevServer?.close();\n  buildService.common.logger.debug({\n    service: \"build\",\n    msg: \"Killed build service\",\n  });\n};\n\nconst executeConfig = async (\n  buildService: Service,\n): Promise<\n  | { status: \"success\"; config: Config; contentHash: string }\n  | { status: \"error\"; error: Error }\n> => {\n  const executeResult = await executeFile(buildService, {\n    file: buildService.common.options.configFile,\n  });\n\n  if (executeResult.status === \"error\") {\n    buildService.common.logger.error({\n      service: \"build\",\n      msg: \"Error while executing 'ponder.config.ts':\",\n      error: executeResult.error,\n    });\n\n    return executeResult;\n  }\n\n  const config = executeResult.exports.default as Config;\n\n  const contentHash = createHash(\"sha256\")\n    .update(serialize(config))\n    .digest(\"hex\");\n\n  return { status: \"success\", config, contentHash } as const;\n};\n\nconst executeSchema = async (\n  buildService: Service,\n): Promise<\n  | { status: \"success\"; schema: Schema; contentHash: string }\n  | { status: \"error\"; error: Error }\n> => {\n  const executeResult = await executeFile(buildService, {\n    file: buildService.common.options.schemaFile,\n  });\n\n  if (executeResult.status === \"error\") {\n    buildService.common.logger.error({\n      service: \"build\",\n      msg: \"Error while executing 'ponder.schema.ts':\",\n      error: executeResult.error,\n    });\n\n    return executeResult;\n  }\n\n  const schema = executeResult.exports;\n\n  const contents = fs.readFileSync(\n    buildService.common.options.schemaFile,\n    \"utf-8\",\n  );\n  return {\n    status: \"success\",\n    schema,\n    contentHash: createHash(\"sha256\").update(contents).digest(\"hex\"),\n  };\n};\n\nconst executeIndexingFunctions = async (\n  buildService: Service,\n): Promise<\n  | {\n      status: \"success\";\n      indexingFunctions: RawIndexingFunctions;\n      contentHash: string;\n    }\n  | { status: \"error\"; error: Error }\n> => {\n  const files = glob.sync(buildService.indexingPattern, {\n    ignore: buildService.apiPattern,\n  });\n  const executeResults = await Promise.all(\n    files.map(async (file) => ({\n      ...(await executeFile(buildService, { file })),\n      file,\n    })),\n  );\n\n  for (const executeResult of executeResults) {\n    if (executeResult.status === \"error\") {\n      buildService.common.logger.error({\n        service: \"build\",\n        msg: `Error while executing '${path.relative(\n          buildService.common.options.rootDir,\n          executeResult.file,\n        )}':`,\n        error: executeResult.error,\n      });\n\n      return executeResult;\n    }\n  }\n\n  // Note that we are only hashing the file contents, not the exports. This is\n  // different from the config/schema, where we include the serializable object itself.\n  const hash = createHash(\"sha256\");\n  for (const file of files) {\n    try {\n      const contents = fs.readFileSync(file, \"utf-8\");\n      hash.update(contents);\n    } catch (e) {\n      buildService.common.logger.warn({\n        service: \"build\",\n        msg: `Unable to read contents of file '${file}' while constructin build ID`,\n      });\n      hash.update(file);\n    }\n  }\n  const contentHash = hash.digest(\"hex\");\n\n  const exports = await buildService.viteNodeRunner.executeId(\"@/generated\");\n\n  return {\n    status: \"success\",\n    indexingFunctions: exports.ponder.fns,\n    contentHash,\n  };\n};\n\nconst executeApiRoutes = async (\n  buildService: Service,\n): Promise<\n  | {\n      status: \"success\";\n      app: Hono;\n      routes: PonderRoutes;\n    }\n  | { status: \"error\"; error: Error }\n> => {\n  const files = glob.sync(buildService.apiPattern);\n  const executeResults = await Promise.all(\n    files.map(async (file) => ({\n      ...(await executeFile(buildService, { file })),\n      file,\n    })),\n  );\n\n  for (const executeResult of executeResults) {\n    if (executeResult.status === \"error\") {\n      buildService.common.logger.error({\n        service: \"build\",\n        msg: `Error while executing '${path.relative(\n          buildService.common.options.rootDir,\n          executeResult.file,\n        )}':`,\n        error: executeResult.error,\n      });\n\n      return executeResult;\n    }\n  }\n\n  const exports = await buildService.viteNodeRunner.executeId(\"@/generated\");\n\n  return {\n    status: \"success\",\n    app: exports.ponder.hono,\n    routes: exports.ponder.routes,\n  };\n};\n\nconst validateAndBuild = async (\n  { common }: Pick<Service, \"common\">,\n  config: { config: Config; contentHash: string },\n  schema: { schema: Schema; contentHash: string },\n  indexingFunctions: {\n    indexingFunctions: RawIndexingFunctions;\n    contentHash: string;\n  },\n): Promise<IndexingBuildResult> => {\n  // Validate and build the schema\n  const buildSchemaResult = safeBuildSchema({\n    schema: schema.schema,\n    instanceId:\n      process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n      // @ts-ignore\n      globalThis.__PONDER_INSTANCE_ID,\n  });\n  if (buildSchemaResult.status === \"error\") {\n    common.logger.error({\n      service: \"build\",\n      msg: \"Error while building schema:\",\n      error: buildSchemaResult.error,\n    });\n\n    return buildSchemaResult;\n  }\n\n  // Validates and build the config\n  const buildConfigAndIndexingFunctionsResult =\n    await safeBuildConfigAndIndexingFunctions({\n      config: config.config,\n      rawIndexingFunctions: indexingFunctions.indexingFunctions,\n      options: common.options,\n    });\n  if (buildConfigAndIndexingFunctionsResult.status === \"error\") {\n    common.logger.error({\n      service: \"build\",\n      msg: \"Failed build\",\n      error: buildConfigAndIndexingFunctionsResult.error,\n    });\n\n    return buildConfigAndIndexingFunctionsResult;\n  }\n\n  for (const log of buildConfigAndIndexingFunctionsResult.logs) {\n    common.logger[log.level]({ service: \"build\", msg: log.msg });\n  }\n\n  const buildId = createHash(\"sha256\")\n    .update(BUILD_ID_VERSION)\n    .update(config.contentHash)\n    .update(schema.contentHash)\n    .update(indexingFunctions.contentHash)\n    .digest(\"hex\")\n    .slice(0, 10);\n\n  common.logger.debug({\n    service: \"build\",\n    msg: `Completed build with ID '${buildId}' (hash of project file contents)`,\n  });\n\n  return {\n    status: \"success\",\n    build: {\n      buildId,\n      instanceId:\n        process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n        // @ts-ignore\n        globalThis.__PONDER_INSTANCE_ID,\n      databaseConfig: buildConfigAndIndexingFunctionsResult.databaseConfig,\n      networks: buildConfigAndIndexingFunctionsResult.networks,\n      sources: buildConfigAndIndexingFunctionsResult.sources,\n      indexingFunctions:\n        buildConfigAndIndexingFunctionsResult.indexingFunctions,\n      schema: schema.schema,\n      statements: buildSchemaResult.statements,\n      namespace: buildSchemaResult.namespace,\n      graphqlSchema: buildSchemaResult.graphqlSchema,\n    },\n  };\n};\n\nconst validateAndBuildApi = (\n  { common }: Pick<Service, \"common\">,\n  baseBuild: BaseBuild,\n  api: { app: Hono; routes: PonderRoutes },\n): ApiBuildResult => {\n  for (const {\n    pathOrHandlers: [maybePathOrHandler],\n  } of api.routes) {\n    if (typeof maybePathOrHandler === \"string\") {\n      if (\n        maybePathOrHandler === \"/status\" ||\n        maybePathOrHandler === \"/metrics\" ||\n        maybePathOrHandler === \"/health\"\n      ) {\n        const error = new BuildError(\n          `Validation failed: API route \"${maybePathOrHandler}\" is reserved for internal use.`,\n        );\n        error.stack = undefined;\n        common.logger.error({ service: \"build\", msg: \"Failed build\", error });\n        return { status: \"error\", error } as const;\n      }\n    }\n  }\n\n  return {\n    status: \"success\",\n    build: {\n      ...baseBuild,\n      app: api.app,\n      routes: api.routes,\n    },\n  };\n};\n\nconst executeFile = async (\n  { common, viteNodeRunner }: Service,\n  { file }: { file: string },\n): Promise<\n  { status: \"success\"; exports: any } | { status: \"error\"; error: Error }\n> => {\n  try {\n    const exports = await viteNodeRunner.executeFile(file);\n    return { status: \"success\", exports } as const;\n  } catch (error_) {\n    const relativePath = path.relative(common.options.rootDir, file);\n    const error = parseViteNodeError(relativePath, error_ as Error);\n    return { status: \"error\", error } as const;\n  }\n};\n","export class BaseError extends Error {\n  override name = \"BaseError\";\n\n  meta: string[] = [];\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, BaseError.prototype);\n  }\n}\n\nexport function getBaseError(err: any) {\n  if (err instanceof BaseError) return err;\n  if (err instanceof Error) return new BaseError(err.message);\n  if (typeof err?.message === \"string\") return new BaseError(err.message);\n  if (typeof err === \"string\") return new BaseError(err);\n  return new BaseError(\"unknown error\");\n}\n\nexport class BuildError extends BaseError {\n  override name = \"BuildError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, BuildError.prototype);\n  }\n}\n\nexport class NonRetryableError extends BaseError {\n  override name = \"NonRetryableError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, NonRetryableError.prototype);\n  }\n}\n\nexport class IgnorableError extends BaseError {\n  override name = \"IgnorableError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, IgnorableError.prototype);\n  }\n}\n\n// Indexing store errors\n\nexport class StoreError extends NonRetryableError {\n  override name = \"StoreError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, StoreError.prototype);\n  }\n}\n\nexport class UniqueConstraintError extends NonRetryableError {\n  override name = \"UniqueConstraintError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, UniqueConstraintError.prototype);\n  }\n}\n\nexport class NotNullConstraintError extends NonRetryableError {\n  override name = \"NotNullConstraintError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, NotNullConstraintError.prototype);\n  }\n}\n\nexport class RecordNotFoundError extends NonRetryableError {\n  override name = \"RecordNotFoundError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, RecordNotFoundError.prototype);\n  }\n}\n\nexport class CheckConstraintError extends NonRetryableError {\n  override name = \"CheckConstraintError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, CheckConstraintError.prototype);\n  }\n}\n\nexport class InvalidStoreMethodError extends NonRetryableError {\n  override name = \"InvalidStoreMethodError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, InvalidStoreMethodError.prototype);\n  }\n}\n\nexport class UndefinedTableError extends NonRetryableError {\n  override name = \"UndefinedTableError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, UndefinedTableError.prototype);\n  }\n}\n\nexport class BigIntSerializationError extends NonRetryableError {\n  override name = \"BigIntSerializationError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, BigIntSerializationError.prototype);\n  }\n}\n\nexport class FlushError extends NonRetryableError {\n  override name = \"FlushError\";\n\n  constructor(message?: string | undefined) {\n    super(message);\n    Object.setPrototypeOf(this, FlushError.prototype);\n  }\n}\n","import path from \"node:path\";\nimport { BuildError } from \"@/common/errors.js\";\nimport type { Options } from \"@/common/options.js\";\nimport type { Config } from \"@/config/config.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport {\n  type Network,\n  getFinalityBlockCount,\n  getRpcUrlsForClient,\n  isRpcUrlPublic,\n} from \"@/config/networks.js\";\nimport { buildAbiEvents, buildAbiFunctions, buildTopics } from \"@/sync/abi.js\";\nimport type { BlockSource, ContractSource } from \"@/sync/source.js\";\nimport { chains } from \"@/utils/chains.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { dedupe } from \"@ponder/common\";\nimport parse from \"pg-connection-string\";\nimport type { Hex, LogTopic } from \"viem\";\nimport { buildLogFactory } from \"./factory.js\";\n\nexport type RawIndexingFunctions = {\n  name: string;\n  fn: (...args: any) => any;\n}[];\n\nexport type IndexingFunctions = {\n  [eventName: string]: (...args: any) => any;\n};\n\nexport async function buildConfigAndIndexingFunctions({\n  config,\n  rawIndexingFunctions,\n  options: { rootDir, ponderDir },\n}: {\n  config: Config;\n  rawIndexingFunctions: RawIndexingFunctions;\n  options: Pick<Options, \"ponderDir\" | \"rootDir\">;\n}): Promise<{\n  databaseConfig: DatabaseConfig;\n  networks: Network[];\n  sources: (BlockSource | ContractSource)[];\n  indexingFunctions: IndexingFunctions;\n  logs: { level: \"warn\" | \"info\" | \"debug\"; msg: string }[];\n}> {\n  const logs: { level: \"warn\" | \"info\" | \"debug\"; msg: string }[] = [];\n\n  // Build database.\n  let databaseConfig: DatabaseConfig;\n\n  // Determine PGlite directory, preferring config.database.directory if available\n  const pgliteDir =\n    config.database?.kind === \"pglite\" && config.database.directory\n      ? config.database.directory === \"memory://\"\n        ? \"memory://\"\n        : path.resolve(config.database.directory)\n      : path.join(ponderDir, \"pglite\");\n\n  const pglitePrintPath =\n    pgliteDir === \"memory://\" ? \"memory://\" : path.relative(rootDir, pgliteDir);\n\n  if (config.database?.kind) {\n    if (config.database.kind === \"postgres\") {\n      let connectionString: string | undefined = undefined;\n      let source: string | undefined = undefined;\n\n      if (config.database.connectionString) {\n        connectionString = config.database.connectionString;\n        source = \"from ponder.config.ts\";\n      } else if (process.env.DATABASE_PRIVATE_URL) {\n        connectionString = process.env.DATABASE_PRIVATE_URL;\n        source = \"from DATABASE_PRIVATE_URL env var\";\n      } else if (process.env.DATABASE_URL) {\n        connectionString = process.env.DATABASE_URL;\n        source = \"from DATABASE_URL env var\";\n      } else {\n        throw new Error(\n          `Invalid database configuration: 'kind' is set to 'postgres' but no connection string was provided.`,\n        );\n      }\n\n      logs.push({\n        level: \"info\",\n        msg: `Using Postgres database '${getDatabaseName(connectionString)}' (${source})`,\n      });\n\n      const poolConfig = {\n        max: config.database.poolConfig?.max ?? 30,\n        connectionString,\n      };\n\n      databaseConfig = { kind: \"postgres\", poolConfig };\n    } else {\n      logs.push({\n        level: \"info\",\n        msg: `Using PGlite database in '${pglitePrintPath}' (from ponder.config.ts)`,\n      });\n\n      databaseConfig = { kind: \"pglite\", options: { dataDir: pgliteDir } };\n    }\n  } else {\n    let connectionString: string | undefined = undefined;\n    let source: string | undefined = undefined;\n    if (process.env.DATABASE_PRIVATE_URL) {\n      connectionString = process.env.DATABASE_PRIVATE_URL;\n      source = \"from DATABASE_PRIVATE_URL env var\";\n    } else if (process.env.DATABASE_URL) {\n      connectionString = process.env.DATABASE_URL;\n      source = \"from DATABASE_URL env var\";\n    }\n\n    // If either of the DATABASE_URL env vars are set, use Postgres.\n    if (connectionString !== undefined) {\n      logs.push({\n        level: \"info\",\n        msg: `Using Postgres database ${getDatabaseName(connectionString)} (${source})`,\n      });\n\n      const poolConfig = { max: 30, connectionString };\n\n      databaseConfig = { kind: \"postgres\", poolConfig };\n    } else {\n      // Fall back to PGlite.\n      logs.push({\n        level: \"info\",\n        msg: `Using PGlite database at ${pglitePrintPath} (default)`,\n      });\n\n      databaseConfig = { kind: \"pglite\", options: { dataDir: pgliteDir } };\n    }\n  }\n\n  const networks: Network[] = await Promise.all(\n    Object.entries(config.networks).map(async ([networkName, network]) => {\n      const { chainId, transport } = network;\n\n      const defaultChain =\n        Object.values(chains).find((c) =>\n          \"id\" in c ? c.id === chainId : false,\n        ) ?? chains.mainnet!;\n      const chain = { ...defaultChain, name: networkName, id: chainId };\n\n      // Note: This can throw.\n      const rpcUrls = await getRpcUrlsForClient({ transport, chain });\n      rpcUrls.forEach((rpcUrl) => {\n        if (isRpcUrlPublic(rpcUrl)) {\n          logs.push({\n            level: \"warn\",\n            msg: `Network '${networkName}' is using a public RPC URL (${rpcUrl}). Most apps require an RPC URL with a higher rate limit.`,\n          });\n        }\n      });\n\n      if (\n        network.pollingInterval !== undefined &&\n        network.pollingInterval! < 100\n      ) {\n        throw new Error(\n          `Invalid 'pollingInterval' for network '${networkName}. Expected 100 milliseconds or greater, got ${network.pollingInterval} milliseconds.`,\n        );\n      }\n\n      return {\n        name: networkName,\n        chainId,\n        chain,\n        transport: network.transport({ chain }),\n        maxRequestsPerSecond: network.maxRequestsPerSecond ?? 50,\n        pollingInterval: network.pollingInterval ?? 1_000,\n        finalityBlockCount: getFinalityBlockCount({ chainId }),\n        disableCache: network.disableCache ?? false,\n      } satisfies Network;\n    }),\n  );\n\n  // Validate and build indexing functions\n  let indexingFunctionCount = 0;\n  const indexingFunctions: IndexingFunctions = {};\n\n  for (const { name: eventName, fn } of rawIndexingFunctions) {\n    const eventNameComponents = eventName.includes(\".\")\n      ? eventName.split(\".\")\n      : eventName.split(\":\");\n    const [sourceName, sourceEventName] = eventNameComponents;\n    if (eventNameComponents.length !== 2 || !sourceName || !sourceEventName) {\n      throw new Error(\n        `Validation failed: Invalid event '${eventName}', expected format '{sourceName}:{eventName}' or '{sourceName}.{eventName}'.`,\n      );\n    }\n\n    if (eventName in indexingFunctions) {\n      throw new Error(\n        `Validation failed: Multiple indexing functions registered for event '${eventName}'.`,\n      );\n    }\n\n    // Validate that the indexing function uses a sourceName that is present in the config.\n    const matchedSourceName = Object.keys({\n      ...(config.contracts ?? {}),\n      ...(config.blocks ?? {}),\n    }).find((_sourceName) => _sourceName === sourceName);\n\n    if (!matchedSourceName) {\n      // Multi-network has N sources, but the hint here should not have duplicates.\n      const uniqueSourceNames = dedupe(\n        Object.keys({ ...(config.contracts ?? {}), ...(config.blocks ?? {}) }),\n      );\n      throw new Error(\n        `Validation failed: Invalid source name '${sourceName}'. Got '${sourceName}', expected one of [${uniqueSourceNames\n          .map((n) => `'${n}'`)\n          .join(\", \")}].`,\n      );\n    }\n\n    indexingFunctions[eventName] = fn;\n    indexingFunctionCount += 1;\n  }\n\n  if (indexingFunctionCount === 0) {\n    logs.push({ level: \"warn\", msg: \"No indexing functions were registered.\" });\n  }\n\n  const contractSources: ContractSource[] = Object.entries(\n    config.contracts ?? {},\n  )\n    // First, apply any network-specific overrides and flatten the result.\n    .flatMap(([contractName, contract]) => {\n      if (contract.network === null || contract.network === undefined) {\n        throw new Error(\n          `Validation failed: Network for contract '${contractName}' is null or undefined. Expected one of [${networks\n            .map((n) => `'${n.name}'`)\n            .join(\", \")}].`,\n        );\n      }\n\n      const startBlockMaybeNan = contract.startBlock ?? 0;\n      const startBlock = Number.isNaN(startBlockMaybeNan)\n        ? 0\n        : startBlockMaybeNan;\n      const endBlockMaybeNan = contract.endBlock;\n      const endBlock = Number.isNaN(endBlockMaybeNan)\n        ? undefined\n        : endBlockMaybeNan;\n\n      if (endBlock !== undefined && endBlock < startBlock) {\n        throw new Error(\n          `Validation failed: Start block for contract '${contractName}' is after end block (${startBlock} > ${endBlock}).`,\n        );\n      }\n\n      // Single network case.\n      if (typeof contract.network === \"string\") {\n        return {\n          id: `log_${contractName}_${contract.network}`,\n          name: contractName,\n          networkName: contract.network,\n          abi: contract.abi,\n\n          address: \"address\" in contract ? contract.address : undefined,\n          factory: \"factory\" in contract ? contract.factory : undefined,\n          filter: contract.filter,\n\n          includeTransactionReceipts:\n            contract.includeTransactionReceipts ?? false,\n          includeCallTraces: contract.includeCallTraces ?? false,\n\n          startBlock,\n          endBlock,\n        };\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"contracts\"][string][\"network\"], string>[string]\n      >;\n\n      // Multiple networks case.\n      return Object.entries(contract.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => {\n          const startBlockMaybeNan =\n            overrides.startBlock ?? contract.startBlock ?? 0;\n          const startBlock = Number.isNaN(startBlockMaybeNan)\n            ? 0\n            : startBlockMaybeNan;\n          const endBlockMaybeNan = overrides.endBlock ?? contract.endBlock;\n          const endBlock = Number.isNaN(endBlockMaybeNan)\n            ? undefined\n            : endBlockMaybeNan;\n\n          if (endBlock !== undefined && endBlock < startBlock) {\n            throw new Error(\n              `Validation failed: Start block for contract '${contractName}' is after end block (${startBlock} > ${endBlock}).`,\n            );\n          }\n\n          return {\n            name: contractName,\n            networkName,\n            abi: contract.abi,\n\n            address:\n              (\"address\" in overrides ? overrides?.address : undefined) ??\n              (\"address\" in contract ? contract.address : undefined),\n            factory:\n              (\"factory\" in overrides ? overrides.factory : undefined) ??\n              (\"factory\" in contract ? contract.factory : undefined),\n            filter: overrides.filter ?? contract.filter,\n\n            includeTransactionReceipts:\n              overrides.includeTransactionReceipts ??\n              contract.includeTransactionReceipts ??\n              false,\n            includeCallTraces:\n              overrides.includeCallTraces ??\n              contract.includeCallTraces ??\n              false,\n\n            startBlock,\n            endBlock,\n          };\n        });\n    })\n    // Second, build and validate the factory or log source.\n    .flatMap((rawContract): ContractSource[] => {\n      const network = networks.find((n) => n.name === rawContract.networkName);\n      if (!network) {\n        throw new Error(\n          `Validation failed: Invalid network for contract '${\n            rawContract.name\n          }'. Got '${rawContract.networkName}', expected one of [${networks\n            .map((n) => `'${n.name}'`)\n            .join(\", \")}].`,\n        );\n      }\n\n      // Get indexing function that were registered for this contract\n      const registeredLogEvents: string[] = [];\n      const registeredCallTraceEvents: string[] = [];\n      for (const eventName of Object.keys(indexingFunctions)) {\n        // log event\n        if (eventName.includes(\":\")) {\n          const [logContractName, logEventName] = eventName.split(\":\") as [\n            string,\n            string,\n          ];\n          if (\n            logContractName === rawContract.name &&\n            logEventName !== \"setup\"\n          ) {\n            registeredLogEvents.push(logEventName);\n          }\n        }\n\n        // call trace event\n        if (eventName.includes(\".\")) {\n          const [functionContractName, functionName] = eventName.split(\".\") as [\n            string,\n            string,\n          ];\n          if (functionContractName === rawContract.name) {\n            registeredCallTraceEvents.push(functionName);\n          }\n        }\n      }\n\n      // Note: This can probably throw for invalid ABIs. Consider adding explicit ABI validation before this line.\n      const abiEvents = buildAbiEvents({ abi: rawContract.abi });\n      const abiFunctions = buildAbiFunctions({ abi: rawContract.abi });\n\n      const registeredEventSelectors: Hex[] = [];\n      // Validate that the registered log events exist in the abi\n      for (const logEvent of registeredLogEvents) {\n        const abiEvent = abiEvents.bySafeName[logEvent];\n        if (abiEvent === undefined) {\n          throw new Error(\n            `Validation failed: Event name for event '${logEvent}' not found in the contract ABI. Got '${logEvent}', expected one of [${Object.keys(\n              abiEvents.bySafeName,\n            )\n              .map((eventName) => `'${eventName}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        registeredEventSelectors.push(abiEvent.selector);\n      }\n\n      const registeredFunctionSelectors: Hex[] = [];\n      for (const _function of registeredCallTraceEvents) {\n        const abiFunction = abiFunctions.bySafeName[_function];\n        if (abiFunction === undefined) {\n          throw new Error(\n            `Validation failed: Function name for function '${_function}' not found in the contract ABI. Got '${_function}', expected one of [${Object.keys(\n              abiFunctions.bySafeName,\n            )\n              .map((eventName) => `'${eventName}'`)\n              .join(\", \")}].`,\n          );\n        }\n\n        registeredFunctionSelectors.push(abiFunction.selector);\n      }\n\n      let topics: LogTopic[] = [registeredEventSelectors];\n\n      if (rawContract.filter !== undefined) {\n        if (\n          Array.isArray(rawContract.filter.event) &&\n          rawContract.filter.args !== undefined\n        ) {\n          throw new Error(\n            `Validation failed: Event filter for contract '${rawContract.name}' cannot contain indexed argument values if multiple events are provided.`,\n          );\n        }\n\n        const filterSafeEventNames = Array.isArray(rawContract.filter.event)\n          ? rawContract.filter.event\n          : [rawContract.filter.event];\n\n        for (const filterSafeEventName of filterSafeEventNames) {\n          const abiEvent = abiEvents.bySafeName[filterSafeEventName];\n          if (!abiEvent) {\n            throw new Error(\n              `Validation failed: Invalid filter for contract '${\n                rawContract.name\n              }'. Got event name '${filterSafeEventName}', expected one of [${Object.keys(\n                abiEvents.bySafeName,\n              )\n                .map((n) => `'${n}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        // TODO: Explicit validation of indexed argument value format (array or object).\n        // The first element of the array return from `buildTopics` being defined\n        // is an invariant of the current filter design.\n        // Note: This can throw.\n        const [topic0FromFilter, ...topicsFromFilter] = buildTopics(\n          rawContract.abi,\n          rawContract.filter,\n        ) as [Exclude<LogTopic, null>, ...LogTopic[]];\n\n        const filteredEventSelectors = Array.isArray(topic0FromFilter)\n          ? topic0FromFilter\n          : [topic0FromFilter];\n\n        // Validate that the topic0 value defined by the `eventFilter` is a superset of the\n        // registered indexing functions. Simply put, confirm that no indexing function is\n        // defined for a log event that is excluded by the filter.\n        for (const registeredEventSelector of registeredEventSelectors) {\n          if (!filteredEventSelectors.includes(registeredEventSelector)) {\n            const logEventName =\n              abiEvents.bySelector[registeredEventSelector]!.safeName;\n\n            throw new Error(\n              `Validation failed: Event '${logEventName}' is excluded by the event filter defined on the contract '${\n                rawContract.name\n              }'. Got '${logEventName}', expected one of [${filteredEventSelectors\n                .map((s) => abiEvents.bySelector[s]!.safeName)\n                .map((eventName) => `'${eventName}'`)\n                .join(\", \")}].`,\n            );\n          }\n        }\n\n        topics = [registeredEventSelectors, ...topicsFromFilter];\n      }\n\n      const contractMetadata = {\n        type: \"contract\",\n        abi: rawContract.abi,\n        abiEvents,\n        abiFunctions,\n        name: rawContract.name,\n        networkName: rawContract.networkName,\n      } as const;\n\n      const resolvedFactory = rawContract?.factory;\n      const resolvedAddress = rawContract?.address;\n\n      if (resolvedFactory !== undefined && resolvedAddress !== undefined) {\n        throw new Error(\n          `Validation failed: Contract '${contractMetadata.name}' cannot specify both 'factory' and 'address' options.`,\n        );\n      }\n\n      if (resolvedFactory) {\n        // Note that this can throw.\n        const logFactory = buildLogFactory({\n          chainId: network.chainId,\n          ...resolvedFactory,\n        });\n\n        const logSource = {\n          ...contractMetadata,\n          filter: {\n            type: \"log\",\n            chainId: network.chainId,\n            address: logFactory,\n            topics,\n            includeTransactionReceipts: rawContract.includeTransactionReceipts,\n            fromBlock: rawContract.startBlock,\n            toBlock: rawContract.endBlock,\n          },\n        } satisfies ContractSource;\n\n        if (rawContract.includeCallTraces) {\n          return [\n            logSource,\n            {\n              ...contractMetadata,\n              filter: {\n                type: \"callTrace\",\n                chainId: network.chainId,\n                fromAddress: undefined,\n                toAddress: logFactory,\n                functionSelectors: registeredFunctionSelectors,\n                includeTransactionReceipts:\n                  rawContract.includeTransactionReceipts,\n                fromBlock: rawContract.startBlock,\n                toBlock: rawContract.endBlock,\n              },\n            } satisfies ContractSource,\n          ];\n        }\n\n        return [logSource];\n      }\n\n      if (resolvedAddress !== undefined) {\n        for (const address of Array.isArray(resolvedAddress)\n          ? resolvedAddress\n          : [resolvedAddress]) {\n          if (!address.startsWith(\"0x\"))\n            throw new Error(\n              `Validation failed: Invalid prefix for address '${address}'. Got '${address.slice(\n                0,\n                2,\n              )}', expected '0x'.`,\n            );\n          if (address.length !== 42)\n            throw new Error(\n              `Validation failed: Invalid length for address '${address}'. Got ${address.length}, expected 42 characters.`,\n            );\n        }\n      }\n\n      const validatedAddress = Array.isArray(resolvedAddress)\n        ? resolvedAddress.map((r) => toLowerCase(r))\n        : resolvedAddress !== undefined\n          ? toLowerCase(resolvedAddress)\n          : undefined;\n\n      const logSource = {\n        ...contractMetadata,\n        filter: {\n          type: \"log\",\n          chainId: network.chainId,\n          address: validatedAddress,\n          topics,\n          includeTransactionReceipts: rawContract.includeTransactionReceipts,\n          fromBlock: rawContract.startBlock,\n          toBlock: rawContract.endBlock,\n        },\n      } satisfies ContractSource;\n\n      if (rawContract.includeCallTraces) {\n        return [\n          logSource,\n          {\n            ...contractMetadata,\n            filter: {\n              type: \"callTrace\",\n              chainId: network.chainId,\n              fromAddress: undefined,\n              toAddress: Array.isArray(validatedAddress)\n                ? validatedAddress\n                : validatedAddress === undefined\n                  ? undefined\n                  : [validatedAddress],\n              functionSelectors: registeredFunctionSelectors,\n              includeTransactionReceipts:\n                rawContract.includeTransactionReceipts,\n              fromBlock: rawContract.startBlock,\n              toBlock: rawContract.endBlock,\n            },\n          } satisfies ContractSource,\n        ];\n      } else return [logSource];\n    })\n    // Remove sources with no registered indexing functions\n    .filter((source) => {\n      const hasRegisteredIndexingFunctions =\n        source.filter.type === \"callTrace\"\n          ? source.filter.functionSelectors.length !== 0\n          : source.filter.topics[0]?.length !== 0;\n      if (!hasRegisteredIndexingFunctions) {\n        logs.push({\n          level: \"debug\",\n          msg: `No indexing functions were registered for '${\n            source.name\n          }' ${source.filter.type === \"callTrace\" ? \"call traces\" : \"logs\"}`,\n        });\n      }\n      return hasRegisteredIndexingFunctions;\n    });\n\n  const blockSources: BlockSource[] = Object.entries(config.blocks ?? {})\n    .flatMap(([sourceName, blockSourceConfig]) => {\n      const startBlockMaybeNan = blockSourceConfig.startBlock ?? 0;\n      const startBlock = Number.isNaN(startBlockMaybeNan)\n        ? 0\n        : startBlockMaybeNan;\n      const endBlockMaybeNan = blockSourceConfig.endBlock;\n      const endBlock = Number.isNaN(endBlockMaybeNan)\n        ? undefined\n        : endBlockMaybeNan;\n\n      if (endBlock !== undefined && endBlock < startBlock) {\n        throw new Error(\n          `Validation failed: Start block for block source '${sourceName}' is after end block (${startBlock} > ${endBlock}).`,\n        );\n      }\n\n      if (typeof blockSourceConfig.network === \"string\") {\n        const network = networks.find(\n          (n) => n.name === blockSourceConfig.network,\n        );\n        if (!network) {\n          throw new Error(\n            `Validation failed: Invalid network for block source '${sourceName}'. Got '${\n              blockSourceConfig.network\n            }', expected one of [${networks.map((n) => `'${n.name}'`).join(\", \")}].`,\n          );\n        }\n\n        const intervalMaybeNan = blockSourceConfig.interval ?? 1;\n        const interval = Number.isNaN(intervalMaybeNan) ? 0 : intervalMaybeNan;\n\n        if (!Number.isInteger(interval) || interval === 0) {\n          throw new Error(\n            `Validation failed: Invalid interval for block source '${sourceName}'. Got ${interval}, expected a non-zero integer.`,\n          );\n        }\n\n        return {\n          type: \"block\",\n          name: sourceName,\n          networkName: blockSourceConfig.network,\n          filter: {\n            type: \"block\",\n            chainId: network.chainId,\n            interval: interval,\n            offset: startBlock % interval,\n            fromBlock: startBlock,\n            toBlock: endBlock,\n          },\n        } satisfies BlockSource;\n      }\n\n      type DefinedNetworkOverride = NonNullable<\n        Exclude<Config[\"blocks\"][string][\"network\"], string>[string]\n      >;\n\n      return Object.entries(blockSourceConfig.network)\n        .filter((n): n is [string, DefinedNetworkOverride] => !!n[1])\n        .map(([networkName, overrides]) => {\n          const network = networks.find((n) => n.name === networkName);\n          if (!network) {\n            throw new Error(\n              `Validation failed: Invalid network for block source '${sourceName}'. Got '${networkName}', expected one of [${networks\n                .map((n) => `'${n.name}'`)\n                .join(\", \")}].`,\n            );\n          }\n\n          const startBlockMaybeNan =\n            overrides.startBlock ?? blockSourceConfig.startBlock ?? 0;\n          const startBlock = Number.isNaN(startBlockMaybeNan)\n            ? 0\n            : startBlockMaybeNan;\n          const endBlockMaybeNan =\n            overrides.endBlock ?? blockSourceConfig.endBlock;\n          const endBlock = Number.isNaN(endBlockMaybeNan)\n            ? undefined\n            : endBlockMaybeNan;\n\n          if (endBlock !== undefined && endBlock < startBlock) {\n            throw new Error(\n              `Validation failed: Start block for block source '${sourceName}' is after end block (${startBlock} > ${endBlock}).`,\n            );\n          }\n\n          const intervalMaybeNan =\n            overrides.interval ?? blockSourceConfig.interval ?? 0;\n          const interval = Number.isNaN(intervalMaybeNan)\n            ? 0\n            : intervalMaybeNan;\n\n          if (!Number.isInteger(interval) || interval === 0) {\n            throw new Error(\n              `Validation failed: Invalid interval for block source '${sourceName}'. Got ${interval}, expected a non-zero integer.`,\n            );\n          }\n\n          return {\n            type: \"block\",\n            name: sourceName,\n            networkName,\n            filter: {\n              type: \"block\",\n              chainId: network.chainId,\n              interval: interval,\n              offset: startBlock % interval,\n              fromBlock: startBlock,\n              toBlock: endBlock,\n            },\n          } satisfies BlockSource;\n        });\n    })\n    .filter((blockSource) => {\n      const hasRegisteredIndexingFunction =\n        indexingFunctions[`${blockSource.name}:block`] !== undefined;\n      if (!hasRegisteredIndexingFunction) {\n        logs.push({\n          level: \"debug\",\n          msg: `No indexing functions were registered for '${blockSource.name}' blocks`,\n        });\n      }\n      return hasRegisteredIndexingFunction;\n    });\n\n  const sources = [...contractSources, ...blockSources];\n\n  // Filter out any networks that don't have any sources registered.\n  const networksWithSources = networks.filter((network) => {\n    const hasSources = sources.some(\n      (source) => source.networkName === network.name,\n    );\n    if (!hasSources) {\n      logs.push({\n        level: \"warn\",\n        msg: `No sources registered for network '${network.name}'`,\n      });\n    }\n    return hasSources;\n  });\n\n  if (Object.keys(indexingFunctions).length === 0) {\n    throw new Error(\n      \"Validation failed: Found 0 registered indexing functions.\",\n    );\n  }\n\n  return {\n    databaseConfig,\n    networks: networksWithSources,\n    sources,\n    indexingFunctions,\n    logs,\n  };\n}\n\nexport async function safeBuildConfigAndIndexingFunctions({\n  config,\n  rawIndexingFunctions,\n  options,\n}: {\n  config: Config;\n  rawIndexingFunctions: RawIndexingFunctions;\n  options: Pick<Options, \"rootDir\" | \"ponderDir\">;\n}) {\n  try {\n    const result = await buildConfigAndIndexingFunctions({\n      config,\n      rawIndexingFunctions,\n      options,\n    });\n\n    return {\n      status: \"success\",\n      sources: result.sources,\n      networks: result.networks,\n      indexingFunctions: result.indexingFunctions,\n      databaseConfig: result.databaseConfig,\n      logs: result.logs,\n    } as const;\n  } catch (_error) {\n    const buildError = new BuildError((_error as Error).message);\n    buildError.stack = undefined;\n    return { status: \"error\", error: buildError } as const;\n  }\n}\n\nfunction getDatabaseName(connectionString: string) {\n  const parsed = (parse as unknown as typeof parse.parse)(connectionString);\n  return `${parsed.host}:${parsed.port}/${parsed.database}`;\n}\n","import * as _chains from \"viem/chains\";\n\nexport const chains = _chains as unknown as Record<string, _chains.Chain>;\n","import { chains } from \"@/utils/chains.js\";\nimport type { Chain, Client, Transport } from \"viem\";\n\nexport type Network = {\n  name: string;\n  chainId: number;\n  chain: Chain;\n  transport: ReturnType<Transport>;\n  pollingInterval: number;\n  maxRequestsPerSecond: number;\n  finalityBlockCount: number;\n  disableCache: boolean;\n};\n\n/**\n * Returns the number of blocks that must pass before a block is considered final.\n * Note that a value of `0` indicates that blocks are considered final immediately.\n *\n * @param network The network to get the finality block count for.\n * @returns The finality block count.\n */\nexport function getFinalityBlockCount({ chainId }: { chainId: number }) {\n  let finalityBlockCount: number;\n  switch (chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      finalityBlockCount = 65;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      finalityBlockCount = 200;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 42170:\n    case 421611:\n    case 421613:\n      finalityBlockCount = 240;\n      break;\n    default:\n      // Assume a 2-second block time, e.g. OP stack chains.\n      finalityBlockCount = 30;\n  }\n\n  return finalityBlockCount;\n}\n\n/**\n * Returns the list of RPC URLs backing a Transport.\n *\n * @param transport A viem Transport.\n * @returns Array of RPC URLs.\n */\nexport async function getRpcUrlsForClient(parameters: {\n  transport: Transport;\n  chain: Chain;\n}) {\n  // This is how viem converts a Transport into the Client.transport type.\n  const { config, value } = parameters.transport({\n    chain: parameters.chain,\n    pollingInterval: 4_000, // default viem value\n    retryCount: 0,\n  });\n  const transport = { ...config, ...value } as Client[\"transport\"];\n\n  async function getRpcUrlsForTransport(transport: Client[\"transport\"]) {\n    switch (transport.type) {\n      case \"http\": {\n        return [transport.url ?? parameters.chain.rpcUrls.default.http[0]];\n      }\n      case \"webSocket\": {\n        try {\n          const socket = await transport.getSocket();\n          return [socket.url];\n        } catch (e) {\n          const symbol = Object.getOwnPropertySymbols(e).find(\n            (symbol) => symbol.toString() === \"Symbol(kTarget)\",\n          );\n          if (!symbol) return [];\n          const url = (e as any)[symbol]?._url;\n          if (!url) return [];\n          return [url.replace(/\\/$/, \"\")];\n        }\n      }\n      case \"fallback\": {\n        // This is how viem converts a TransportConfig into the Client.transport type.\n        const fallbackTransports = transport.transports.map((t: any) => ({\n          ...t.config,\n          ...t.value,\n        })) as Client[\"transport\"][];\n\n        const urls: (string | undefined)[] = [];\n        for (const fallbackTransport of fallbackTransports) {\n          urls.push(...(await getRpcUrlsForTransport(fallbackTransport)));\n        }\n\n        return urls;\n      }\n      default: {\n        // TODO: Consider logging a warning here. This will catch \"custom\" and unknown transports,\n        // which we might not want to support.\n        return [];\n      }\n    }\n  }\n\n  return getRpcUrlsForTransport(transport);\n}\n\nlet publicRpcUrls: Set<string> | undefined = undefined;\n\n/**\n * Returns `true` if the RPC URL is found in the list of public RPC URLs\n * included in viem/chains. Handles both HTTP and WebSocket RPC URLs.\n *\n * @param rpcUrl An RPC URL.\n * @returns Boolean indicating if the RPC URL is public.\n */\nexport function isRpcUrlPublic(rpcUrl: string | undefined) {\n  if (rpcUrl === undefined) return true;\n\n  if (!publicRpcUrls) {\n    // By default, viem uses `chain.default.{http|webSocket}.[0]` if it exists.\n    publicRpcUrls = Object.values(chains).reduce<Set<string>>((acc, chain) => {\n      chain.rpcUrls.default.http.forEach((httpRpcUrl) => {\n        acc.add(httpRpcUrl);\n      });\n\n      (\n        (chain.rpcUrls.default as unknown as { webSocket?: string[] })\n          .webSocket ?? []\n      ).forEach((webSocketRpcUrl) => {\n        acc.add(webSocketRpcUrl);\n      });\n\n      return acc;\n    }, new Set<string>());\n  }\n\n  return publicRpcUrls.has(rpcUrl);\n}\n","/**\n * Returns a Set containing all the duplicate elements in an array of strings.\n * @param arr - The input array of strings.\n * @returns A Set object containing the duplicate elements found in the input array.\n */\nexport function getDuplicateElements(arr: string[]): Set<string> {\n  const uniqueElements = new Set<string>();\n  const duplicates = new Set<string>();\n\n  arr.forEach((element: string) => {\n    if (uniqueElements.has(element)) {\n      duplicates.add(element);\n    } else {\n      uniqueElements.add(element);\n    }\n  });\n\n  return duplicates;\n}\n","import { getDuplicateElements } from \"@/utils/duplicates.js\";\nimport {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  formatAbiItem,\n} from \"abitype\";\nimport {\n  type GetEventArgs,\n  type Hex,\n  type LogTopic,\n  encodeEventTopics,\n  getAbiItem,\n  getEventSelector,\n  getFunctionSelector,\n  parseAbiItem,\n} from \"viem\";\nimport type { Config } from \"../config/config.js\";\n\n/**\n * Fix issue with Array.isArray not checking readonly arrays\n * {@link https://github.com/microsoft/TypeScript/issues/17002}\n */\ndeclare global {\n  interface ArrayConstructor {\n    isArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>;\n  }\n}\n\ntype AbiEventMeta = {\n  // Event name (if no overloads) or full event signature (if name is overloaded).\n  // This is the event name used when registering indexing functions using `ponder.on(\"ContractName:EventName\", ...)`\n  safeName: string;\n  // Full event signature, e.g. `event Deposit(address indexed from,bytes32 indexed id,uint value);`\n  signature: string;\n  // Keccak256 hash of the event signature (topic[0]).\n  selector: Hex;\n  // ABI item used for decoding raw logs.\n  item: AbiEvent;\n};\n\ntype AbiFunctionMeta = {\n  // Function name (if no overloads) or full function signature (if name is overloaded).\n  // This is the function name used when registering indexing functions using `ponder.on(\"ContractName.FunctionName\", ...)`\n  safeName: string;\n  // Full function signature, e.g. `function transfer(address to,uint256 amount)`\n  signature: string;\n  // Keccak256 hash of the function signature.\n  selector: Hex;\n  // ABI item used for decoding input and output data.\n  item: AbiFunction;\n};\n\nexport type AbiEvents = {\n  bySafeName: { [key: string]: AbiEventMeta | undefined };\n  bySelector: { [key: Hex]: AbiEventMeta | undefined };\n};\n\nexport type AbiFunctions = {\n  bySafeName: { [key: string]: AbiFunctionMeta | undefined };\n  bySelector: { [key: Hex]: AbiFunctionMeta | undefined };\n};\n\nexport const buildAbiEvents = ({ abi }: { abi: Abi }) => {\n  const abiEvents = abi\n    .filter((item): item is AbiEvent => item.type === \"event\")\n    .filter((item) => item.anonymous === undefined || item.anonymous === false);\n\n  const overloadedEventNames = getDuplicateElements(\n    abiEvents.map((item) => item.name),\n  );\n\n  return abiEvents.reduce<AbiEvents>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedEventNames.has(item.name)\n        ? signature.split(\"event \")[1]!\n        : item.name;\n      const selector = getEventSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n\nexport function buildTopics(\n  abi: Abi,\n  filter: NonNullable<Config[\"contracts\"][string][\"filter\"]>,\n): LogTopic[] {\n  if (Array.isArray(filter.event)) {\n    // List of event signatures\n    return [\n      filter.event.map((event) => getEventSelector(findAbiEvent(abi, event))),\n    ];\n  } else {\n    // Single event with args\n    return encodeEventTopics({\n      abi: [findAbiEvent(abi, filter.event)],\n      args: filter.args as GetEventArgs<Abi, string>,\n    });\n  }\n}\n\n/**\n * Finds the event ABI item for the event name or event signature.\n *\n * @param eventName Event name or event signature if there are duplicates\n */\nconst findAbiEvent = (abi: Abi, eventName: string): AbiEvent => {\n  if (eventName.includes(\"(\")) {\n    // full event signature\n    return parseAbiItem(`event ${eventName}`) as AbiEvent;\n  } else {\n    return getAbiItem({ abi, name: eventName }) as AbiEvent;\n  }\n};\n\nexport const buildAbiFunctions = ({ abi }: { abi: Abi }) => {\n  const abiFunctions = abi.filter(\n    (item): item is AbiFunction => item.type === \"function\",\n  );\n\n  const overloadedFunctionNames = getDuplicateElements(\n    abiFunctions.map((item) => item.name),\n  );\n\n  return abiFunctions.reduce<AbiFunctions>(\n    (acc, item) => {\n      const signature = formatAbiItem(item);\n      const safeName = overloadedFunctionNames.has(item.name)\n        ? signature.split(\"function \")[1]!\n        : `${item.name}()`;\n      const selector = getFunctionSelector(item);\n\n      const abiEventMeta = { safeName, signature, selector, item };\n\n      acc.bySafeName[safeName] = abiEventMeta;\n      acc.bySelector[selector] = abiEventMeta;\n\n      return acc;\n    },\n    { bySafeName: {}, bySelector: {} },\n  );\n};\n","/**\n * Transforms the input string to lower case.\n */\nexport function toLowerCase<T extends string>(value: T) {\n  return value.toLowerCase() as Lowercase<T>;\n}\n","export type PromiseWithResolvers<TPromise> = {\n  resolve: (arg: TPromise) => void;\n  reject: (error: Error) => void;\n  promise: Promise<TPromise>;\n};\n\n/**\n * @description Application level polyfill.\n */\nexport const promiseWithResolvers = <\n  TPromise,\n>(): PromiseWithResolvers<TPromise> => {\n  let resolve: (arg: TPromise) => void;\n  let reject: (error: Error) => void;\n  const promise = new Promise<TPromise>((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return { resolve: resolve!, reject: reject!, promise };\n};\n","/**\n * Remove duplicate values from an array.\n *\n * @param getId callback used to calculate a unique value for an element of the array.\n *\n * @example\n * dedupe([1,1,2,3]) // [1,2,3]\n *\n * dedupe(\n *   [\n *     { a: 1, b: 2 },\n *     { a: 1, b: 2 },\n *     { a: 2, b: 2 },\n *   ],\n *   (e) => `${e.a}_${e.b}`,\n * ) // [{a: 1, b: 2}, {a: 2, b: 2}]\n *\n */\nexport function dedupe<item, id>(arr: item[], getId?: (x: item) => id): item[] {\n  const seen = new Set<id | item>();\n\n  return arr.filter((x) => {\n    if (seen.has(getId ? getId(x) : x)) return false;\n\n    seen.add(x);\n    return true;\n  });\n}\n\ndedupe(\n  [\n    { a: 1, b: 2 },\n    { a: 1, b: 2 },\n    { a: 2, b: 2 },\n  ],\n  (e) => `${e.a}_${e.b}`,\n);\n","import {\n  type PromiseWithResolvers,\n  promiseWithResolvers,\n} from \"./promiseWithResolvers.js\";\n\nexport type InnerQueue<returnType, taskType> = {\n  task: taskType;\n  resolve: (arg: returnType) => void;\n  reject: (error: Error) => void;\n}[];\n\nexport type Queue<returnType, taskType> = {\n  size: () => number;\n  pending: () => Promise<number>;\n  add: (task: taskType) => Promise<returnType>;\n  clear: () => void;\n  isStarted: () => boolean;\n  start: () => Promise<void>;\n  pause: () => void;\n  onIdle: () => Promise<void>;\n  onEmpty: () => Promise<void>;\n  setParameters: (\n    parameters: Pick<\n      CreateQueueParameters<unknown, unknown>,\n      \"frequency\" | \"concurrency\"\n    >,\n  ) => void;\n};\n\nexport type CreateQueueParameters<returnType, taskType> = {\n  worker: (task: taskType) => Promise<returnType>;\n  initialStart?: boolean;\n  browser?: boolean;\n} & (\n  | {\n      concurrency: number;\n      frequency: number;\n    }\n  | { concurrency: number; frequency?: undefined }\n  | { concurrency?: undefined; frequency: number }\n);\n\nconst validateParameters = ({\n  concurrency,\n  frequency,\n}: Pick<\n  CreateQueueParameters<unknown, unknown>,\n  \"frequency\" | \"concurrency\"\n>) => {\n  if (concurrency === undefined && frequency === undefined) {\n    throw new Error(\n      \"Invalid queue configuration, must specify either 'concurrency' or 'frequency'.\",\n    );\n  }\n\n  if (concurrency !== undefined && concurrency <= 0) {\n    throw new Error(\n      `Invalid value for queue 'concurrency' option. Got ${concurrency}, expected a number greater than zero.`,\n    );\n  }\n\n  if (frequency !== undefined && frequency <= 0) {\n    throw new Error(\n      `Invalid value for queue 'frequency' option. Got ${frequency}, expected a number greater than zero.`,\n    );\n  }\n};\n\nexport const createQueue = <returnType, taskType = void>({\n  worker,\n  initialStart = false,\n  browser = true,\n  ..._parameters\n}: CreateQueueParameters<returnType, taskType>): Queue<\n  returnType,\n  taskType\n> => {\n  validateParameters(_parameters);\n\n  const parameters: Pick<\n    CreateQueueParameters<unknown, unknown>,\n    \"frequency\" | \"concurrency\"\n  > = _parameters;\n  let queue = new Array<InnerQueue<returnType, taskType>[number]>();\n  let pending = 0;\n  let timestamp = 0;\n  let requests = 0;\n  let isStarted = initialStart;\n\n  let timer: NodeJS.Timeout | undefined;\n\n  let emptyPromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n  let idlePromiseWithResolvers:\n    | (PromiseWithResolvers<void> & { completed: boolean })\n    | undefined = undefined;\n\n  const next = () => {\n    if (!isStarted) return;\n\n    const _timestamp = Date.now();\n\n    if (Math.floor(_timestamp / 1_000) !== timestamp) {\n      requests = 0;\n      timestamp = Math.floor(_timestamp / 1_000);\n    }\n\n    if (timer) return;\n\n    while (\n      (parameters.frequency !== undefined\n        ? requests < parameters.frequency\n        : true) &&\n      (parameters.concurrency !== undefined\n        ? pending < parameters.concurrency\n        : true) &&\n      queue.length > 0\n    ) {\n      const { task, resolve, reject } = queue.shift()!;\n\n      requests++;\n      pending++;\n\n      worker(task)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          pending--;\n\n          if (\n            idlePromiseWithResolvers !== undefined &&\n            queue.length === 0 &&\n            pending === 0\n          ) {\n            idlePromiseWithResolvers.resolve();\n            idlePromiseWithResolvers.completed = true;\n          }\n\n          browser ? next() : process.nextTick(next);\n        });\n\n      if (emptyPromiseWithResolvers !== undefined && queue.length === 0) {\n        emptyPromiseWithResolvers.resolve();\n        emptyPromiseWithResolvers.completed = true;\n      }\n    }\n\n    if (\n      parameters.frequency !== undefined &&\n      requests >= parameters.frequency\n    ) {\n      timer = setTimeout(\n        () => {\n          timer = undefined;\n          next();\n        },\n        1_000 - (_timestamp % 1_000),\n      );\n      return;\n    }\n  };\n\n  return {\n    size: () => queue.length,\n    pending: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        );\n      } else {\n        return new Promise<number>((resolve) =>\n          setImmediate(() => resolve(pending)),\n        );\n      }\n    },\n    add: (task: taskType) => {\n      const { promise, resolve, reject } = promiseWithResolvers<returnType>();\n      queue.push({ task, resolve, reject });\n\n      next();\n\n      return promise.catch((error) => {\n        Error.captureStackTrace(error);\n        throw error;\n      });\n    },\n    clear: () => {\n      queue = new Array<InnerQueue<returnType, taskType>[number]>();\n      clearTimeout(timer);\n      timer = undefined;\n    },\n    isStarted: () => isStarted,\n    start: () => {\n      if (browser) {\n        return new Promise<number>((resolve) =>\n          setTimeout(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      } else {\n        return new Promise<number>((resolve) =>\n          process.nextTick(() => resolve(pending)),\n        ).then(() => {\n          isStarted = true;\n          next();\n        });\n      }\n    },\n    pause: () => {\n      isStarted = false;\n    },\n    onIdle: () => {\n      if (\n        idlePromiseWithResolvers === undefined ||\n        idlePromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0 && pending === 0) return Promise.resolve();\n\n        idlePromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return idlePromiseWithResolvers.promise;\n    },\n    onEmpty: () => {\n      if (\n        emptyPromiseWithResolvers === undefined ||\n        emptyPromiseWithResolvers.completed\n      ) {\n        if (queue.length === 0) return Promise.resolve();\n\n        emptyPromiseWithResolvers = {\n          ...promiseWithResolvers<void>(),\n          completed: false,\n        };\n      }\n      return emptyPromiseWithResolvers.promise;\n    },\n    setParameters: (_parameters) => {\n      validateParameters(_parameters);\n\n      if (\"frequency\" in _parameters) {\n        parameters.frequency = _parameters.frequency;\n      }\n      if (\"concurrency\" in _parameters) {\n        parameters.concurrency = _parameters.concurrency;\n      }\n    },\n  } as Queue<returnType, taskType>;\n};\n","import type { AbiParameter } from \"abitype\";\nimport { InvalidAbiDecodingTypeError } from \"viem\";\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/5c95fafceffe7f399b5b5ee32119e2d78a0c8acd/src/utils/abi/decodeEventLog.ts\n\nexport function getBytesConsumedByParam(param: AbiParameter): number {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, innerType] = arrayComponents;\n\n    // If the array is dynamic or has dynamic children, it uses the\n    // dynamic encoding scheme (32 byte header).\n    if (!length || hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // If the length of the array is known in advance,\n    // and the length of each element in the array is known,\n    // the array data is encoded contiguously after the array.\n    const bytesConsumedByInnerType = getBytesConsumedByParam({\n      ...param,\n      type: innerType,\n    });\n    return length * bytesConsumedByInnerType;\n  }\n\n  if (param.type === \"tuple\") {\n    // If the tuple has dynamic children, it uses the dynamic encoding\n    // scheme (32 byte header).\n    if (hasDynamicChild(param)) {\n      return 32;\n    }\n\n    // Otherwise the tuple has static children, so we can just decode\n    // each component in sequence.\n    let consumed = 0;\n    for (const component of (param as any).components ?? []) {\n      consumed += getBytesConsumedByParam(component);\n    }\n    return consumed;\n  }\n\n  // Otherwise, it's a dynamic string or bytes (32 bytes),\n  // or a static number, address, or bool (32 bytes).\n  if (\n    param.type === \"string\" ||\n    param.type.startsWith(\"bytes\") ||\n    param.type.startsWith(\"uint\") ||\n    param.type.startsWith(\"int\") ||\n    param.type === \"address\" ||\n    param.type === \"bool\"\n  ) {\n    return 32;\n  }\n\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: \"/docs/contract/decodeAbiParameters\",\n  });\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param;\n  if (type === \"string\") return true;\n  if (type === \"bytes\") return true;\n  if (type.endsWith(\"[]\")) return true;\n\n  if (type === \"tuple\") return (param as any).components?.some(hasDynamicChild);\n\n  const arrayComponents = getArrayComponents(param.type);\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true;\n\n  return false;\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n","import type { LogFactory } from \"@/sync/source.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { getBytesConsumedByParam } from \"@/utils/offset.js\";\nimport type { AbiEvent } from \"abitype\";\nimport { type Address, getEventSelector } from \"viem\";\n\nexport function buildLogFactory({\n  address: _address,\n  event,\n  parameter,\n  chainId,\n}: {\n  address: Address | readonly Address[];\n  event: AbiEvent;\n  parameter: string;\n  chainId: number;\n}): LogFactory {\n  const address = Array.isArray(_address)\n    ? _address.map(toLowerCase)\n    : toLowerCase(_address);\n  const eventSelector = getEventSelector(event);\n\n  // Check if the provided parameter is present in the list of indexed inputs.\n  const indexedInputPosition = event.inputs\n    .filter((x) => \"indexed\" in x && x.indexed)\n    .findIndex((input) => input.name === parameter);\n\n  if (indexedInputPosition > -1) {\n    return {\n      type: \"log\",\n      chainId,\n      address,\n      eventSelector,\n      // Add 1 because inputs will not contain an element for topic0 (the signature).\n      childAddressLocation: `topic${(indexedInputPosition + 1) as 1 | 2 | 3}`,\n    };\n  }\n\n  const nonIndexedInputs = event.inputs.filter(\n    (x) => !(\"indexed\" in x && x.indexed),\n  );\n  const nonIndexedInputPosition = nonIndexedInputs.findIndex(\n    (input) => input.name === parameter,\n  );\n\n  if (nonIndexedInputPosition === -1) {\n    throw new Error(\n      `Factory event parameter not found in factory event signature. Got '${parameter}', expected one of [${event.inputs\n        .map((i) => `'${i.name}'`)\n        .join(\", \")}].`,\n    );\n  }\n\n  let offset = 0;\n  for (let i = 0; i < nonIndexedInputPosition; i++) {\n    offset += getBytesConsumedByParam(nonIndexedInputs[i]!);\n  }\n\n  return {\n    type: \"log\",\n    chainId,\n    address,\n    eventSelector,\n    childAddressLocation: `offset${offset}`,\n  };\n}\n","import type { Plugin } from \"vite\";\n\nconst virtualModule = () => `import { Hono } from \"hono\";\n\nconst ponderHono = {\n  routes: [],\n  get(...maybePathOrHandlers) {\n    this.routes.push({ method: \"GET\", pathOrHandlers: maybePathOrHandlers });\n    return this;\n  },\n  post(...maybePathOrHandlers) {\n    this.routes.push({ method: \"POST\", pathOrHandlers: maybePathOrHandlers });\n    return this;\n  },\n  use(...maybePathOrHandlers) {\n    this.routes.push({ method: \"USE\", pathOrHandlers: maybePathOrHandlers });\n    return this;\n  },\n};\n\nconst ponder = {\n  ...ponderHono,\n  hono: new Hono(),\n  fns: [],\n  on(name, fn) {\n    this.fns.push({ name, fn });\n  },\n};\n\nexport { ponder };\n`;\n\nexport const vitePluginPonder = (): Plugin => {\n  return {\n    name: \"ponder\",\n    load: (id) => {\n      if (id === \"@/generated\") return virtualModule();\n      return null;\n    },\n  };\n};\n","import { BuildError } from \"@/common/errors.js\";\nimport { type Schema, isPgEnumSym } from \"@/drizzle/index.js\";\nimport { getSql } from \"@/drizzle/kit/index.js\";\nimport { buildGraphQLSchema } from \"@/graphql/index.js\";\nimport { SQL, getTableColumns, is } from \"drizzle-orm\";\nimport {\n  PgBigSerial53,\n  PgBigSerial64,\n  type PgEnum,\n  PgSchema,\n  PgSequence,\n  PgSerial,\n  PgSmallSerial,\n  PgTable,\n  PgView,\n  getTableConfig,\n} from \"drizzle-orm/pg-core\";\n\nexport const buildSchema = ({\n  schema,\n  instanceId,\n}: { schema: Schema; instanceId: string }) => {\n  const statements = getSql(schema, instanceId);\n\n  // find and validate namespace\n\n  let namespace: string;\n\n  for (const maybeSchema of Object.values(schema)) {\n    if (is(maybeSchema, PgSchema)) {\n      namespace = maybeSchema.schemaName;\n      break;\n    }\n  }\n\n  if (namespace! === undefined) {\n    namespace = \"public\";\n  }\n\n  for (const [name, s] of Object.entries(schema)) {\n    if (is(s, PgTable)) {\n      if (namespace === \"public\" && getTableConfig(s).schema !== undefined) {\n        throw new Error(\n          `Schema validation failed: All tables must use the same schema and ${name} uses a different schema '${getTableConfig(s).schema}' than '${namespace}'.`,\n        );\n      }\n      if (namespace !== \"public\" && getTableConfig(s).schema !== namespace) {\n        throw new Error(\n          `Schema validation failed: All tables  must use the same schema and ${name} uses a different schema '${getTableConfig(s).schema ?? \"public\"}' than '${namespace}'.`,\n        );\n      }\n\n      let hasPrimaryKey = false;\n\n      for (const [columnName, column] of Object.entries(getTableColumns(s))) {\n        if (column.primary) {\n          if (hasPrimaryKey) {\n            throw new Error(\n              `Schema validation failed: '${name}' has multiple primary keys.`,\n            );\n          } else {\n            hasPrimaryKey = true;\n          }\n        }\n\n        if (\n          column instanceof PgSerial ||\n          column instanceof PgSmallSerial ||\n          column instanceof PgBigSerial53 ||\n          column instanceof PgBigSerial64\n        ) {\n          throw new Error(\n            `Schema validation failed: '${name}.${columnName}' has a serial column and serial columns are unsupported.`,\n          );\n        }\n\n        if (column.isUnique) {\n          throw new Error(\n            `Schema validation failed: '${name}.${columnName}' has a unique constraint and unique constraints are unsupported.`,\n          );\n        }\n\n        if (column.generated !== undefined) {\n          throw new Error(\n            `Schema validation failed: '${name}.${columnName}' is a generated column and generated columns are unsupported.`,\n          );\n        }\n\n        if (column.generatedIdentity !== undefined) {\n          throw new Error(\n            `Schema validation failed: '${name}.${columnName}' is a generated column and generated columns are unsupported.`,\n          );\n        }\n\n        if (column.hasDefault) {\n          if (column.default && column.default instanceof SQL) {\n            throw new Error(\n              `Schema validation failed: '${name}.${columnName}' is a default column and default columns with raw sql are unsupported.`,\n            );\n          }\n\n          if (column.defaultFn && column.defaultFn() instanceof SQL) {\n            throw new Error(\n              `Schema validation failed: '${name}.${columnName}' is a default column and default columns with raw sql are unsupported.`,\n            );\n          }\n\n          if (column.onUpdateFn && column.onUpdateFn() instanceof SQL) {\n            throw new Error(\n              `Schema validation failed: '${name}.${columnName}' is a default column and default columns with raw sql are unsupported.`,\n            );\n          }\n        }\n      }\n\n      if (getTableConfig(s).primaryKeys.length > 1) {\n        throw new Error(\n          `Schema validation failed: '${name}' has multiple primary keys.`,\n        );\n      }\n\n      if (getTableConfig(s).primaryKeys.length === 1 && hasPrimaryKey) {\n        throw new Error(\n          `Schema validation failed: '${name}' has multiple primary keys.`,\n        );\n      }\n\n      if (\n        getTableConfig(s).primaryKeys.length === 0 &&\n        hasPrimaryKey === false\n      ) {\n        throw new Error(\n          `Schema validation failed: '${name}' has no primary key. Declare one with \".primaryKey()\".`,\n        );\n      }\n\n      if (getTableConfig(s).foreignKeys.length > 0) {\n        throw new Error(\n          `Schema validation failed: '${name}' has a foreign key constraint and foreign key constraints are unsupported.`,\n        );\n      }\n\n      if (getTableConfig(s).checks.length > 0) {\n        throw new Error(\n          `Schema validation failed: '${name}' has a check constraint and check constraints are unsupported.`,\n        );\n      }\n\n      if (getTableConfig(s).uniqueConstraints.length > 0) {\n        throw new Error(\n          `Schema validation failed: '${name}' has a unique constraint and unique constraints are unsupported.`,\n        );\n      }\n    }\n\n    if (is(s, PgSequence)) {\n      throw new Error(\n        `Schema validation failed: '${name}' is a sequence and sequences are unsupported.`,\n      );\n    }\n\n    if (is(s, PgView)) {\n      throw new Error(\n        `Schema validation failed: '${name}' is a view and views are unsupported.`,\n      );\n    }\n\n    // @ts-ignore\n    if (isPgEnumSym in s) {\n      // @ts-ignore\n      if (namespace === \"public\" && (s as PgEnum<any>).schema !== undefined) {\n        throw new Error(\n          // @ts-ignore\n          `Schema validation failed: All enums must use the same schema and ${name} uses a different schema '${(s as PgEnum<any>).schema}' than '${namespace}'.`,\n        );\n      }\n      // @ts-ignore\n      if (namespace !== \"public\" && (s as PgEnum<any>).schema !== namespace) {\n        throw new Error(\n          // @ts-ignore\n          `Schema validation failed: All enums must use the same schema and ${name} uses a different schema '${(s as PgEnum<any>).schema ?? \"public\"}' than '${namespace}'.`,\n        );\n      }\n    }\n  }\n\n  return { statements, namespace };\n};\n\nexport const safeBuildSchema = ({\n  schema,\n  instanceId,\n}: { schema: Schema; instanceId: string }) => {\n  try {\n    const result = buildSchema({ schema, instanceId });\n    const graphqlSchema = buildGraphQLSchema(schema);\n\n    return {\n      status: \"success\",\n      ...result,\n      graphqlSchema,\n    } as const;\n  } catch (_error) {\n    const buildError = new BuildError((_error as Error).message);\n    buildError.stack = undefined;\n    return { status: \"error\", error: buildError } as const;\n  }\n};\n","import { readFileSync } from \"node:fs\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { parse as parseStackTrace } from \"stacktrace-parser\";\n\nclass ESBuildTransformError extends Error {\n  override name = \"ESBuildTransformError\";\n}\n\nclass ESBuildBuildError extends Error {\n  override name = \"ESBuildBuildError\";\n}\n\nclass ESBuildContextError extends Error {\n  override name = \"ESBuildContextError\";\n}\n\ntype ViteNodeError =\n  | ESBuildTransformError\n  | ESBuildBuildError\n  | ESBuildContextError\n  | Error;\n\nexport function parseViteNodeError(file: string, error: Error): ViteNodeError {\n  let resolvedError: ViteNodeError;\n\n  if (/^(Transform failed|Build failed|Context failed)/.test(error.message)) {\n    // Handle ESBuild errors based on this error message construction logic:\n    // https://github.com/evanw/esbuild/blob/4e11b50fe3178ed0a78c077df78788d66304d379/lib/shared/common.ts#L1659\n    const errorKind = error.message.split(\" with \")[0] as\n      | \"Transform failed\"\n      | \"Build failed\"\n      | \"Context failed\";\n    const innerError = error.message\n      .split(\"\\n\")\n      .slice(1)\n      .map((message) => {\n        let location: string | undefined = undefined;\n        let detail: string | undefined = undefined;\n        if (message.includes(\": ERROR: \")) {\n          // /path/to/file.ts:11:9: ERROR: Expected \")\" but found \";\"\n          const s = message.split(\": ERROR: \");\n          location = s[0];\n          detail = s[1];\n        } else {\n          // error: some error without a location\n          detail = message.slice(7);\n        }\n        return { location, detail };\n      })[0];\n\n    // If we aren't able to extract an inner error, just return the original.\n    if (!innerError) return error;\n\n    resolvedError =\n      errorKind === \"Transform failed\"\n        ? new ESBuildTransformError(innerError.detail)\n        : errorKind === \"Build failed\"\n          ? new ESBuildBuildError(innerError.detail)\n          : new ESBuildContextError(innerError.detail);\n    if (innerError.location)\n      resolvedError.stack = `    at ${innerError.location}`;\n  }\n  // If it's not an ESBuild error, it's a user-land vm.runModuleInContext execution error.\n  // Attempt to build a user-land stack trace.\n  else if (error.stack) {\n    const stackFrames = parseStackTrace(error.stack);\n\n    const userStackFrames = [];\n    for (const rawStackFrame of stackFrames) {\n      if (rawStackFrame.methodName.includes(\"ViteNodeRunner.runModule\")) break;\n      userStackFrames.push(rawStackFrame);\n    }\n\n    const userStack = userStackFrames\n      .map(({ file, lineNumber, column, methodName }) => {\n        const prefix = \"    at\";\n        const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n          column !== null ? `:${column}` : \"\"\n        }`;\n        if (methodName === null || methodName === \"<unknown>\") {\n          return `${prefix} ${path}`;\n        } else {\n          return `${prefix} ${methodName} (${path})`;\n        }\n      })\n      .join(\"\\n\");\n\n    resolvedError = error;\n    resolvedError.stack = userStack;\n  }\n  // Still a vm.runModuleInContext execution error, but no stack.\n  else {\n    resolvedError = error;\n  }\n\n  // Attempt to build a code frame for the top of the user stack. This works for\n  // both ESBuild and vm.runModuleInContext errors.\n  if (resolvedError.stack) {\n    const userStackFrames = parseStackTrace(resolvedError.stack);\n\n    let codeFrame: string | undefined = undefined;\n    for (const { file, lineNumber, column } of userStackFrames) {\n      if (file !== null && lineNumber !== null) {\n        try {\n          const sourceFileContents = readFileSync(file, { encoding: \"utf-8\" });\n          codeFrame = codeFrameColumns(\n            sourceFileContents,\n            { start: { line: lineNumber, column: column ?? undefined } },\n            { highlightCode: true },\n          );\n          break;\n        } catch (err) {\n          // No-op.\n        }\n      }\n    }\n\n    resolvedError.stack = `${resolvedError.name}: ${resolvedError.message}\\n${resolvedError.stack}`;\n    if (codeFrame) resolvedError.stack += `\\n${codeFrame}`;\n  }\n\n  // Finally, add a useful relative file name and verb to the error message.\n  const verb =\n    resolvedError.name === \"ESBuildTransformError\"\n      ? \"transforming\"\n      : resolvedError.name === \"ESBuildBuildError\" ||\n          resolvedError.name === \"ESBuildContextError\"\n        ? \"building\"\n        : \"executing\";\n\n  // This can throw with \"Cannot set property message of [object Object] which has only a getter\"\n  try {\n    resolvedError.message = `Error while ${verb} ${file}: ${resolvedError.message}`;\n  } catch (e) {}\n\n  return resolvedError;\n}\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport { create, kill, start } from \"./service.js\";\nimport type { ApiBuild, IndexingBuild, Service } from \"./service.js\";\n\nconst methods = { start, kill };\n\nexport const createBuildService = extend(create, methods);\n\nexport type BuildService = Extend<Service, typeof methods>;\n\nexport type { IndexingBuild, ApiBuild };\n","import { mkdirSync, writeFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport type { Common } from \"@/common/common.js\";\nimport { type GraphQLSchema, printSchema } from \"graphql\";\n\nexport const ponderEnv = `// This file enables type checking and editor autocomplete for this Ponder project.\n// After upgrading, you may find that changes have been made to this file.\n// If this happens, please commit the changes. Do not manually edit this file.\n// See https://ponder.sh/docs/getting-started/installation#typescript for more information.\n\ndeclare module \"@/generated\" {\n  import type { Virtual } from \"@ponder/core\";\n\n  type config = typeof import(\"./ponder.config.ts\").default;\n  type schema = typeof import(\"./ponder.schema.ts\");\n\n  export const ponder: Virtual.Registry<config, schema>;\n\n  export type EventNames = Virtual.EventNames<config>;\n  export type Event<name extends EventNames = EventNames> = Virtual.Event<\n    config,\n    name\n  >;\n  export type Context<name extends EventNames = EventNames> = Virtual.Context<\n    config,\n    schema,\n    name\n  >;\n  export type ApiContext = Virtual.ApiContext<schema>;\n  export type IndexingFunctionArgs<name extends EventNames = EventNames> =\n    Virtual.IndexingFunctionArgs<config, schema, name>;\n}\n`;\n\nexport function runCodegen({\n  common,\n  graphqlSchema,\n}: { common: Common; graphqlSchema: GraphQLSchema }) {\n  writeFileSync(\n    path.join(common.options.rootDir, \"ponder-env.d.ts\"),\n    ponderEnv,\n    \"utf8\",\n  );\n\n  common.logger.debug({\n    service: \"codegen\",\n    msg: \"Wrote new file at ponder-env.d.ts\",\n  });\n\n  mkdirSync(common.options.generatedDir, { recursive: true });\n  writeFileSync(\n    path.join(common.options.generatedDir, \"schema.graphql\"),\n    printSchema(graphqlSchema),\n    \"utf-8\",\n  );\n\n  common.logger.debug({\n    service: \"codegen\",\n    msg: \"Wrote new file at generated/schema.graphql\",\n  });\n}\n","import type { Prettify } from \"@/types/utils.js\";\nimport pc from \"picocolors\";\nimport { type DestinationStream, type LevelWithSilent, pino } from \"pino\";\n\nexport type LogMode = \"pretty\" | \"json\";\nexport type LogLevel = Prettify<LevelWithSilent>;\nexport type Logger = ReturnType<typeof createLogger>;\n\ntype Log = {\n  // Pino properties\n  level: 60 | 50 | 40 | 30 | 20 | 10;\n  time: number;\n\n  service: string;\n  msg: string;\n\n  error?: Error;\n};\n\nexport function createLogger({\n  level,\n  mode = \"pretty\",\n}: { level: LogLevel; mode?: LogMode }) {\n  const stream: DestinationStream = {\n    write(logString: string) {\n      if (mode === \"json\") {\n        console.log(logString.trimEnd());\n        return;\n      }\n\n      const log = JSON.parse(logString) as Log;\n      const prettyLog = format(log);\n      console.log(prettyLog);\n    },\n  };\n\n  const logger = pino(\n    {\n      level,\n      serializers: {\n        error: pino.stdSerializers.wrapErrorSerializer((error) => {\n          error.meta = Array.isArray(error.meta)\n            ? error.meta.join(\"\\n\")\n            : error.meta;\n          //@ts-ignore\n          error.type = undefined;\n          return error;\n        }),\n      },\n      // Removes \"pid\" and \"hostname\" properties from the log.\n      base: undefined,\n    },\n    stream,\n  );\n\n  return {\n    fatal(options: Omit<Log, \"level\" | \"time\">) {\n      logger.fatal(options);\n    },\n    error(options: Omit<Log, \"level\" | \"time\">) {\n      logger.error(options);\n    },\n    warn(options: Omit<Log, \"level\" | \"time\">) {\n      logger.warn(options);\n    },\n    info(options: Omit<Log, \"level\" | \"time\">) {\n      logger.info(options);\n    },\n    debug(options: Omit<Log, \"level\" | \"time\">) {\n      logger.debug(options);\n    },\n    trace(options: Omit<Log, \"level\" | \"time\">) {\n      logger.trace(options);\n    },\n    async kill() {},\n  };\n}\n\nconst levels = {\n  60: { label: \"FATAL\", colorLabel: pc.bgRed(\"FATAL\") },\n  50: { label: \"ERROR\", colorLabel: pc.red(\"ERROR\") },\n  40: { label: \"WARN \", colorLabel: pc.yellow(\"WARN \") },\n  30: { label: \"INFO \", colorLabel: pc.green(\"INFO \") },\n  20: { label: \"DEBUG\", colorLabel: pc.blue(\"DEBUG\") },\n  10: { label: \"TRACE\", colorLabel: pc.gray(\"TRACE\") },\n} as const;\n\nconst timeFormatter = new Intl.DateTimeFormat(undefined, {\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\",\n});\n\nconst format = (log: Log) => {\n  const time = timeFormatter.format(new Date(log.time));\n  const levelObject = levels[log.level ?? 30];\n\n  let prettyLog: string[];\n  if (pc.isColorSupported) {\n    const level = levelObject.colorLabel;\n    const service = log.service ? pc.cyan(log.service.padEnd(10, \" \")) : \"\";\n    const messageText = pc.reset(log.msg);\n\n    prettyLog = [`${pc.gray(time)} ${level} ${service} ${messageText}`];\n  } else {\n    const level = levelObject.label;\n    const service = log.service ? log.service.padEnd(10, \" \") : \"\";\n\n    prettyLog = [`${time} ${level} ${service} ${log.msg}`];\n  }\n\n  if (log.error) {\n    if (log.error.stack) {\n      prettyLog.push(log.error.stack);\n    } else {\n      prettyLog.push(`${log.error.name}: ${log.error.message}`);\n    }\n\n    if (\"where\" in log.error) {\n      prettyLog.push(`where: ${log.error.where as string}`);\n    }\n    if (\"meta\" in log.error) {\n      prettyLog.push(log.error.meta as string);\n    }\n  }\n  return prettyLog.join(\"\\n\");\n};\n","import prometheus from \"prom-client\";\n\nconst databaseQueryDurationMs = [\n  0.05, 0.1, 1, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1_000, 2_500, 5_000,\n  7_500, 10_000, 25_000,\n];\n\nconst httpRequestDurationMs = [\n  5, 10, 25, 50, 75, 100, 250, 500, 750, 1_000, 2_500, 5_000, 7_500, 10_000,\n  25_000,\n];\n\nconst httpRequestSizeBytes = [\n  10, 100, 1_000, 5_000, 10_000, 50_000, 100_000, 500_000, 1_000_000, 5_000_000,\n  10_000_000,\n];\n\nexport class MetricsService {\n  registry: prometheus.Registry;\n\n  ponder_indexing_total_seconds: prometheus.Gauge;\n  ponder_indexing_completed_seconds: prometheus.Gauge;\n  ponder_indexing_completed_events: prometheus.Gauge<\"event\">;\n\n  ponder_indexing_completed_timestamp: prometheus.Gauge;\n  ponder_indexing_has_error: prometheus.Gauge;\n\n  ponder_indexing_function_duration: prometheus.Histogram<\"event\">;\n  ponder_indexing_abi_decoding_duration: prometheus.Histogram;\n\n  ponder_sync_block: prometheus.Gauge<\"network\">;\n  ponder_sync_is_realtime: prometheus.Gauge<\"network\">;\n  ponder_sync_is_complete: prometheus.Gauge<\"network\">;\n\n  ponder_historical_duration: prometheus.Histogram<\"network\">;\n  ponder_historical_total_blocks: prometheus.Gauge<\"network\">;\n  ponder_historical_cached_blocks: prometheus.Gauge<\"network\">;\n  ponder_historical_completed_blocks: prometheus.Gauge<\"network\">;\n\n  ponder_realtime_reorg_total: prometheus.Counter<\"network\">;\n\n  ponder_database_method_duration: prometheus.Histogram<\"service\" | \"method\">;\n  ponder_database_method_error_total: prometheus.Counter<\"service\" | \"method\">;\n\n  ponder_http_server_port: prometheus.Gauge;\n  ponder_http_server_active_requests: prometheus.Gauge<\"method\" | \"path\">;\n  ponder_http_server_request_duration_ms: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_http_server_request_size_bytes: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_http_server_response_size_bytes: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n\n  ponder_rpc_request_duration: prometheus.Histogram<\"network\" | \"method\">;\n  ponder_rpc_request_lag: prometheus.Histogram<\"network\" | \"method\">;\n\n  ponder_postgres_query_total: prometheus.Counter<\"pool\">;\n  ponder_postgres_query_queue_size: prometheus.Gauge<\"pool\"> = null!;\n  ponder_postgres_pool_connections: prometheus.Gauge<\"pool\" | \"kind\"> = null!;\n\n  constructor() {\n    this.registry = new prometheus.Registry();\n\n    this.ponder_indexing_total_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_total_seconds\",\n      help: \"Total number of seconds that are required\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_seconds = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_seconds\",\n      help: \"Number of seconds that have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_events = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_events\",\n      help: \"Number of events that have been processed\",\n      labelNames: [\"network\", \"event\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_completed_timestamp = new prometheus.Gauge({\n      name: \"ponder_indexing_completed_timestamp\",\n      help: \"Timestamp through which all events have been completed\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_has_error = new prometheus.Gauge({\n      name: \"ponder_indexing_has_error\",\n      help: \"Boolean (0 or 1) indicating if there is an indexing error\",\n      registers: [this.registry],\n    });\n    this.ponder_indexing_function_duration = new prometheus.Histogram({\n      name: \"ponder_indexing_function_duration\",\n      help: \"Duration of indexing function execution\",\n      labelNames: [\"network\", \"event\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_indexing_abi_decoding_duration = new prometheus.Histogram({\n      name: \"ponder_indexing_abi_decoding_duration\",\n      help: \"Total time spent decoding log arguments and call trace arguments and results\",\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n\n    this.ponder_sync_block = new prometheus.Gauge({\n      name: \"ponder_sync_block\",\n      help: \"Closest-to-tip synced block number\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_sync_is_realtime = new prometheus.Gauge({\n      name: \"ponder_sync_is_realtime\",\n      help: \"Boolean (0 or 1) indicating if the sync is realtime mode\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_sync_is_complete = new prometheus.Gauge({\n      name: \"ponder_sync_is_complete\",\n      help: \"Boolean (0 or 1) indicating if the sync has synced all blocks\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_historical_duration = new prometheus.Histogram({\n      name: \"ponder_historical_duration\",\n      help: \"Duration of historical sync execution\",\n      labelNames: [\"network\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_historical_total_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_total_blocks\",\n      help: \"Number of blocks required for the historical sync\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_cached_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_cached_blocks\",\n      help: \"Number of blocks that were found in the cache for the historical sync\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completed_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_completed_blocks\",\n      help: \"Number of blocks that have been processed for the historical sync\",\n      labelNames: [\"network\", \"source\", \"type\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_realtime_reorg_total = new prometheus.Counter({\n      name: \"ponder_realtime_reorg_total\",\n      help: \"Count of how many re-orgs have occurred.\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_database_method_duration = new prometheus.Histogram({\n      name: \"ponder_database_method_duration\",\n      help: \"Duration of database operations\",\n      labelNames: [\"service\", \"method\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_database_method_error_total = new prometheus.Counter({\n      name: \"ponder_database_method_error_total\",\n      help: \"Total number of errors encountered during database operations\",\n      labelNames: [\"service\", \"method\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_http_server_port = new prometheus.Gauge({\n      name: \"ponder_http_server_port\",\n      help: \"Port that the server is listening on\",\n      registers: [this.registry],\n    });\n    this.ponder_http_server_active_requests = new prometheus.Gauge({\n      name: \"ponder_http_server_active_requests\",\n      help: \"Number of active HTTP server requests\",\n      labelNames: [\"method\", \"path\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_request_duration_ms = new prometheus.Histogram({\n      name: \"ponder_http_server_request_duration_ms\",\n      help: \"Duration of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_request_size_bytes = new prometheus.Histogram({\n      name: \"ponder_http_server_request_size_bytes\",\n      help: \"Size of HTTP requests received by the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeBytes,\n      registers: [this.registry],\n    });\n    this.ponder_http_server_response_size_bytes = new prometheus.Histogram({\n      name: \"ponder_http_server_response_size_bytes\",\n      help: \"Size of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeBytes,\n      registers: [this.registry],\n    });\n\n    this.ponder_rpc_request_duration = new prometheus.Histogram({\n      name: \"ponder_rpc_request_duration\",\n      help: \"Duration of RPC requests\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestDurationMs,\n      registers: [this.registry],\n    });\n    this.ponder_rpc_request_lag = new prometheus.Histogram({\n      name: \"ponder_rpc_request_lag\",\n      help: \"Time RPC requests spend waiting in the request queue\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: databaseQueryDurationMs,\n      registers: [this.registry],\n    });\n\n    this.ponder_postgres_query_total = new prometheus.Counter({\n      name: \"ponder_postgres_query_total\",\n      help: \"Total number of queries submitted to the database\",\n      labelNames: [\"pool\"] as const,\n      registers: [this.registry],\n    });\n\n    prometheus.collectDefaultMetrics({ register: this.registry });\n  }\n\n  /**\n   * Get string representation for all metrics.\n   * @returns Metrics encoded using Prometheus v0.0.4 format.\n   */\n  async getMetrics() {\n    return await this.registry.metrics();\n  }\n\n  resetIndexingMetrics() {\n    this.ponder_indexing_total_seconds.reset();\n    this.ponder_indexing_completed_seconds.reset();\n    this.ponder_indexing_completed_events.reset();\n    this.ponder_indexing_completed_timestamp.reset();\n    this.ponder_indexing_has_error.reset();\n    this.ponder_indexing_function_duration.reset();\n    this.ponder_indexing_abi_decoding_duration.reset();\n    this.ponder_sync_block.reset();\n    this.ponder_sync_is_realtime.reset();\n    this.ponder_sync_is_complete.reset();\n    this.ponder_historical_duration.reset();\n    this.ponder_historical_total_blocks.reset();\n    this.ponder_historical_cached_blocks.reset();\n    this.ponder_historical_completed_blocks.reset();\n    this.ponder_realtime_reorg_total.reset();\n    this.ponder_rpc_request_duration.reset();\n    this.ponder_rpc_request_lag.reset();\n\n    // Note: These are used by both indexing and API services.\n    this.ponder_database_method_duration.reset();\n    this.ponder_database_method_error_total.reset();\n    this.ponder_postgres_pool_connections?.reset();\n    this.ponder_postgres_query_queue_size?.reset();\n    this.ponder_postgres_query_total?.reset();\n  }\n\n  resetApiMetrics() {\n    this.ponder_http_server_port.reset();\n    this.ponder_http_server_active_requests.reset();\n    this.ponder_http_server_request_duration_ms.reset();\n    this.ponder_http_server_request_size_bytes.reset();\n    this.ponder_http_server_response_size_bytes.reset();\n\n    // TODO: Create a separate metric for API build errors,\n    // or stop using metrics for the TUI error message.\n    this.ponder_indexing_has_error.reset();\n  }\n}\n\nconst rps: { [network: string]: { count: number; timestamp: number }[] } = {};\n\nexport async function getSyncProgress(metrics: MetricsService): Promise<\n  {\n    networkName: string;\n    block: number | undefined;\n    // events: number;\n    status: \"historical\" | \"realtime\" | \"complete\";\n    progress: number;\n    eta: number | undefined;\n    rps: number;\n  }[]\n> {\n  const syncDurationMetric = await metrics.ponder_historical_duration\n    .get()\n    .then((metrics) => metrics.values);\n  const syncDurationSum: { [network: string]: number } = {};\n  for (const m of syncDurationMetric) {\n    if (m.metricName === \"ponder_historical_duration_sum\") {\n      syncDurationSum[m.labels.network!] = m.value;\n    }\n  }\n\n  const extractMetric = (\n    metric: prometheus.MetricObjectWithValues<\n      prometheus.MetricValue<\"network\">\n    >,\n    network: string,\n  ) => {\n    return metric.values.find((m) => m.labels.network === network)?.value;\n  };\n\n  const totalBlocksMetric = await metrics.ponder_historical_total_blocks.get();\n  const cachedBlocksMetric =\n    await metrics.ponder_historical_cached_blocks.get();\n  const completedBlocksMetric =\n    await metrics.ponder_historical_completed_blocks.get();\n  const syncBlockMetric = await metrics.ponder_sync_block.get();\n  const syncIsRealtimeMetrics = await metrics.ponder_sync_is_realtime.get();\n  const syncIsCompleteMetrics = await metrics.ponder_sync_is_complete.get();\n\n  const requestCount: { [network: string]: number } = {};\n  const rpcRequestMetrics = await metrics.ponder_rpc_request_duration.get();\n  for (const m of rpcRequestMetrics.values) {\n    const network = m.labels.network!;\n    if (m.metricName === \"ponder_rpc_request_duration_count\") {\n      if (requestCount[network] === undefined) {\n        requestCount[network] = 0;\n      }\n      requestCount[m.labels.network!]! += m.value;\n    }\n  }\n\n  for (const [networkName, count] of Object.entries(requestCount)) {\n    if (rps[networkName] === undefined) {\n      rps[networkName] = [{ count, timestamp: Date.now() }];\n    } else {\n      rps[networkName]!.push({ count, timestamp: Date.now() });\n    }\n\n    if (rps[networkName]!.length > 100) {\n      rps[networkName]!.shift();\n    }\n  }\n\n  return totalBlocksMetric.values.map(({ value, labels }) => {\n    const network = labels.network as string;\n    const totalBlocks = value;\n    const cachedBlocks = extractMetric(cachedBlocksMetric, network) ?? 0;\n    const completedBlocks = extractMetric(completedBlocksMetric, network) ?? 0;\n    const syncBlock = extractMetric(syncBlockMetric, network);\n    const isRealtime = extractMetric(syncIsRealtimeMetrics, network);\n    const isComplete = extractMetric(syncIsCompleteMetrics, network);\n\n    const progress =\n      totalBlocks === 0 ? 1 : (completedBlocks + cachedBlocks) / totalBlocks;\n    const elapsed = syncDurationSum[network]!;\n    const total = elapsed / (completedBlocks / (totalBlocks - cachedBlocks));\n    // The ETA is low quality if we've completed only one or two blocks.\n    const eta = completedBlocks >= 3 ? total - elapsed : undefined;\n\n    const _length = rps[labels.network!]!.length;\n    const _firstRps = rps[labels.network!]![0]!;\n    const _lastRps = rps[labels.network!]![_length - 1]!;\n\n    const requests = _lastRps.count - (_length > 1 ? _firstRps.count : 0);\n    const seconds =\n      _length === 1 ? 0.1 : (_lastRps.timestamp - _firstRps.timestamp) / 1_000;\n\n    return {\n      networkName: network,\n      block: syncBlock,\n      progress,\n      status: isComplete ? \"complete\" : isRealtime ? \"realtime\" : \"historical\",\n      eta,\n      rps: requests / seconds,\n    } as const;\n  });\n}\n\nexport async function getIndexingProgress(metrics: MetricsService) {\n  const hasErrorMetric = (await metrics.ponder_indexing_has_error.get())\n    .values[0]?.value;\n  const hasError = hasErrorMetric === 1;\n\n  const totalSeconds =\n    (await metrics.ponder_indexing_total_seconds.get()).values[0]?.value ?? 0;\n  const completedSeconds =\n    (await metrics.ponder_indexing_completed_seconds.get()).values[0]?.value ??\n    0;\n  const completedToTimestamp =\n    (await metrics.ponder_indexing_completed_timestamp.get()).values[0]!\n      .value ?? 0;\n\n  const progress = totalSeconds === 0 ? 0 : completedSeconds / totalSeconds;\n\n  const indexingCompletedEventsMetric = (\n    await metrics.ponder_indexing_completed_events.get()\n  ).values;\n  const indexingFunctionDurationMetric = (\n    await metrics.ponder_indexing_function_duration.get()\n  ).values;\n\n  const indexingDurationSum: Record<string, number> = {};\n  const indexingDurationCount: Record<string, number> = {};\n  for (const m of indexingFunctionDurationMetric) {\n    if (m.metricName === \"ponder_indexing_function_duration_sum\")\n      indexingDurationSum[m.labels.event!] = m.value;\n    if (m.metricName === \"ponder_indexing_function_duration_count\")\n      indexingDurationCount[m.labels.event!] = m.value;\n  }\n\n  const events = indexingCompletedEventsMetric.map((m) => {\n    const eventName = m.labels.event as string;\n    const count = m.value;\n\n    const durationSum = indexingDurationSum[eventName] ?? 0;\n    const durationCount = indexingDurationCount[eventName] ?? 0;\n    const averageDuration =\n      durationCount === 0 ? 0 : durationSum / durationCount;\n\n    return { eventName, count, averageDuration };\n  });\n\n  const totalEvents = events.reduce((a, e) => a + e.count, 0);\n\n  return {\n    hasError,\n    overall: {\n      completedSeconds,\n      totalSeconds,\n      progress,\n      completedToTimestamp,\n      totalEvents,\n    },\n    events,\n  };\n}\n\nexport async function getAppProgress(metrics: MetricsService): Promise<{\n  mode: \"historical\" | \"realtime\" | \"complete\" | undefined;\n  progress: number;\n  eta: number | undefined;\n}> {\n  const sync = await getSyncProgress(metrics);\n  const indexing = await getIndexingProgress(metrics);\n  const decodingSum = await metrics.ponder_indexing_abi_decoding_duration\n    .get()\n    .then(\n      (m) =>\n        m.values.find(\n          (v) => v.metricName === \"ponder_indexing_abi_decoding_duration_sum\",\n        )?.value,\n    );\n  const getEventsSum = await metrics.ponder_database_method_duration\n    .get()\n    .then(\n      (m) =>\n        m.values.find(\n          (v) =>\n            v.labels.method === \"getEvents\" &&\n            v.metricName === \"ponder_database_method_duration_sum\",\n        )?.value,\n    );\n  const indexingSum = indexing.events.reduce(\n    (acc, cur) => acc + cur.averageDuration * cur.count,\n    0,\n  );\n\n  let maxSync: (typeof sync)[number] | undefined;\n  for (const networkSync of sync) {\n    if (\n      maxSync === undefined ||\n      maxSync.eta === undefined ||\n      (networkSync.eta && networkSync.eta > maxSync.eta)\n    ) {\n      maxSync = networkSync;\n    }\n  }\n\n  const remainingSeconds =\n    indexing.overall.totalSeconds - indexing.overall.completedSeconds;\n\n  const indexingEta =\n    indexing.overall.completedSeconds === 0\n      ? undefined\n      : (((decodingSum ?? 0) + (getEventsSum ?? 0) + indexingSum) *\n          remainingSeconds) /\n        indexing.overall.completedSeconds;\n\n  const eta = sync.every((n) => n.progress === 1)\n    ? indexingEta\n    : maxSync?.eta === undefined && indexingEta === undefined\n      ? undefined\n      : maxSync?.eta === undefined && maxSync?.progress !== undefined\n        ? undefined\n        : Math.max(maxSync?.eta ?? 0, indexingEta ?? 0);\n\n  // Edge case: If all matched events occurred in the same unix timestamp (second), progress will\n  // be zero, even though indexing is complete. When this happens, totalEvents will be non-zero.\n  const indexingProgress =\n    indexing.overall.progress === 0 && indexing.overall.totalEvents > 0\n      ? 1\n      : indexing.overall.progress;\n\n  const progress = sync.every((n) => n.progress === 1)\n    ? indexingProgress\n    : maxSync?.progress === undefined\n      ? 0\n      : maxSync!.progress * indexingProgress;\n\n  return {\n    mode: sync.some((n) => n.status === \"realtime\")\n      ? \"realtime\"\n      : sync.every((n) => n.status === \"complete\")\n        ? \"complete\"\n        : sync.length === 0\n          ? undefined\n          : \"historical\",\n    progress,\n    eta,\n  };\n}\n","import path from \"node:path\";\nimport v8 from \"node:v8\";\nimport type { CliOptions } from \"@/bin/ponder.js\";\nimport type { LevelWithSilent } from \"pino\";\n\nexport type Options = {\n  command: \"dev\" | \"start\" | \"serve\" | \"codegen\";\n\n  configFile: string;\n  schemaFile: string;\n  rootDir: string;\n  indexingDir: string;\n  apiDir: string;\n  generatedDir: string;\n  ponderDir: string;\n  logDir: string;\n\n  port: number;\n  hostname?: string;\n\n  telemetryUrl: string;\n  telemetryDisabled: boolean;\n  telemetryConfigDir: string | undefined;\n\n  logLevel: LevelWithSilent;\n  logFormat: \"json\" | \"pretty\";\n\n  databaseHeartbeatInterval: number;\n  databaseHeartbeatTimeout: number;\n  databaseMaxQueryParameters: number;\n\n  factoryAddressCountThreshold: number;\n\n  indexingCacheMaxBytes: number;\n  indexingCacheFlushRatio: number;\n\n  syncStoreMaxIntervals: number;\n  syncEventsQuerySize: number;\n  syncHandoffStaleSeconds: number;\n};\n\nexport const buildOptions = ({ cliOptions }: { cliOptions: CliOptions }) => {\n  let rootDir: string;\n  if (cliOptions.root !== undefined) {\n    rootDir = path.resolve(cliOptions.root);\n  } else {\n    rootDir = path.resolve(\".\");\n  }\n\n  let logLevel: LevelWithSilent;\n  if (cliOptions.logLevel) {\n    logLevel = cliOptions.logLevel as LevelWithSilent;\n  } else if (cliOptions.trace === true) {\n    logLevel = \"trace\";\n  } else if (cliOptions.debug === true) {\n    logLevel = \"debug\";\n  } else if (\n    process.env.PONDER_LOG_LEVEL !== undefined &&\n    [\"silent\", \"fatal\", \"error\", \"warn\", \"info\", \"debug\", \"trace\"].includes(\n      process.env.PONDER_LOG_LEVEL,\n    )\n  ) {\n    logLevel = process.env.PONDER_LOG_LEVEL as LevelWithSilent;\n  } else {\n    logLevel = \"info\";\n  }\n\n  const port =\n    process.env.PORT !== undefined\n      ? Number(process.env.PORT)\n      : cliOptions.port !== undefined\n        ? cliOptions.port\n        : 42069;\n\n  const hostname = cliOptions.hostname;\n\n  return {\n    command: cliOptions.command,\n\n    rootDir,\n    configFile: path.join(rootDir, cliOptions.config),\n    schemaFile: path.join(rootDir, \"ponder.schema.ts\"),\n    indexingDir: path.join(rootDir, \"src\"),\n    apiDir: path.join(rootDir, \"src\", \"api\"),\n    generatedDir: path.join(rootDir, \"generated\"),\n    ponderDir: path.join(rootDir, \".ponder\"),\n    logDir: path.join(rootDir, \".ponder\", \"logs\"),\n\n    port,\n    hostname,\n\n    telemetryUrl: \"https://ponder.sh/api/telemetry\",\n    telemetryDisabled: Boolean(process.env.PONDER_TELEMETRY_DISABLED),\n    telemetryConfigDir: undefined,\n\n    logLevel,\n    logFormat: cliOptions.logFormat! as Options[\"logFormat\"],\n\n    databaseHeartbeatInterval: 10 * 1000,\n    databaseHeartbeatTimeout: 25 * 1000,\n    // Half of the max query parameters for PGlite\n    databaseMaxQueryParameters: 16_000,\n\n    factoryAddressCountThreshold: 1_000,\n\n    // v8.getHeapStatistics().heap_size_limit / 8, bucketed closest to 128, 256, 512, 1024, 2048 mB\n    indexingCacheMaxBytes:\n      2 **\n        Math.min(\n          Math.max(\n            Math.round(\n              Math.log2(\n                v8.getHeapStatistics().heap_size_limit / 1_024 / 1_024 / 8,\n              ),\n            ),\n            7,\n          ),\n          11,\n        ) *\n      1_024 *\n      1_024,\n    indexingCacheFlushRatio: 0.35,\n\n    syncStoreMaxIntervals: 5_000,\n    syncEventsQuerySize: 10_000,\n    syncHandoffStaleSeconds: 300,\n  } satisfies Options;\n};\n","import { exec } from \"node:child_process\";\nimport { createHash, randomBytes } from \"node:crypto\";\nimport { existsSync, readFileSync } from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\nimport { promisify } from \"node:util\";\nimport type { IndexingBuild } from \"@/build/service.js\";\nimport type { Options } from \"@/common/options.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { createQueue } from \"@ponder/common\";\nimport Conf from \"conf\";\nimport { type PM, detect, getNpmVersion } from \"detect-package-manager\";\nimport type { Logger } from \"./logger.js\";\n\nconst HEARTBEAT_INTERVAL_MS = 60_000;\n\ntype TelemetryEvent =\n  | {\n      name: \"lifecycle:session_start\";\n      properties: { cli_command: string };\n    }\n  | {\n      name: \"lifecycle:session_end\";\n      properties: { duration_seconds: number };\n    }\n  | {\n      name: \"lifecycle:heartbeat_send\";\n      properties: { duration_seconds: number };\n    };\n\ntype CommonProperties = {\n  // Identification\n  project_id: string;\n  session_id: string;\n  is_internal: boolean;\n};\n\ntype SessionProperties = {\n  // Environment and package versions\n  package_manager: string;\n  package_manager_version: string;\n  node_version: string;\n  ponder_core_version: string;\n  viem_version: string;\n  // System and hardware\n  system_platform: NodeJS.Platform;\n  system_release: string;\n  system_architecture: string;\n  cpu_count: number;\n  cpu_model: string;\n  cpu_speed: number;\n  total_memory_bytes: number;\n};\n\ntype DeviceConf = {\n  notifiedAt?: string;\n  anonymousId?: string;\n  salt?: string;\n};\n\nexport type Telemetry = ReturnType<typeof createTelemetry>;\n\nexport function createTelemetry({\n  options,\n  logger,\n}: { options: Options; logger: Logger }) {\n  if (options.telemetryDisabled) {\n    return {\n      record: (_event: TelemetryEvent) => {},\n      flush: async () => {},\n      kill: async () => {},\n    };\n  }\n\n  const conf = new Conf<DeviceConf>({\n    projectName: \"ponder\",\n    cwd: options.telemetryConfigDir,\n  });\n\n  if (conf.get(\"notifiedAt\") === undefined) {\n    conf.set(\"notifiedAt\", Date.now().toString());\n    logger.info({\n      service: \"telemetry\",\n      msg: \"Ponder collects anonymous telemetry data to identify issues and prioritize features. See https://ponder.sh/docs/advanced/telemetry for more information.\",\n    });\n  }\n\n  const sessionId = randomBytes(8).toString(\"hex\");\n\n  let anonymousId = conf.get(\"anonymousId\") as string;\n  if (anonymousId === undefined) {\n    anonymousId = randomBytes(8).toString(\"hex\");\n    conf.set(\"anonymousId\", anonymousId);\n  }\n  // Before 0.4.3, the anonymous ID was 64 characters long. Truncate it to 16\n  // here to align with new ID lengths.\n  if (anonymousId.length > 16) anonymousId = anonymousId.slice(0, 16);\n\n  let salt = conf.get(\"salt\") as string;\n  if (salt === undefined) {\n    salt = randomBytes(8).toString(\"hex\");\n    conf.set(\"salt\", salt);\n  }\n\n  // Prepend the value with a secret salt to ensure a credible one-way hash.\n  const oneWayHash = (value: string) => {\n    const hash = createHash(\"sha256\");\n    hash.update(salt);\n    hash.update(value);\n    return hash.digest(\"hex\").slice(0, 16);\n  };\n\n  const buildContext = async () => {\n    // Project ID is a one-way hash of the git remote URL OR the current working directory.\n    const gitRemoteUrl = await getGitRemoteUrl();\n    const projectIdRaw = gitRemoteUrl ?? process.cwd();\n    const projectId = oneWayHash(projectIdRaw);\n\n    const { packageManager, packageManagerVersion } = await getPackageManager();\n\n    // Attempt to find and read the users package.json file.\n    const packageJson = getPackageJson(options.rootDir);\n    const ponderCoreVersion =\n      packageJson?.dependencies?.[\"@ponder/core\"] ?? \"unknown\";\n    const viemVersion = packageJson?.dependencies?.viem ?? \"unknown\";\n\n    // Make a guess as to whether the project is internal (within the monorepo) or not.\n    const isInternal = ponderCoreVersion === \"workspace:*\";\n\n    const cpus = os.cpus();\n\n    return {\n      common: {\n        session_id: sessionId,\n        project_id: projectId,\n        is_internal: isInternal,\n      } satisfies CommonProperties,\n      session: {\n        ponder_core_version: ponderCoreVersion,\n        viem_version: viemVersion,\n        package_manager: packageManager,\n        package_manager_version: packageManagerVersion,\n        node_version: process.versions.node,\n        system_platform: os.platform(),\n        system_release: os.release(),\n        system_architecture: os.arch(),\n        cpu_count: cpus.length,\n        cpu_model: cpus.length > 0 ? cpus[0]!.model : \"unknown\",\n        cpu_speed: cpus.length > 0 ? cpus[0]!.speed : 0,\n        total_memory_bytes: os.totalmem(),\n      } satisfies SessionProperties,\n    };\n  };\n\n  let context: Awaited<ReturnType<typeof buildContext>> | undefined = undefined;\n  const contextPromise = buildContext();\n\n  const controller = new AbortController();\n  let isKilled = false;\n\n  const queue = createQueue({\n    initialStart: true,\n    concurrency: 10,\n    worker: async (event: TelemetryEvent) => {\n      const endClock = startClock();\n      try {\n        if (context === undefined) context = await contextPromise;\n\n        const properties =\n          event.name === \"lifecycle:session_start\"\n            ? { ...event.properties, ...context.common, ...context.session }\n            : { ...event.properties, ...context.common };\n\n        const body = JSON.stringify({\n          distinctId: anonymousId,\n          event: event.name,\n          properties,\n        });\n\n        await fetch(options.telemetryUrl, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body,\n          signal: controller.signal,\n        });\n        logger.trace({\n          service: \"telemetry\",\n          msg: `Sent '${event.name}' event in ${endClock()}ms`,\n        });\n      } catch (error_) {\n        const error = error_ as Error;\n        logger.trace({\n          service: \"telemetry\",\n          msg: `Failed to send '${event.name}' event after ${endClock()}ms`,\n          error,\n        });\n      }\n    },\n  });\n\n  const record = (event: TelemetryEvent) => {\n    if (isKilled) return;\n    queue.add(event);\n  };\n\n  const heartbeatInterval = setInterval(() => {\n    record({\n      name: \"lifecycle:heartbeat_send\",\n      properties: { duration_seconds: process.uptime() },\n    });\n  }, HEARTBEAT_INTERVAL_MS);\n\n  // Note that this method is only used for testing.\n  const flush = async () => {\n    await queue.onIdle();\n  };\n\n  const kill = async () => {\n    clearInterval(heartbeatInterval);\n    isKilled = true;\n    // If there are any events in the queue that have not started, drop them.\n    queue.clear();\n    // Wait at most 1 second for any in-flight events to complete.\n    await Promise.race([queue.onIdle(), wait(1_000)]);\n  };\n\n  return { record, flush, kill };\n}\n\nasync function getPackageManager() {\n  let packageManager: PM = \"unknown\" as PM;\n  let packageManagerVersion = \"unknown\";\n  try {\n    packageManager = await detect();\n    packageManagerVersion = await getNpmVersion(packageManager);\n  } catch (e) {}\n  return { packageManager, packageManagerVersion };\n}\n\nconst execa = promisify(exec);\n\nasync function getGitRemoteUrl() {\n  const result = await execa(\"git config --local --get remote.origin.url\", {\n    timeout: 250,\n    windowsHide: true,\n  }).catch(() => undefined);\n\n  return result?.stdout.trim();\n}\n\ntype PackageJson = {\n  name?: string;\n  version?: string;\n  dependencies?: { [key: string]: string };\n  devDependencies?: { [key: string]: string };\n};\n\nfunction getPackageJson(rootDir: string) {\n  try {\n    const rootPath = path.join(rootDir, \"package.json\");\n    const cwdPath = path.join(process.cwd(), \"package.json\");\n\n    const packageJsonPath = existsSync(rootPath)\n      ? rootPath\n      : existsSync(cwdPath)\n        ? cwdPath\n        : undefined;\n    if (packageJsonPath === undefined) return undefined;\n\n    const packageJsonString = readFileSync(packageJsonPath, \"utf8\");\n    const packageJson = JSON.parse(packageJsonString) as PackageJson;\n\n    return packageJson;\n  } catch (e) {\n    return undefined;\n  }\n}\n\nexport function buildPayload(build: IndexingBuild) {\n  const table_count = Object.keys(build.schema).length;\n  const indexing_function_count = Object.values(build.indexingFunctions).reduce(\n    (acc, f) => acc + Object.keys(f).length,\n    0,\n  );\n\n  return {\n    database_kind: build.databaseConfig.kind,\n    contract_count: build.sources.length,\n    network_count: build.networks.length,\n    table_count,\n    indexing_function_count,\n  };\n}\n","/**\n * Measures the elapsed wall clock time in milliseconds (ms) between two points.\n * @returns A function returning the elapsed time in milliseconds (ms).\n */\nexport function startClock() {\n  const start = process.hrtime();\n  return () => hrTimeToMs(process.hrtime(start));\n}\n\n/**\n * Converts a process.hrtime() measurement to milliseconds (ms).\n * @returns The timestamp in milliseconds (ms).\n */\nexport function hrTimeToMs(diff: [number, number]) {\n  const ns = diff[0] * 10 ** 9 + diff[1];\n  return ns / 10 ** 6;\n}\n","/** Waits at least a specified amount of time.\n *\n * @param milliseconds Minimum number of milliseconds to wait.\n */\nexport async function wait(milliseconds: number) {\n  return new Promise<void>((res) => setTimeout(res, milliseconds));\n}\n","import os from \"node:os\";\nimport readline from \"node:readline\";\nimport type { Common } from \"@/common/common.js\";\nimport { IgnorableError } from \"@/common/errors.js\";\n\nconst SHUTDOWN_GRACE_PERIOD_MS = 5_000;\n\n/**\n * Sets up shutdown handlers for the process. Accepts additional cleanup logic to run.\n */\nexport function setupShutdown({\n  common,\n  cleanup,\n}: {\n  common: Common;\n  cleanup: () => Promise<void>;\n}) {\n  let isShuttingDown = false;\n\n  const shutdown = async ({\n    reason,\n    code,\n  }: { reason: string; code: 0 | 1 }) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n    setTimeout(async () => {\n      common.logger.fatal({\n        service: \"process\",\n        msg: \"Failed to shutdown within 5 seconds, terminating (exit code 1)\",\n      });\n      await common.logger.kill();\n      process.exit(1);\n    }, SHUTDOWN_GRACE_PERIOD_MS);\n\n    if (reason !== undefined) {\n      common.logger.warn({\n        service: \"process\",\n        msg: `${reason}, starting shutdown sequence`,\n      });\n    }\n    common.telemetry.record({\n      name: \"lifecycle:session_end\",\n      properties: { duration_seconds: process.uptime() },\n    });\n\n    await cleanup();\n\n    const level = code === 0 ? \"info\" : \"fatal\";\n    common.logger[level]({\n      service: \"process\",\n      msg: `Finished shutdown sequence, terminating (exit code ${code})`,\n    });\n\n    await common.logger.kill();\n    process.exit(code);\n  };\n\n  if (os.platform() === \"win32\") {\n    const readlineInterface = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n    readlineInterface.on(\"SIGINT\", () =>\n      shutdown({ reason: \"Received SIGINT\", code: 0 }),\n    );\n  }\n\n  process.on(\"SIGINT\", () => shutdown({ reason: \"Received SIGINT\", code: 0 }));\n  process.on(\"SIGTERM\", () =>\n    shutdown({ reason: \"Received SIGTERM\", code: 0 }),\n  );\n  process.on(\"SIGQUIT\", () =>\n    shutdown({ reason: \"Received SIGQUIT\", code: 0 }),\n  );\n\n  process.on(\"uncaughtException\", (error: Error) => {\n    if (error instanceof IgnorableError) return;\n    common.logger.error({\n      service: \"process\",\n      msg: \"Caught uncaughtException event\",\n      error,\n    });\n    shutdown({ reason: \"Received uncaughtException\", code: 1 });\n  });\n  process.on(\"unhandledRejection\", (error: Error) => {\n    if (error instanceof IgnorableError) return;\n    common.logger.error({\n      service: \"process\",\n      msg: \"Caught unhandledRejection event\",\n      error,\n    });\n    shutdown({ reason: \"Received unhandledRejection\", code: 1 });\n  });\n\n  return shutdown;\n}\n","import { createBuildService } from \"@/build/index.js\";\nimport { runCodegen } from \"@/common/codegen.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { createTelemetry } from \"@/common/telemetry.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function codegen({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  const cleanup = async () => {\n    await buildService.kill();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const buildResult = await buildService.start({ watch: false });\n\n  if (buildResult.status === \"error\") {\n    logger.error({\n      service: \"process\",\n      msg: \"Failed schema build\",\n      error: buildResult.error,\n    });\n    await shutdown({ reason: \"Failed schema build\", code: 1 });\n    return;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: { cli_command: \"codegen\" },\n  });\n\n  const graphqlSchema = buildResult.indexingBuild.graphqlSchema;\n  runCodegen({ common, graphqlSchema });\n\n  logger.info({ service: \"codegen\", msg: \"Wrote ponder-env.d.ts\" });\n  logger.info({ service: \"codegen\", msg: \"Wrote schema.graphql\" });\n\n  await shutdown({ reason: \"Success\", code: 0 });\n}\n","import { existsSync } from \"node:fs\";\nimport path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport type { BuildResultDev } from \"@/build/service.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { type Database, createDatabase } from \"@/database/index.js\";\nimport { createUi } from \"@/ui/service.js\";\nimport { createQueue } from \"@ponder/common\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { run } from \"../utils/run.js\";\nimport { runServer } from \"../utils/runServer.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function dev({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  if (!existsSync(path.join(options.rootDir, \".env.local\"))) {\n    logger.warn({\n      service: \"app\",\n      msg: \"Local environment file (.env.local) not found\",\n    });\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  const ui = createUi({ common });\n\n  let indexingCleanupReloadable = () => Promise.resolve();\n  let apiCleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await indexingCleanupReloadable();\n    await apiCleanupReloadable();\n    if (database) {\n      await database.kill();\n    }\n    await buildService.kill();\n    await telemetry.kill();\n    ui.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const buildQueue = createQueue({\n    initialStart: true,\n    concurrency: 1,\n    worker: async (result: BuildResultDev) => {\n      if (result.kind === \"indexing\") {\n        await indexingCleanupReloadable();\n      }\n      await apiCleanupReloadable();\n\n      if (result.status === \"success\") {\n        if (result.kind === \"indexing\") {\n          metrics.resetIndexingMetrics();\n\n          if (database) {\n            await database.kill();\n          }\n\n          database = createDatabase({\n            common,\n            schema: result.indexingBuild.schema,\n            databaseConfig: result.indexingBuild.databaseConfig,\n            buildId: result.indexingBuild.buildId,\n            instanceId: result.indexingBuild.instanceId,\n            namespace: result.indexingBuild.namespace,\n            statements: result.indexingBuild.statements,\n          });\n\n          indexingCleanupReloadable = await run({\n            common,\n            build: result.indexingBuild,\n            database,\n            onFatalError: () => {\n              shutdown({ reason: \"Received fatal error\", code: 1 });\n            },\n            onReloadableError: (error) => {\n              buildQueue.clear();\n              buildQueue.add({ status: \"error\", kind: \"indexing\", error });\n            },\n          });\n        }\n        metrics.resetApiMetrics();\n\n        apiCleanupReloadable = await runServer({\n          common,\n          build: result.apiBuild,\n          database: database!,\n        });\n      } else {\n        // This handles indexing function build failures on hot reload.\n        metrics.ponder_indexing_has_error.set(1);\n        if (result.kind === \"indexing\") {\n          indexingCleanupReloadable = () => Promise.resolve();\n        }\n        apiCleanupReloadable = () => Promise.resolve();\n      }\n    },\n  });\n\n  let database: Database | undefined;\n\n  const buildResult = await buildService.start({\n    watch: true,\n    onBuild: (buildResult) => {\n      buildQueue.clear();\n      buildQueue.add(buildResult);\n    },\n  });\n\n  if (buildResult.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: {\n      cli_command: \"dev\",\n      ...buildPayload(buildResult.indexingBuild),\n    },\n  });\n\n  buildQueue.add({ ...buildResult, kind: \"indexing\" });\n\n  return async () => {\n    buildQueue.pause();\n    await cleanup();\n  };\n}\n","import crypto from \"node:crypto\";\nimport type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport type { DatabaseConfig } from \"@/config/database.js\";\nimport {\n  type Drizzle,\n  type Schema,\n  getPrimaryKeyColumns,\n  getTableNames,\n  userToReorgTableName,\n  userToSqlTableName,\n} from \"@/drizzle/index.js\";\nimport { type SqlStatements, getColumnCasing } from \"@/drizzle/kit/index.js\";\nimport type { PonderSyncSchema } from \"@/sync-store/encoding.js\";\nimport {\n  moveLegacyTables,\n  migrationProvider as postgresMigrationProvider,\n} from \"@/sync-store/migrations.js\";\nimport type { Status } from \"@/sync/index.js\";\nimport {\n  decodeCheckpoint,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { formatEta } from \"@/utils/format.js\";\nimport { createPool } from \"@/utils/pg.js\";\nimport { createPglite } from \"@/utils/pglite.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport type { PGlite } from \"@electric-sql/pglite\";\nimport { getTableColumns } from \"drizzle-orm\";\nimport { drizzle as drizzleNodePg } from \"drizzle-orm/node-postgres\";\nimport type { PgTable } from \"drizzle-orm/pg-core\";\nimport { drizzle as drizzlePglite } from \"drizzle-orm/pglite\";\nimport {\n  Migrator,\n  PostgresDialect,\n  type Transaction,\n  WithSchemaPlugin,\n  sql,\n} from \"kysely\";\nimport { KyselyPGlite } from \"kysely-pglite\";\nimport type { Pool } from \"pg\";\nimport prometheus from \"prom-client\";\nimport { HeadlessKysely } from \"./kysely.js\";\n\nexport type Database = {\n  qb: QueryBuilder;\n  drizzle: Drizzle<Schema>;\n  migrateSync(): Promise<void>;\n  /**\n   * Prepare the database environment for a Ponder app.\n   *\n   * The core logic in this function reads the schema where the new\n   * app will live, and decides what to do. Metadata is stored in the\n   * \"_ponder_meta\" table, and any residual entries in this table are\n   * used to determine what action this function will take.\n   *\n   * - If schema is empty or no matching build_id, start\n   * - If matching build_id and unlocked, cache hit\n   * - Else, start\n   *\n   * Separate from this main control flow, two other actions can happen:\n   * - Tables corresponding to non-live apps will be dropped, with a 3 app buffer\n   * - Apps run with \"ponder dev\" will publish view immediately\n   *\n   * @returns The progress checkpoint that that app should start from.\n   */\n  setup(): Promise<{\n    checkpoint: string;\n  }>;\n  createLiveViews(): Promise<void>;\n  createIndexes(): Promise<void>;\n  createTriggers(): Promise<void>;\n  removeTriggers(): Promise<void>;\n  revert(args: { checkpoint: string }): Promise<void>;\n  finalize(args: { checkpoint: string }): Promise<void>;\n  complete(args: { checkpoint: string }): Promise<void>;\n  unlock(): Promise<void>;\n  kill(): Promise<void>;\n};\n\nexport type PonderApp = {\n  is_locked: 0 | 1;\n  is_dev: 0 | 1;\n  heartbeat_at: number;\n  instance_id: string;\n  build_id: string;\n  checkpoint: string;\n  table_names: string[];\n};\n\ntype PonderInternalSchema = {\n  _ponder_meta:\n    | { key: `app_${string}`; value: PonderApp }\n    | { key: `status_${string}`; value: Status | null }\n    | { key: `live`; value: { instance_id: string } };\n} & {\n  [_: ReturnType<typeof getTableNames>[number][\"sql\"]]: unknown;\n} & {\n  [_: ReturnType<typeof getTableNames>[number][\"reorg\"]]: unknown & {\n    operation_id: number;\n    checkpoint: string;\n    operation: 0 | 1 | 2;\n  };\n};\n\ntype PGliteDriver = {\n  instance: PGlite;\n};\n\ntype PostgresDriver = {\n  internal: Pool;\n  user: Pool;\n  readonly: Pool;\n  sync: Pool;\n};\n\ntype QueryBuilder = {\n  /** For updating metadata and handling reorgs */\n  internal: HeadlessKysely<PonderInternalSchema>;\n  /** For indexing-store methods in user code */\n  user: HeadlessKysely<any>;\n  /** Used in api functions */\n  readonly: HeadlessKysely<unknown>;\n  /** Used to interact with the sync-store */\n  sync: HeadlessKysely<PonderSyncSchema>;\n};\n\nexport const createDatabase = (args: {\n  common: Common;\n  schema: Schema;\n  statements: SqlStatements;\n  namespace: string;\n  databaseConfig: DatabaseConfig;\n  instanceId: string;\n  buildId: string;\n}): Database => {\n  let heartbeatInterval: NodeJS.Timeout | undefined;\n\n  ////////\n  // Create drivers and orms\n  ////////\n\n  let driver: PGliteDriver | PostgresDriver;\n  let qb: Database[\"qb\"];\n\n  const dialect = args.databaseConfig.kind;\n\n  if (dialect === \"pglite\" || dialect === \"pglite_test\") {\n    driver = {\n      instance:\n        dialect === \"pglite\"\n          ? createPglite(args.databaseConfig.options)\n          : args.databaseConfig.instance,\n    };\n\n    const kyselyDialect = new KyselyPGlite(driver.instance).dialect;\n\n    qb = {\n      internal: new HeadlessKysely({\n        name: \"internal\",\n        common: args.common,\n        dialect: kyselyDialect,\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"internal\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(args.namespace)],\n      }),\n      user: new HeadlessKysely({\n        name: \"user\",\n        common: args.common,\n        dialect: kyselyDialect,\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"user\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(args.namespace)],\n      }),\n      readonly: new HeadlessKysely({\n        name: \"readonly\",\n        common: args.common,\n        dialect: kyselyDialect,\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"readonly\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(args.namespace)],\n      }),\n      sync: new HeadlessKysely<PonderSyncSchema>({\n        name: \"sync\",\n        common: args.common,\n        dialect: kyselyDialect,\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"sync\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(\"ponder_sync\")],\n      }),\n    };\n  } else {\n    const internalMax = 2;\n    const equalMax = Math.floor(\n      (args.databaseConfig.poolConfig.max - internalMax) / 3,\n    );\n    const [readonlyMax, userMax, syncMax] =\n      args.common.options.command === \"serve\"\n        ? [args.databaseConfig.poolConfig.max - internalMax, 0, 0]\n        : [equalMax, equalMax, equalMax];\n\n    driver = {\n      internal: createPool({\n        ...args.databaseConfig.poolConfig,\n        application_name: `${args.namespace}_internal`,\n        max: internalMax,\n        statement_timeout: 10 * 60 * 1000, // 10 minutes to accommodate slow sync store migrations.\n      }),\n      user: createPool({\n        ...args.databaseConfig.poolConfig,\n        application_name: `${args.namespace}_user`,\n        max: userMax,\n      }),\n      readonly: createPool({\n        ...args.databaseConfig.poolConfig,\n        application_name: `${args.namespace}_readonly`,\n        max: readonlyMax,\n      }),\n      sync: createPool({\n        ...args.databaseConfig.poolConfig,\n        application_name: \"ponder_sync\",\n        max: syncMax,\n      }),\n    };\n\n    qb = {\n      internal: new HeadlessKysely({\n        name: \"internal\",\n        common: args.common,\n        dialect: new PostgresDialect({ pool: driver.internal }),\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"internal\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(args.namespace)],\n      }),\n      user: new HeadlessKysely({\n        name: \"user\",\n        common: args.common,\n        dialect: new PostgresDialect({ pool: driver.user }),\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"user\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(args.namespace)],\n      }),\n      readonly: new HeadlessKysely({\n        name: \"readonly\",\n        common: args.common,\n        dialect: new PostgresDialect({ pool: driver.readonly }),\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"readonly\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(args.namespace)],\n      }),\n      sync: new HeadlessKysely<PonderSyncSchema>({\n        name: \"sync\",\n        common: args.common,\n        dialect: new PostgresDialect({ pool: driver.sync }),\n        log(event) {\n          if (event.level === \"query\") {\n            args.common.metrics.ponder_postgres_query_total.inc({\n              pool: \"sync\",\n            });\n          }\n        },\n        plugins: [new WithSchemaPlugin(\"ponder_sync\")],\n      }),\n    };\n\n    // Register Postgres-only metrics\n    const d = driver as PostgresDriver;\n    args.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_pool_connections\",\n    );\n    args.common.metrics.ponder_postgres_pool_connections = new prometheus.Gauge(\n      {\n        name: \"ponder_postgres_pool_connections\",\n        help: \"Number of connections in the pool\",\n        labelNames: [\"pool\", \"kind\"] as const,\n        registers: [args.common.metrics.registry],\n        collect() {\n          this.set({ pool: \"internal\", kind: \"idle\" }, d.internal.idleCount);\n          this.set({ pool: \"internal\", kind: \"total\" }, d.internal.totalCount);\n          this.set({ pool: \"sync\", kind: \"idle\" }, d.sync.idleCount);\n          this.set({ pool: \"sync\", kind: \"total\" }, d.sync.totalCount);\n          this.set({ pool: \"user\", kind: \"idle\" }, d.user.idleCount);\n          this.set({ pool: \"user\", kind: \"total\" }, d.user.totalCount);\n          this.set({ pool: \"readonly\", kind: \"idle\" }, d.readonly.idleCount);\n          this.set({ pool: \"readonly\", kind: \"total\" }, d.readonly.totalCount);\n        },\n      },\n    );\n\n    args.common.metrics.registry.removeSingleMetric(\n      \"ponder_postgres_query_queue_size\",\n    );\n    args.common.metrics.ponder_postgres_query_queue_size = new prometheus.Gauge(\n      {\n        name: \"ponder_postgres_query_queue_size\",\n        help: \"Number of queries waiting for an available connection\",\n        labelNames: [\"pool\"] as const,\n        registers: [args.common.metrics.registry],\n        collect() {\n          this.set({ pool: \"internal\" }, d.internal.waitingCount);\n          this.set({ pool: \"sync\" }, d.sync.waitingCount);\n          this.set({ pool: \"user\" }, d.user.waitingCount);\n          this.set({ pool: \"readonly\" }, d.readonly.waitingCount);\n        },\n      },\n    );\n  }\n\n  const drizzle =\n    dialect === \"pglite\" || dialect === \"pglite_test\"\n      ? drizzlePglite((driver as PGliteDriver).instance, {\n          casing: \"snake_case\",\n          schema: args.schema,\n        })\n      : drizzleNodePg((driver as PostgresDriver).user, {\n          casing: \"snake_case\",\n          schema: args.schema,\n        });\n\n  ////////\n  // Helpers\n  ////////\n\n  /**\n   * Undo operations in user tables by using the \"reorg\" tables.\n   *\n   * Note: \"reorg\" tables may contain operations that have not been applied to the\n   *       underlying tables, but only be 1 operation at most.\n   */\n  const revert = async ({\n    tableName,\n    checkpoint,\n    tx,\n  }: {\n    tableName: ReturnType<typeof getTableNames>[number];\n    checkpoint: string;\n    tx: Transaction<PonderInternalSchema>;\n    instanceId: string;\n  }) => {\n    const primaryKeyColumns = getPrimaryKeyColumns(\n      args.schema[tableName.js] as PgTable,\n    );\n\n    const rows = await tx\n      .deleteFrom(tableName.reorg)\n      .returningAll()\n      .where(\"checkpoint\", \">\", checkpoint)\n      .execute();\n\n    const reversed = rows.sort((a, b) => b.operation_id - a.operation_id);\n\n    // undo operation\n    for (const log of reversed) {\n      if (log.operation === 0) {\n        // Create\n        await tx\n          // @ts-ignore\n          .deleteFrom(tableName.sql)\n          .$call((qb) => {\n            for (const { sql } of primaryKeyColumns) {\n              // @ts-ignore\n              qb = qb.where(sql, \"=\", log[sql]);\n            }\n            return qb;\n          })\n          .execute();\n      } else if (log.operation === 1) {\n        // Update\n\n        // @ts-ignore\n        log.operation_id = undefined;\n        // @ts-ignore\n        log.checkpoint = undefined;\n        // @ts-ignore\n        log.operation = undefined;\n        await tx\n          // @ts-ignore\n          .updateTable(tableName.sql)\n          .set(log as any)\n          .$call((qb) => {\n            for (const { sql } of primaryKeyColumns) {\n              // @ts-ignore\n              qb = qb.where(sql, \"=\", log[sql]);\n            }\n            return qb;\n          })\n          .execute();\n      } else {\n        // Delete\n\n        // @ts-ignore\n        log.operation_id = undefined;\n        // @ts-ignore\n        log.checkpoint = undefined;\n        // @ts-ignore\n        log.operation = undefined;\n        await tx\n          // @ts-ignore\n          .insertInto(tableName.sql)\n          .values(log as any)\n          // @ts-ignore\n          .onConflict((oc) =>\n            oc\n              .columns(primaryKeyColumns.map(({ sql }) => sql) as any)\n              .doNothing(),\n          )\n          .execute();\n      }\n    }\n\n    args.common.logger.info({\n      service: \"database\",\n      msg: `Reverted ${rows.length} unfinalized operations from '${tableName.user}' table`,\n    });\n  };\n\n  const database = {\n    qb,\n    drizzle,\n    async migrateSync() {\n      await qb.sync.wrap({ method: \"migrateSyncStore\" }, async () => {\n        // TODO: Probably remove this at 1.0 to speed up startup time.\n        // TODO(kevin) is the `WithSchemaPlugin` going to break this?\n        await moveLegacyTables({\n          common: args.common,\n          // @ts-expect-error\n          db: qb.internal,\n          newSchemaName: \"ponder_sync\",\n        });\n\n        const migrator = new Migrator({\n          db: qb.sync as any,\n          provider: postgresMigrationProvider,\n          migrationTableSchema: \"ponder_sync\",\n        });\n\n        const { error } = await migrator.migrateToLatest();\n        if (error) throw error;\n      });\n    },\n    async setup() {\n      ////////\n      // Migrate\n      ////////\n\n      // v0.4 migration\n\n      // v0.6 migration\n\n      const hasPonderSchema = await qb.internal\n        // @ts-ignore\n        .selectFrom(\"information_schema.schemata\")\n        // @ts-ignore\n        .select(\"schema_name\")\n        // @ts-ignore\n        .where(\"schema_name\", \"=\", \"ponder\")\n        .executeTakeFirst()\n        .then((schema) => schema?.schema_name === \"ponder\");\n\n      if (hasPonderSchema) {\n        const hasNamespaceLockTable = await qb.internal\n          // @ts-ignore\n          .selectFrom(\"information_schema.tables\")\n          // @ts-ignore\n          .select([\"table_name\", \"table_schema\"])\n          // @ts-ignore\n          .where(\"table_name\", \"=\", \"namespace_lock\")\n          // @ts-ignore\n          .where(\"table_schema\", \"=\", \"ponder\")\n          .executeTakeFirst()\n          .then((table) => table !== undefined);\n\n        if (hasNamespaceLockTable) {\n          await qb.internal.wrap({ method: \"migrate\" }, async () => {\n            const namespaceCount = await qb.internal\n              .withSchema(\"ponder\")\n              // @ts-ignore\n              .selectFrom(\"namespace_lock\")\n              .select(sql`count(*)`.as(\"count\"))\n              .executeTakeFirst();\n\n            const tableNames = await qb.internal\n              .withSchema(\"ponder\")\n              // @ts-ignore\n              .selectFrom(\"namespace_lock\")\n              // @ts-ignore\n              .select(\"schema\")\n              // @ts-ignore\n              .where(\"namespace\", \"=\", args.namespace)\n              .executeTakeFirst()\n              .then((schema: any | undefined) =>\n                schema === undefined\n                  ? undefined\n                  : Object.keys(schema.schema.tables),\n              );\n            if (tableNames) {\n              for (const tableName of tableNames) {\n                await qb.internal.schema\n                  .dropTable(tableName)\n                  .ifExists()\n                  .cascade()\n                  .execute();\n              }\n\n              await qb.internal\n                .withSchema(\"ponder\")\n                // @ts-ignore\n                .deleteFrom(\"namespace_lock\")\n                // @ts-ignore\n                .where(\"namespace\", \"=\", args.namespace)\n                .execute();\n\n              if (namespaceCount!.count === 1) {\n                await qb.internal.schema\n                  .dropSchema(\"ponder\")\n                  .cascade()\n                  .execute();\n\n                args.common.logger.debug({\n                  service: \"database\",\n                  msg: `Removed 'ponder' schema`,\n                });\n              }\n            }\n          });\n        }\n      }\n\n      // v0.7 migration\n\n      const hasPonderMetaTable = await qb.internal\n        // @ts-ignore\n        .selectFrom(\"information_schema.tables\")\n        // @ts-ignore\n        .select([\"table_name\", \"table_schema\"])\n        // @ts-ignore\n        .where(\"table_name\", \"=\", \"_ponder_meta\")\n        // @ts-ignore\n        .where(\"table_schema\", \"=\", args.namespace)\n        .executeTakeFirst()\n        .then((table) => table !== undefined);\n\n      if (hasPonderMetaTable) {\n        await qb.internal.wrap({ method: \"migrate\" }, () =>\n          qb.internal.transaction().execute(async (tx) => {\n            const previousApp: PonderApp | undefined = await tx\n              .selectFrom(\"_ponder_meta\")\n              // @ts-ignore\n              .where(\"key\", \"=\", \"app\")\n              .select(\"value\")\n              .executeTakeFirst()\n              .then((row) =>\n                row === undefined ? undefined : (row.value as PonderApp),\n              );\n\n            if (previousApp) {\n              const instanceId = crypto.randomBytes(2).toString(\"hex\");\n\n              await tx\n                .deleteFrom(\"_ponder_meta\")\n                // @ts-ignore\n                .where(\"key\", \"=\", \"app\")\n                .execute();\n\n              await tx\n                .deleteFrom(\"_ponder_meta\")\n                // @ts-ignore\n                .where(\"key\", \"=\", \"status\")\n                .execute();\n\n              for (const tableName of previousApp.table_names) {\n                await tx.schema\n                  .alterTable(tableName)\n                  .renameTo(userToSqlTableName(tableName, instanceId))\n                  .execute();\n\n                await tx.schema\n                  .alterTable(`_ponder_reorg__${tableName}`)\n                  .renameTo(userToReorgTableName(tableName, instanceId))\n                  .execute();\n              }\n\n              await tx\n                .insertInto(\"_ponder_meta\")\n                .values({\n                  key: `app_${instanceId}`,\n                  value: { ...previousApp, instance_id: instanceId },\n                })\n                .execute();\n\n              args.common.logger.debug({\n                service: \"database\",\n                msg: \"Migrated previous app to v0.7\",\n              });\n            }\n          }),\n        );\n      }\n\n      await qb.internal.wrap({ method: \"setup\" }, async () => {\n        for (const statement of args.statements.schema.sql) {\n          await sql.raw(statement).execute(qb.internal);\n        }\n\n        // Create \"_ponder_meta\" table if it doesn't exist\n        await qb.internal.schema\n          .createTable(\"_ponder_meta\")\n          .addColumn(\"key\", \"text\", (col) => col.primaryKey())\n          .addColumn(\"value\", \"jsonb\")\n          .ifNotExists()\n          .execute();\n      });\n\n      const attempt = async ({ isFirstAttempt }: { isFirstAttempt: boolean }) =>\n        qb.internal.wrap({ method: \"setup\" }, () =>\n          qb.internal.transaction().execute(async (tx) => {\n            const previousApps: PonderApp[] = await tx\n              .selectFrom(\"_ponder_meta\")\n              .where(\"key\", \"like\", \"app_%\")\n              .select(\"value\")\n              .execute()\n              .then((rows) => rows.map(({ value }) => value as PonderApp));\n\n            const previousAppsWithBuildId = previousApps.filter(\n              (app) => app.build_id === args.buildId && app.is_dev === 0,\n            );\n\n            const newApp = {\n              is_locked: 1,\n              is_dev: args.common.options.command === \"dev\" ? 1 : 0,\n              heartbeat_at: Date.now(),\n              instance_id: args.instanceId,\n              build_id: args.buildId,\n              checkpoint: encodeCheckpoint(zeroCheckpoint),\n              table_names: getTableNames(args.schema, args.instanceId).map(\n                (tableName) => tableName.user,\n              ),\n            } satisfies PonderApp;\n\n            /**\n             * If schema is empty, start\n             */\n            if (previousAppsWithBuildId.length === 0) {\n              await tx\n                .insertInto(\"_ponder_meta\")\n                .values({ key: `status_${args.instanceId}`, value: null })\n                .onConflict((oc) =>\n                  oc\n                    .column(\"key\")\n                    // @ts-ignore\n                    .doUpdateSet({ value: null }),\n                )\n                .execute();\n              await tx\n                .insertInto(\"_ponder_meta\")\n                .values({\n                  key: `app_${args.instanceId}`,\n                  value: newApp,\n                })\n                .onConflict((oc) =>\n                  oc\n                    .column(\"key\")\n                    // @ts-ignore\n                    .doUpdateSet({ value: newApp }),\n                )\n                .execute();\n\n              for (const tableName of getTableNames(\n                args.schema,\n                newApp.instance_id,\n              )) {\n                await tx.schema\n                  .dropTable(tableName.sql)\n                  .cascade()\n                  .ifExists()\n                  .execute();\n                await tx.schema\n                  .dropTable(tableName.reorg)\n                  .cascade()\n                  .ifExists()\n                  .execute();\n              }\n\n              for (let i = 0; i < args.statements.enums.sql.length; i++) {\n                await sql\n                  .raw(args.statements.enums.sql[i]!)\n                  .execute(tx)\n                  .catch((_error) => {\n                    const error = _error as Error;\n                    if (!error.message.includes(\"already exists\")) throw error;\n                    throw new NonRetryableError(\n                      `Unable to create enum '${args.namespace}'.'${args.statements.enums.json[i]!.name}' because an enum with that name already exists.`,\n                    );\n                  });\n              }\n              for (let i = 0; i < args.statements.tables.sql.length; i++) {\n                await sql\n                  .raw(args.statements.tables.sql[i]!)\n                  .execute(tx)\n                  .catch((_error) => {\n                    const error = _error as Error;\n                    if (!error.message.includes(\"already exists\")) throw error;\n                    throw new NonRetryableError(\n                      `Unable to create table '${args.namespace}'.'${args.statements.tables.json[i]!.tableName}' because a table with that name already exists.`,\n                    );\n                  });\n              }\n              args.common.logger.info({\n                service: \"database\",\n                msg: `Created tables [${newApp.table_names.join(\", \")}]`,\n              });\n\n              return {\n                status: \"success\",\n                checkpoint: encodeCheckpoint(zeroCheckpoint),\n              } as const;\n            }\n\n            // Find the newest, unlocked, non-dev app to recover from\n            const crashRecoveryApp =\n              previousAppsWithBuildId\n                .filter(\n                  (app) =>\n                    app.is_locked === 0 ||\n                    app.heartbeat_at +\n                      args.common.options.databaseHeartbeatTimeout <=\n                      Date.now(),\n                )\n                .sort((a, b) => (a.checkpoint > b.checkpoint ? -1 : 1))[0] ??\n              undefined;\n\n            if (\n              crashRecoveryApp &&\n              crashRecoveryApp.checkpoint > encodeCheckpoint(zeroCheckpoint) &&\n              args.common.options.command !== \"dev\"\n            ) {\n              await tx\n                .insertInto(\"_ponder_meta\")\n                .values({ key: `status_${args.instanceId}`, value: null })\n                .execute();\n              await tx\n                .insertInto(\"_ponder_meta\")\n                .values({\n                  key: `app_${args.instanceId}`,\n                  value: {\n                    ...newApp,\n                    checkpoint: crashRecoveryApp.checkpoint,\n                  },\n                })\n                .execute();\n\n              args.common.logger.info({\n                service: \"database\",\n                msg: `Detected cache hit for build '${args.buildId}' in schema '${args.namespace}' last active ${formatEta(Date.now() - crashRecoveryApp.heartbeat_at)} ago`,\n              });\n\n              // Remove triggers\n\n              for (const tableName of getTableNames(\n                args.schema,\n                crashRecoveryApp.instance_id,\n              )) {\n                await sql\n                  .raw(\n                    `DROP TRIGGER IF EXISTS \"${tableName.trigger}\" ON \"${args.namespace}\".\"${tableName.sql}\"`,\n                  )\n                  .execute(tx);\n              }\n\n              // Remove indexes\n\n              for (const indexStatement of args.statements.indexes.json) {\n                await tx.schema\n                  .dropIndex(indexStatement.data.name)\n                  .ifExists()\n                  .execute();\n\n                args.common.logger.info({\n                  service: \"database\",\n                  msg: `Dropped index '${indexStatement.data.name}' in schema '${args.namespace}'`,\n                });\n              }\n\n              // Rename tables + reorg tables\n              for (const tableName of crashRecoveryApp.table_names) {\n                await tx.schema\n                  .alterTable(\n                    userToSqlTableName(tableName, crashRecoveryApp.instance_id),\n                  )\n                  .renameTo(userToSqlTableName(tableName, args.instanceId))\n                  .execute();\n\n                await tx.schema\n                  .alterTable(\n                    userToReorgTableName(\n                      tableName,\n                      crashRecoveryApp.instance_id,\n                    ),\n                  )\n                  .renameTo(userToReorgTableName(tableName, args.instanceId))\n                  .execute();\n              }\n\n              await tx\n                .deleteFrom(\"_ponder_meta\")\n                .where(\"key\", \"=\", `status_${crashRecoveryApp.instance_id}`)\n                .execute();\n\n              // Drop app\n              await tx\n                .deleteFrom(\"_ponder_meta\")\n                .where(\"key\", \"=\", `app_${crashRecoveryApp.instance_id}`)\n                .execute();\n\n              // Revert unfinalized data\n\n              const { blockTimestamp, chainId, blockNumber } = decodeCheckpoint(\n                crashRecoveryApp.checkpoint,\n              );\n\n              args.common.logger.info({\n                service: \"database\",\n                msg: `Reverting operations after finalized checkpoint (timestamp=${blockTimestamp} chainId=${chainId} block=${blockNumber})`,\n              });\n\n              for (const tableName of getTableNames(\n                args.schema,\n                args.instanceId,\n              )) {\n                await revert({\n                  tableName,\n                  checkpoint: crashRecoveryApp.checkpoint,\n                  tx,\n                  instanceId: args.instanceId,\n                });\n              }\n\n              return {\n                status: \"success\",\n                checkpoint: crashRecoveryApp.checkpoint,\n              } as const;\n            }\n\n            const nextAvailableApp = previousAppsWithBuildId.sort((a, b) =>\n              a.heartbeat_at < b.heartbeat_at ? -1 : 1,\n            )[0]!;\n\n            if (\n              isFirstAttempt &&\n              args.common.options.command !== \"dev\" &&\n              (crashRecoveryApp === undefined ||\n                crashRecoveryApp.is_locked === 1)\n            ) {\n              return {\n                status: \"locked\",\n                expiry:\n                  nextAvailableApp.heartbeat_at +\n                  args.common.options.databaseHeartbeatTimeout,\n              } as const;\n            }\n\n            /**\n             * At this point in the control flow, there is an app with the same build_id,\n             * but it can't be used as a crash recovery. The new app should startup.\n             */\n\n            await tx\n              .insertInto(\"_ponder_meta\")\n              .values({ key: `status_${args.instanceId}`, value: null })\n              // @ts-ignore\n              .onConflict((oc) => oc.column(\"key\").doUpdateSet({ value: null }))\n              .execute();\n            await tx\n              .insertInto(\"_ponder_meta\")\n              .values({\n                key: `app_${args.instanceId}`,\n                value: newApp,\n              })\n              .onConflict((oc) =>\n                oc\n                  .column(\"key\")\n                  // @ts-ignore\n                  .doUpdateSet({ value: newApp }),\n              )\n              .execute();\n\n            // drop tables in case of non-unique instance_id\n\n            for (const tableName of getTableNames(\n              args.schema,\n              newApp.instance_id,\n            )) {\n              await tx.schema\n                .dropTable(tableName.sql)\n                .cascade()\n                .ifExists()\n                .execute();\n              await tx.schema\n                .dropTable(tableName.reorg)\n                .cascade()\n                .ifExists()\n                .execute();\n            }\n\n            for (let i = 0; i < args.statements.enums.sql.length; i++) {\n              await sql\n                .raw(args.statements.enums.sql[i]!)\n                .execute(tx)\n                .catch((_error) => {\n                  const error = _error as Error;\n                  if (!error.message.includes(\"already exists\")) throw error;\n                  throw new NonRetryableError(\n                    `Unable to create enum '${args.namespace}'.'${args.statements.enums.json[i]!.name}' because an enum with that name already exists.`,\n                  );\n                });\n            }\n            for (let i = 0; i < args.statements.tables.sql.length; i++) {\n              await sql\n                .raw(args.statements.tables.sql[i]!)\n                .execute(tx)\n                .catch((_error) => {\n                  const error = _error as Error;\n                  if (!error.message.includes(\"already exists\")) throw error;\n                  throw new NonRetryableError(\n                    `Unable to create table '${args.namespace}'.'${args.statements.tables.json[i]!.tableName}' because a table with that name already exists.`,\n                  );\n                });\n            }\n            args.common.logger.info({\n              service: \"database\",\n              msg: `Created tables [${newApp.table_names.join(\", \")}]`,\n            });\n\n            return {\n              status: \"success\",\n              checkpoint: encodeCheckpoint(zeroCheckpoint),\n            } as const;\n          }),\n        );\n\n      let result = await attempt({ isFirstAttempt: true });\n      if (result.status === \"locked\") {\n        const duration = result.expiry - Date.now();\n        args.common.logger.warn({\n          service: \"database\",\n          msg: `Schema '${args.namespace}' is locked by a different Ponder app`,\n        });\n        args.common.logger.warn({\n          service: \"database\",\n          msg: `Waiting ${formatEta(duration)} for lock on schema '${args.namespace} to expire...`,\n        });\n\n        await wait(duration);\n\n        result = await attempt({ isFirstAttempt: false });\n        if (result.status === \"locked\") {\n          throw new NonRetryableError(\n            `Failed to acquire lock on schema '${args.namespace}'. A different Ponder app is actively using this database.`,\n          );\n        }\n      }\n\n      if (process.env.PONDER_EXPERIMENTAL_DB !== \"platform\") {\n        const apps: PonderApp[] = await qb.internal\n          .selectFrom(\"_ponder_meta\")\n          .where(\"key\", \"like\", \"app_%\")\n          .select(\"value\")\n          .execute()\n          .then((rows) => rows.map(({ value }) => value as PonderApp));\n\n        const removedDevApps = apps.filter(\n          (app) =>\n            app.is_dev === 1 &&\n            (app.is_locked === 0 ||\n              app.heartbeat_at + args.common.options.databaseHeartbeatTimeout <\n                Date.now()),\n        );\n\n        const removedStartApps = apps\n          .filter(\n            (app) =>\n              app.is_dev === 0 &&\n              (app.is_locked === 0 ||\n                app.heartbeat_at +\n                  args.common.options.databaseHeartbeatTimeout <\n                  Date.now()),\n          )\n          .sort((a, b) => (a.heartbeat_at > b.heartbeat_at ? -1 : 1))\n          .slice(2);\n\n        const removedApps = [...removedDevApps, ...removedStartApps];\n\n        for (const app of removedApps) {\n          for (const table of app.table_names) {\n            await qb.internal.schema\n              .dropTable(userToSqlTableName(table, app.instance_id))\n              .cascade()\n              .ifExists()\n              .execute();\n            await qb.internal.schema\n              .dropTable(userToReorgTableName(table, app.instance_id))\n              .cascade()\n              .ifExists()\n              .execute();\n          }\n          await qb.internal\n            .deleteFrom(\"_ponder_meta\")\n            .where(\"key\", \"=\", `status_${app.instance_id}`)\n            .execute();\n          await qb.internal\n            .deleteFrom(\"_ponder_meta\")\n            .where(\"key\", \"=\", `app_${app.instance_id}`)\n            .execute();\n        }\n\n        if (removedApps.length > 0) {\n          args.common.logger.debug({\n            service: \"database\",\n            msg: `Removed tables corresponding to apps [${removedApps.map((app) => app.instance_id)}]`,\n          });\n        }\n\n        if (apps.length === 1 || args.common.options.command === \"dev\") {\n          await this.createLiveViews();\n        }\n      }\n\n      heartbeatInterval = setInterval(async () => {\n        try {\n          const heartbeat = Date.now();\n\n          await qb.internal\n            .updateTable(\"_ponder_meta\")\n            .where(\"key\", \"=\", `app_${args.instanceId}`)\n            .set({\n              value: sql`jsonb_set(value, '{heartbeat_at}', ${heartbeat})`,\n            })\n            .execute();\n\n          args.common.logger.debug({\n            service: \"database\",\n            msg: `Updated heartbeat timestamp to ${heartbeat} (build_id=${args.buildId})`,\n          });\n        } catch (err) {\n          const error = err as Error;\n          args.common.logger.error({\n            service: \"database\",\n            msg: `Failed to update heartbeat timestamp, retrying in ${formatEta(\n              args.common.options.databaseHeartbeatInterval,\n            )}`,\n            error,\n          });\n        }\n      }, args.common.options.databaseHeartbeatInterval);\n\n      return { checkpoint: result.checkpoint };\n    },\n    async createIndexes() {\n      for (const statement of args.statements.indexes.sql) {\n        await sql.raw(statement).execute(qb.internal);\n      }\n    },\n    async createLiveViews() {\n      if (process.env.PONDER_EXPERIMENTAL_DB === \"platform\") return;\n\n      await qb.internal.wrap({ method: \"createLiveViews\" }, async () => {\n        // drop old views\n\n        const previousLiveInstanceId: string | undefined = await qb.internal\n          .selectFrom(\"_ponder_meta\")\n          .select(\"value\")\n          .where(\"key\", \"=\", \"live\")\n          .executeTakeFirst()\n          .then((row) => (row?.value?.instance_id as string) ?? undefined);\n\n        if (previousLiveInstanceId) {\n          const previousTableNames = await qb.internal\n            .selectFrom(\"_ponder_meta\")\n            .select(\"value\")\n            .where(\"key\", \"=\", `app_${previousLiveInstanceId}`)\n            .executeTakeFirst()\n            .then((row) => (row ? (row.value as PonderApp).table_names : []));\n\n          await Promise.all(\n            previousTableNames.map((name) =>\n              qb.internal.schema.dropView(name).ifExists().execute(),\n            ),\n          );\n        }\n\n        // update live app\n\n        await qb.internal\n          .insertInto(\"_ponder_meta\")\n          .values({\n            key: \"live\",\n            value: { instance_id: args.instanceId },\n          })\n          .onConflict((oc) =>\n            oc\n              .column(\"key\")\n              // @ts-ignore\n              .doUpdateSet({ value: { instance_id: args.instanceId } }),\n          )\n          .execute();\n\n        // create new views\n\n        for (const tableName of getTableNames(args.schema, args.instanceId)) {\n          await qb.internal.schema\n            .createView(tableName.user)\n            .orReplace()\n            .as(qb.internal.selectFrom(tableName.sql).selectAll())\n            .execute();\n\n          args.common.logger.info({\n            service: \"database\",\n            msg: `Created view '${args.namespace}'.'${tableName.user}'`,\n          });\n        }\n      });\n    },\n    async createTriggers() {\n      await qb.internal.wrap({ method: \"createTriggers\" }, async () => {\n        for (const tableName of getTableNames(args.schema, args.instanceId)) {\n          const columns = getTableColumns(\n            args.schema[tableName.js]! as PgTable,\n          );\n\n          const columnNames = Object.values(columns).map(\n            (column) => `\"${getColumnCasing(column, \"snake_case\")}\"`,\n          );\n\n          await sql\n            .raw(`\nCREATE OR REPLACE FUNCTION ${tableName.triggerFn}\nRETURNS TRIGGER AS $$\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    INSERT INTO \"${args.namespace}\".\"${tableName.reorg}\" (${columnNames.join(\",\")}, operation, checkpoint)\n    VALUES (${columnNames.map((name) => `NEW.${name}`).join(\",\")}, 0, '${encodeCheckpoint(maxCheckpoint)}');\n  ELSIF TG_OP = 'UPDATE' THEN\n    INSERT INTO \"${args.namespace}\".\"${tableName.reorg}\" (${columnNames.join(\",\")}, operation, checkpoint)\n    VALUES (${columnNames.map((name) => `OLD.${name}`).join(\",\")}, 1, '${encodeCheckpoint(maxCheckpoint)}');\n  ELSIF TG_OP = 'DELETE' THEN\n    INSERT INTO \"${args.namespace}\".\"${tableName.reorg}\" (${columnNames.join(\",\")}, operation, checkpoint)\n    VALUES (${columnNames.map((name) => `OLD.${name}`).join(\",\")}, 2, '${encodeCheckpoint(maxCheckpoint)}');\n  END IF;\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql\n`)\n            .execute(qb.internal);\n\n          await sql\n            .raw(`\n          CREATE TRIGGER \"${tableName.trigger}\"\n          AFTER INSERT OR UPDATE OR DELETE ON \"${args.namespace}\".\"${tableName.sql}\"\n          FOR EACH ROW EXECUTE FUNCTION ${tableName.triggerFn};\n          `)\n            .execute(qb.internal);\n        }\n      });\n    },\n    async removeTriggers() {\n      await qb.internal.wrap({ method: \"removeTriggers\" }, async () => {\n        for (const tableName of getTableNames(args.schema, args.instanceId)) {\n          await sql\n            .raw(\n              `DROP TRIGGER IF EXISTS \"${tableName.trigger}\" ON \"${args.namespace}\".\"${tableName.sql}\"`,\n            )\n            .execute(qb.internal);\n        }\n      });\n    },\n    async revert({ checkpoint }) {\n      await qb.internal.wrap({ method: \"revert\" }, () =>\n        Promise.all(\n          getTableNames(args.schema, args.instanceId).map((tableName) =>\n            qb.internal.transaction().execute((tx) =>\n              revert({\n                tableName,\n                checkpoint,\n                tx,\n                instanceId: args.instanceId,\n              }),\n            ),\n          ),\n        ),\n      );\n    },\n    async finalize({ checkpoint }) {\n      await qb.internal.wrap({ method: \"finalize\" }, async () => {\n        await qb.internal\n          .updateTable(\"_ponder_meta\")\n          .where(\"key\", \"=\", `app_${args.instanceId}`)\n          .set({\n            value: sql`jsonb_set(value, '{checkpoint}', to_jsonb(${checkpoint}::varchar(75)))`,\n          })\n          .execute();\n\n        await Promise.all(\n          getTableNames(args.schema, args.instanceId).map((tableName) =>\n            qb.internal\n              .deleteFrom(tableName.reorg)\n              .where(\"checkpoint\", \"<=\", checkpoint)\n              .execute(),\n          ),\n        );\n      });\n\n      const decoded = decodeCheckpoint(checkpoint);\n\n      args.common.logger.debug({\n        service: \"database\",\n        msg: `Updated finalized checkpoint to (timestamp=${decoded.blockTimestamp} chainId=${decoded.chainId} block=${decoded.blockNumber})`,\n      });\n    },\n    async complete({ checkpoint }) {\n      await Promise.all(\n        getTableNames(args.schema, args.instanceId).map((tableName) =>\n          qb.internal.wrap({ method: \"complete\" }, async () => {\n            await qb.internal\n              .updateTable(tableName.reorg)\n              .set({ checkpoint })\n              .where(\"checkpoint\", \"=\", encodeCheckpoint(maxCheckpoint))\n              .execute();\n          }),\n        ),\n      );\n    },\n    async unlock() {\n      clearInterval(heartbeatInterval);\n\n      await qb.internal.wrap({ method: \"unlock\" }, async () => {\n        await qb.internal\n          .updateTable(\"_ponder_meta\")\n          .where(\"key\", \"=\", `app_${args.instanceId}`)\n          .set({\n            value: sql`jsonb_set(value, '{is_locked}', to_jsonb(0))`,\n          })\n          .execute();\n      });\n    },\n    async kill() {\n      await qb.internal.destroy();\n      await qb.user.destroy();\n      await qb.readonly.destroy();\n      await qb.sync.destroy();\n\n      if (dialect === \"pglite\") {\n        const d = driver as PGliteDriver;\n        await d.instance.close();\n      }\n\n      if (dialect === \"pglite_test\") {\n        // no-op, allow test harness to clean up the instance\n      }\n\n      if (dialect === \"postgres\") {\n        const d = driver as PostgresDriver;\n        await d.internal.end();\n        await d.user.end();\n        await d.readonly.end();\n        await d.sync.end();\n      }\n\n      args.common.logger.debug({\n        service: \"database\",\n        msg: \"Closed connection to database\",\n      });\n    },\n  } satisfies Database;\n\n  return database;\n};\n","import type { Common } from \"@/common/common.js\";\nimport type { Kysely, Migration, MigrationProvider } from \"kysely\";\nimport { sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  \"2023_05_15_0_initial\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", sql`bytea`) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses Postgres SERIAL type which autoincrements.\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n    },\n  },\n  \"2023_06_20_0_indices\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n  },\n  \"2023_07_18_0_better_indices\": {\n    async up(db: Kysely<any>) {\n      // Drop old indices.\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n\n      // Block hash is a join key.\n      await db.schema\n        .createIndex(\"log_block_hash_index\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n\n      // Chain ID, address and topic0 are all used in WHERE clauses.\n      await db.schema\n        .createIndex(\"log_chain_id_index\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_address_index\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"log_topic0_index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      // Block timestamp and number are both used in WHERE and SORT clauses.\n      await db.schema\n        .createIndex(\"block_timestamp_index\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"block_number_index\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n    },\n  },\n  \"2023_07_24_0_drop_finalized\": {\n    async up(db: Kysely<any>) {\n      await db.schema.alterTable(\"blocks\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .dropColumn(\"finalized\")\n        .execute();\n      await db.schema.alterTable(\"logs\").dropColumn(\"finalized\").execute();\n      await db.schema\n        .alterTable(\"contractReadResults\")\n        .dropColumn(\"finalized\")\n        .execute();\n    },\n  },\n  \"2023_09_19_0_new_sync_design\": {\n    async up(db: Kysely<any>) {\n      /** This table is no longer being used. */\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n\n      /** Drop and re-create all tables to fix bigint encoding. */\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"gasLimit\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"miner\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"varchar(18)\", (col) => col.notNull())\n        .addColumn(\"number\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"parentHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"size\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"stateRoot\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"totalDifficulty\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"transactionsRoot\", \"varchar(66)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockTimestampIndex\")\n        .on(\"blocks\")\n        .column(\"timestamp\")\n        .execute();\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"gasPrice\", \"numeric(78, 0)\")\n        .addColumn(\"hash\", \"varchar(66)\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"maxPriorityFeePerGas\", \"numeric(78, 0)\")\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"s\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"v\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logBlockHashIndex\")\n        .on(\"logs\")\n        .column(\"blockHash\")\n        .execute();\n      await db.schema\n        .createIndex(\"logChainIdIndex\")\n        .on(\"logs\")\n        .column(\"chainId\")\n        .execute();\n      await db.schema\n        .createIndex(\"logAddressIndex\")\n        .on(\"logs\")\n        .column(\"address\")\n        .execute();\n      await db.schema\n        .createIndex(\"logTopic0Index\")\n        .on(\"logs\")\n        .column(\"topic0\")\n        .execute();\n\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      /** Add new log filter and factory contract interval tables. */\n      await db.schema\n        .createTable(\"logFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${topic0}_${topic1}_${topic2}_${topic3}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(66)\")\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"logFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"logFilterId\", \"text\", (col) =>\n          col.notNull().references(\"logFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"logFilterIntervalsLogFilterId\")\n        .on(\"logFilterIntervals\")\n        .column(\"logFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factories\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"topic0\", \"varchar(66)\")\n        .addColumn(\"topic1\", \"varchar(66)\")\n        .addColumn(\"topic2\", \"varchar(66)\")\n        .addColumn(\"topic3\", \"varchar(66)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryLogFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\", (col) =>\n          col.notNull().references(\"factories.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryLogFilterIntervalsFactoryId\")\n        .on(\"factoryLogFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n  \"2023_11_06_0_new_rpc_cache_design\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropTable(\"contractReadResults\").execute();\n\n      /**\n       * Formatting for \"request\" field values:\n       *\n       * eth_call: eth_call_{to}_{data}\n       * eth_getBalance: eth_getBalance_{address}\n       * eth_getCode: eth_getCode_{address}\n       * eth_getStorageAt: eth_getStorageAt_{address}_{slot}\n       */\n      await db.schema\n        .createTable(\"rpcRequestResults\")\n        .addColumn(\"request\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"rpcRequestResultPrimaryKey\", [\n          \"request\",\n          \"chainId\",\n          \"blockNumber\",\n        ])\n        .execute();\n    },\n  },\n  \"2024_01_30_0_change_chain_id_type\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logs\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n\n      await db.schema\n        .alterTable(\"rpcRequestResults\")\n        .alterColumn(\"chainId\", (col) => col.setDataType(\"int8\"))\n        .execute();\n    },\n  },\n  \"2024_02_1_0_nullable_block_columns\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"mixHash\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"nonce\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_00_0_log_transaction_hash_index\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_transaction_hash_index\")\n        .on(\"logs\")\n        .column(\"transactionHash\")\n        .execute();\n    },\n  },\n  \"2024_03_13_0_nullable_block_columns_sha3uncles\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"sha3Uncles\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_14_0_nullable_transaction_rsv\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"r\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"s\", (col) => col.dropNotNull())\n        .execute();\n      await db.schema\n        .alterTable(\"transactions\")\n        .alterColumn(\"v\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_03_20_0_checkpoint_in_logs_table\": {\n    async up(_db: Kysely<any>) {\n      // no-op migration to avoid crashing databases that successfully ran this migration\n      return;\n    },\n  },\n  \"2024_04_04_0_log_events_indexes\": {\n    async up(db: Kysely<any>) {\n      await db.schema.dropIndex(\"blockNumberIndex\").ifExists().execute();\n      await db.schema.dropIndex(\"blockTimestampIndex\").ifExists().execute();\n\n      await db.schema\n        .createIndex(\"logBlockNumberIndex\")\n        .on(\"logs\")\n        .column(\"blockNumber\")\n        .execute();\n    },\n  },\n  \"2024_04_14_0_nullable_block_total_difficulty\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"totalDifficulty\", (col) => col.dropNotNull())\n        .execute();\n    },\n  },\n  \"2024_04_14_1_add_checkpoint_column_to_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(\n        sql`\n        ALTER TABLE ponder_sync.logs \n        ADD COLUMN IF NOT EXISTS \n        checkpoint varchar(75)`.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_2_set_checkpoint_in_logs_table\": {\n    async up(db: Kysely<any>) {\n      await db.executeQuery(sql`SET statement_timeout = 3600000;`.compile(db));\n      await db.executeQuery(\n        sql`\n        CREATE TEMP TABLE cp_vals AS \n        SELECT\n          logs.id,\n          (lpad(blocks.timestamp::text, 10, '0') ||\n          lpad(blocks.\"chainId\"::text, 16, '0') ||\n          lpad(blocks.number::text, 16, '0') ||\n          lpad(logs.\"transactionIndex\"::text, 16, '0') ||\n          '5' ||\n          lpad(logs.\"logIndex\"::text, 16, '0')) AS checkpoint\n        FROM ponder_sync.logs logs\n        JOIN ponder_sync.blocks blocks ON logs.\"blockHash\" = blocks.hash;\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n        CREATE INDEX ON cp_vals(id)\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n          UPDATE ponder_sync.logs\n          SET checkpoint=cp_vals.checkpoint\n          FROM cp_vals\n          WHERE ponder_sync.logs.id = cp_vals.id\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`DROP TABLE IF EXISTS cp_vals CASCADE;`.compile(db),\n      );\n    },\n  },\n  \"2024_04_14_3_index_on_logs_checkpoint\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"logs_checkpoint_index\")\n        .ifNotExists()\n        .on(\"logs\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_04_22_0_transaction_receipts\": {\n    async up(db: Kysely<any>) {\n      // Update the log filter ID keys to include the integer includeTransactionReceipts value.\n      // Note that we have to remove the FK constraint, which is fine given our app logic.\n      await db.schema\n        .alterTable(\"logFilterIntervals\")\n        .dropConstraint(\"logFilterIntervals_logFilterId_fkey\")\n        .execute();\n      await db\n        .updateTable(\"logFilters\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db\n        .updateTable(\"logFilterIntervals\")\n        .set({ logFilterId: sql`\"logFilterId\" || '_0'` })\n        .execute();\n      // Add the includeTransactionReceipts column. By setting a default in the ADD COLUMN statement,\n      // Postgres will automatically populate all existing rows with the default value. But, we don't\n      // actually want a default (want to require a value on insertion), so immediately drop the default.\n      await db.schema\n        .alterTable(\"logFilters\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"logFilters\")\n        .alterColumn(\"includeTransactionReceipts\", (col) => col.dropDefault())\n        .execute();\n\n      // Repeat the same 2 steps for the factory tables.\n      await db.schema\n        .alterTable(\"factoryLogFilterIntervals\")\n        .dropConstraint(\"factoryLogFilterIntervals_factoryId_fkey\")\n        .execute();\n      await db\n        .updateTable(\"factories\")\n        .set({ id: sql`\"id\" || '_0'` })\n        .execute();\n      await db\n        .updateTable(\"factoryLogFilterIntervals\")\n        .set({ factoryId: sql`\"factoryId\" || '_0'` })\n        .execute();\n      await db.schema\n        .alterTable(\"factories\")\n        .addColumn(\"includeTransactionReceipts\", \"integer\", (col) =>\n          col.notNull().defaultTo(0),\n        )\n        .execute();\n      await db.schema\n        .alterTable(\"factories\")\n        .alterColumn(\"includeTransactionReceipts\", (col) => col.dropDefault())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactionReceipts\")\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"contractAddress\", \"varchar(66)\")\n        .addColumn(\"cumulativeGasUsed\", \"numeric(78, 0)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"effectiveGasPrice\", \"numeric(78, 0)\", (col) =>\n          col.notNull(),\n        )\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"logs\", \"text\", (col) => col.notNull())\n        .addColumn(\"logsBloom\", \"varchar(514)\", (col) => col.notNull())\n        .addColumn(\"status\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\")\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) =>\n          col.notNull().primaryKey(),\n        )\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .execute();\n    },\n  },\n  \"2024_04_23_0_block_filters\": {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blockFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${interval}_${offset}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"interval\", \"integer\", (col) => col.notNull())\n        .addColumn(\"offset\", \"integer\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createTable(\"blockFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"blockFilterId\", \"text\", (col) =>\n          col.notNull().references(\"blockFilters.id\"),\n        )\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"blockFilterIntervalsBlockFilterId\")\n        .on(\"blockFilterIntervals\")\n        .column(\"blockFilterId\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .addColumn(\"checkpoint\", \"varchar(75)\")\n        .execute();\n\n      await db.executeQuery(\n        sql`\n          CREATE TEMP TABLE bcp_vals AS \n          SELECT\n            blocks.hash,\n            (lpad(blocks.timestamp::text, 10, '0') ||\n            lpad(blocks.\"chainId\"::text, 16, '0') ||\n            lpad(blocks.number::text, 16, '0') ||\n            '9999999999999999' ||\n            '5' ||\n            '0000000000000000') AS checkpoint\n          FROM ponder_sync.blocks\n          `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`\n          UPDATE ponder_sync.blocks\n          SET checkpoint=bcp_vals.checkpoint\n          FROM bcp_vals\n          WHERE ponder_sync.blocks.hash = bcp_vals.hash\n        `.compile(db),\n      );\n\n      await db.executeQuery(\n        sql`DROP TABLE IF EXISTS bcp_vals CASCADE;`.compile(db),\n      );\n\n      await db.schema\n        .alterTable(\"blocks\")\n        .alterColumn(\"checkpoint\", (col) => col.setNotNull())\n        .execute();\n\n      // The blocks.number index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockNumberIndex\")\n        .on(\"blocks\")\n        .column(\"number\")\n        .execute();\n      // The blocks.chainId index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"blockChainIdIndex\")\n        .on(\"blocks\")\n        .column(\"chainId\")\n        .execute();\n      // The blocks.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"blockCheckpointIndex\")\n        .on(\"blocks\")\n        .column(\"checkpoint\")\n        .execute();\n    },\n  },\n  \"2024_05_07_0_trace_filters\": {\n    async up(db: Kysely<any>) {\n      // TODO(kyle) drop foreign key constraint on \"blockFilterIntervals.blockFilterId\".\n\n      await db.schema\n        .createTable(\"traceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${fromAddress}_${toAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .addColumn(\"toAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"traceFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"traceFilterId\", \"text\", (col) => col.notNull())\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"traceFilterIntervalsTraceFilterId\")\n        .on(\"traceFilterIntervals\")\n        .column(\"traceFilterId\")\n        .execute();\n\n      await db.schema\n        .createTable(\"callTraces\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"callType\", \"text\", (col) => col.notNull())\n        .addColumn(\"from\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"gas\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"value\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"error\", \"text\")\n        .addColumn(\"gasUsed\", \"numeric(78, 0)\")\n        .addColumn(\"output\", \"text\")\n        .addColumn(\"subtraces\", \"integer\", (col) => col.notNull())\n        .addColumn(\"traceAddress\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionHash\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"transactionPosition\", \"integer\", (col) => col.notNull())\n        .addColumn(\"functionSelector\", \"varchar(10)\", (col) => col.notNull())\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"checkpoint\", \"varchar(75)\", (col) => col.notNull())\n        .execute();\n\n      // The callTraces.blockNumber index supports getEvents and deleteRealtimeData\n      await db.schema\n        .createIndex(\"callTracesBlockNumberIndex\")\n        .on(\"callTraces\")\n        .column(\"blockNumber\")\n        .execute();\n\n      // The callTraces.functionSelector index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFunctionSelectorIndex\")\n        .on(\"callTraces\")\n        .column(\"functionSelector\")\n        .execute();\n\n      // The callTraces.error index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesErrorIndex\")\n        .on(\"callTraces\")\n        .column(\"error\")\n        .execute();\n\n      // The callTraces.blockHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesBlockHashIndex\")\n        .on(\"callTraces\")\n        .column(\"blockHash\")\n        .execute();\n\n      // The callTraces.transactionHash index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesTransactionHashIndex\")\n        .on(\"callTraces\")\n        .column(\"transactionHash\")\n        .execute();\n\n      // The callTraces.checkpoint index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesCheckpointIndex\")\n        .on(\"callTraces\")\n        .column(\"checkpoint\")\n        .execute();\n\n      // The callTraces.chainId index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesChainIdIndex\")\n        .on(\"callTraces\")\n        .column(\"chainId\")\n        .execute();\n\n      // The callTraces.from index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesFromIndex\")\n        .on(\"callTraces\")\n        .column(\"from\")\n        .execute();\n\n      // The callTraces.to index supports getEvents\n      await db.schema\n        .createIndex(\"callTracesToIndex\")\n        .on(\"callTraces\")\n        .column(\"to\")\n        .execute();\n\n      await db.schema\n        .alterTable(\"factories\")\n        .renameTo(\"factoryLogFilters\")\n        .execute();\n\n      await db.schema\n        .createTable(\"factoryTraceFilters\")\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey()) // `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${fromAddress}`\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"address\", \"varchar(42)\", (col) => col.notNull())\n        .addColumn(\"eventSelector\", \"varchar(66)\", (col) => col.notNull())\n        .addColumn(\"childAddressLocation\", \"text\", (col) => col.notNull()) // `topic${number}` or `offset${number}`\n        .addColumn(\"fromAddress\", \"varchar(42)\")\n        .execute();\n      await db.schema\n        .createTable(\"factoryTraceFilterIntervals\")\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey()) // Auto-increment\n        .addColumn(\"factoryId\", \"text\")\n        .addColumn(\"startBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .addColumn(\"endBlock\", \"numeric(78, 0)\", (col) => col.notNull())\n        .execute();\n      await db.schema\n        .createIndex(\"factoryTraceFilterIntervalsFactoryId\")\n        .on(\"factoryTraceFilterIntervals\")\n        .column(\"factoryId\")\n        .execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n\nexport async function moveLegacyTables({\n  common,\n  db,\n  newSchemaName,\n}: {\n  common: Common;\n  db: Kysely<any>;\n  newSchemaName: string;\n}) {\n  // If the database has ponder migration tables present in the public schema,\n  // move them to the new schema.\n  let hasLegacyMigrations = false;\n  try {\n    const { rows } = await db.executeQuery<{ name: string }>(\n      sql`SELECT * FROM public.kysely_migration LIMIT 1`.compile(db),\n    );\n    if (rows[0]?.name === \"2023_05_15_0_initial\") hasLegacyMigrations = true;\n  } catch (e) {\n    const error = e as Error;\n    if (!error.message.includes(\"does not exist\")) throw error;\n  }\n\n  if (!hasLegacyMigrations) return;\n\n  common.logger.warn({\n    service: \"database\",\n    msg: \"Detected legacy sync migrations. Moving tables from 'public' schema to 'ponder_sync'.\",\n  });\n\n  async function moveOrDeleteTable(tableName: string) {\n    try {\n      await db.schema\n        .alterTable(`public.${tableName}`)\n        .setSchema(newSchemaName)\n        .execute();\n    } catch (e) {\n      const error = e as Error;\n      switch (error.message) {\n        case `relation \"${tableName}\" already exists in schema \"${newSchemaName}\"`: {\n          await db.schema\n            .dropTable(`public.${tableName}`)\n            .execute()\n            // Ignore errors if this fails.\n            .catch(() => {});\n          break;\n        }\n        case `relation \"public.${tableName}\" does not exist`: {\n          break;\n        }\n        default: {\n          common.logger.warn({\n            service: \"database\",\n            msg: `Failed to migrate table \"${tableName}\" to \"ponder_sync\" schema: ${error.message}`,\n          });\n        }\n      }\n    }\n\n    common.logger.warn({\n      service: \"database\",\n      msg: `Successfully moved 'public.${tableName}' table to 'ponder_sync' schema.`,\n    });\n  }\n\n  const tableNames = [\n    \"kysely_migration\",\n    \"kysely_migration_lock\",\n    \"blocks\",\n    \"logs\",\n    \"transactions\",\n    \"rpcRequestResults\",\n    // Note that logFilterIntervals has a constraint that uses logFilters,\n    // so the order here matters. Same story with factoryLogFilterIntervals.\n    \"logFilterIntervals\",\n    \"logFilters\",\n    \"factoryLogFilterIntervals\",\n    \"factories\",\n    // Old ones that are no longer being used, but should still be moved\n    // so that older migrations work as expected.\n    \"contractReadResults\",\n    \"logFilterCachedRanges\",\n  ];\n\n  for (const tableName of tableNames) {\n    await moveOrDeleteTable(tableName);\n  }\n}\n","export type Checkpoint = {\n  blockTimestamp: number;\n  chainId: bigint;\n  blockNumber: bigint;\n  transactionIndex: bigint;\n  eventType: number;\n  eventIndex: bigint;\n};\n\n// 10 digits for unix timestamp gets us to the year 2277.\nconst BLOCK_TIMESTAMP_DIGITS = 10;\n// Chain IDs are uint256. As of writing the largest Chain ID on https://chainlist.org\n// is 13 digits. 16 digits should be enough (JavaScript's max safe integer).\nconst CHAIN_ID_DIGITS = 16;\n// Same logic as chain ID.\nconst BLOCK_NUMBER_DIGITS = 16;\n// Same logic as chain ID.\nconst TRANSACTION_INDEX_DIGITS = 16;\n// At time of writing, we only have 2 event types planned, so one digit (10 types) is enough.\nconst EVENT_TYPE_DIGITS = 1;\n// This could contain log index, trace index, etc. 16 digits should be enough.\nconst EVENT_INDEX_DIGITS = 16;\n\nconst CHECKPOINT_LENGTH =\n  BLOCK_TIMESTAMP_DIGITS +\n  CHAIN_ID_DIGITS +\n  BLOCK_NUMBER_DIGITS +\n  TRANSACTION_INDEX_DIGITS +\n  EVENT_TYPE_DIGITS +\n  EVENT_INDEX_DIGITS;\n\nexport const EVENT_TYPES = {\n  blocks: 5,\n  logs: 5,\n  callTraces: 7,\n} as const;\n\nexport const encodeCheckpoint = (checkpoint: Checkpoint) => {\n  const {\n    blockTimestamp,\n    chainId,\n    blockNumber,\n    transactionIndex,\n    eventType,\n    eventIndex,\n  } = checkpoint;\n\n  if (eventType < 0 || eventType > 9)\n    throw new Error(\n      `Got invalid event type ${eventType}, expected a number from 0 to 9`,\n    );\n\n  const result =\n    blockTimestamp.toString().padStart(BLOCK_TIMESTAMP_DIGITS, \"0\") +\n    chainId.toString().padStart(CHAIN_ID_DIGITS, \"0\") +\n    blockNumber.toString().padStart(BLOCK_NUMBER_DIGITS, \"0\") +\n    transactionIndex.toString().padStart(TRANSACTION_INDEX_DIGITS, \"0\") +\n    eventType.toString() +\n    eventIndex.toString().padStart(EVENT_INDEX_DIGITS, \"0\");\n\n  if (result.length !== CHECKPOINT_LENGTH)\n    throw new Error(`Invalid stringified checkpoint: ${result}`);\n\n  return result;\n};\n\nexport const decodeCheckpoint = (checkpoint: string): Checkpoint => {\n  let offset = 0;\n\n  const blockTimestamp = +checkpoint.slice(\n    offset,\n    offset + BLOCK_TIMESTAMP_DIGITS,\n  );\n  offset += BLOCK_TIMESTAMP_DIGITS;\n\n  const chainId = BigInt(checkpoint.slice(offset, offset + CHAIN_ID_DIGITS));\n  offset += CHAIN_ID_DIGITS;\n\n  const blockNumber = BigInt(\n    checkpoint.slice(offset, offset + BLOCK_NUMBER_DIGITS),\n  );\n  offset += BLOCK_NUMBER_DIGITS;\n\n  const transactionIndex = BigInt(\n    checkpoint.slice(offset, offset + TRANSACTION_INDEX_DIGITS),\n  );\n  offset += TRANSACTION_INDEX_DIGITS;\n\n  const eventType = +checkpoint.slice(offset, offset + EVENT_TYPE_DIGITS);\n  offset += EVENT_TYPE_DIGITS;\n\n  const eventIndex = BigInt(\n    checkpoint.slice(offset, offset + EVENT_INDEX_DIGITS),\n  );\n  offset += EVENT_INDEX_DIGITS;\n\n  return {\n    blockTimestamp,\n    chainId,\n    blockNumber,\n    transactionIndex,\n    eventType,\n    eventIndex,\n  };\n};\n\nexport const zeroCheckpoint: Checkpoint = {\n  blockTimestamp: 0,\n  chainId: 0n,\n  blockNumber: 0n,\n  transactionIndex: 0n,\n  eventType: 0,\n  eventIndex: 0n,\n};\n\nexport const maxCheckpoint: Checkpoint = {\n  blockTimestamp: 99999_99999,\n  chainId: 9999_9999_9999_9999n,\n  blockNumber: 9999_9999_9999_9999n,\n  transactionIndex: 9999_9999_9999_9999n,\n  eventType: 9,\n  eventIndex: 9999_9999_9999_9999n,\n};\n\n/**\n * Returns true if two checkpoints are equal.\n */\nexport const isCheckpointEqual = (a: Checkpoint, b: Checkpoint) =>\n  encodeCheckpoint(a) === encodeCheckpoint(b);\n\n/**\n * Returns true if checkpoint a is greater than checkpoint b.\n * Returns false if the checkpoints are equal.\n */\nexport const isCheckpointGreaterThan = (a: Checkpoint, b: Checkpoint) =>\n  encodeCheckpoint(a) > encodeCheckpoint(b);\n\n/**\n * Returns true if checkpoint a is greater than or equal to checkpoint b.\n */\nexport const isCheckpointGreaterThanOrEqualTo = (\n  a: Checkpoint,\n  b: Checkpoint,\n) => encodeCheckpoint(a) >= encodeCheckpoint(b);\n\nexport const checkpointMax = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((max, checkpoint) => {\n    return isCheckpointGreaterThan(checkpoint, max) ? checkpoint : max;\n  });\n\nexport const checkpointMin = (...checkpoints: Checkpoint[]) =>\n  checkpoints.reduce((min, checkpoint) => {\n    return isCheckpointGreaterThan(min, checkpoint) ? checkpoint : min;\n  });\n\nexport const LATEST = encodeCheckpoint(maxCheckpoint);\n","export const formatEta = (ms: number) => {\n  // If less than 1 second, return ms.\n  if (ms < 1000) return `${Math.round(ms)}ms`;\n  const seconds = Math.floor(ms / 1000);\n\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds - h * 3600) / 60);\n  const s = seconds - h * 3600 - m * 60;\n\n  const hstr = h > 0 ? `${h}h ` : \"\";\n  const mstr = m > 0 || h > 0 ? `${m < 10 && h > 0 ? \"0\" : \"\"}${m}m ` : \"\";\n  const sstr = s > 0 || m > 0 ? `${s < 10 && m > 0 ? \"0\" : \"\"}${s}s` : \"\";\n\n  return `${hstr}${mstr}${sstr}`;\n};\n\nexport const formatPercentage = (cacheRate: number) => {\n  const decimal = Math.round(cacheRate * 1000) / 10;\n  return Number.isInteger(decimal) && decimal < 100\n    ? `${decimal}.0%`\n    : `${decimal}%`;\n};\n","import pg, { type PoolConfig } from \"pg\";\nimport { prettyPrint } from \"./print.js\";\n\n// Monkeypatch Pool.query to get more informative stack traces. I have no idea why this works.\n// https://stackoverflow.com/a/70601114\nconst originalClientQuery = pg.Client.prototype.query;\n// @ts-ignore\npg.Client.prototype.query = function query(\n  ...args: [queryText: string, values: any[], callback: () => void]\n) {\n  try {\n    return originalClientQuery.apply(this, args as any);\n  } catch (error_) {\n    const error = error_ as Error & { detail?: string; meta?: string[] };\n    const [statement, parameters_] = args ?? [\"empty\", []];\n\n    error.name = \"PostgresError\";\n\n    let parameters = parameters_ ?? [];\n    parameters =\n      parameters.length <= 25\n        ? parameters\n        : parameters.slice(0, 26).concat([\"...\"]);\n    const params = parameters.reduce<Record<number, any>>(\n      (acc, parameter, idx) => {\n        acc[idx + 1] = parameter;\n        return acc;\n      },\n      {},\n    );\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    if (error.detail) error.meta.push(`Detail:\\n  ${error.detail}`);\n    error.meta.push(`Statement:\\n  ${statement}`);\n    error.meta.push(`Parameters:\\n${prettyPrint(params)}`);\n\n    throw error;\n  }\n};\n\nclass ReadonlyClient extends pg.Client {\n  // @ts-expect-error\n  override connect(\n    callback: (err: Error) => void | undefined,\n  ): void | Promise<void> {\n    if (callback) {\n      super.connect(() => {\n        this.query(\n          \"SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY\",\n          callback,\n        );\n      });\n    } else {\n      return super.connect().then(async () => {\n        await this.query(\n          \"SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY\",\n        );\n      });\n    }\n  }\n}\n\nexport function createPool(config: PoolConfig) {\n  return new pg.Pool({\n    // https://stackoverflow.com/questions/59155572/how-to-set-query-timeout-in-relation-to-statement-timeout\n    statement_timeout: 2 * 60 * 1000, // 2 minutes\n    ...config,\n  });\n}\n\nexport function createReadonlyPool(config: PoolConfig) {\n  return new pg.Pool({\n    // https://stackoverflow.com/questions/59155572/how-to-set-query-timeout-in-relation-to-statement-timeout\n    statement_timeout: 2 * 60 * 1000, // 2 minutes\n    // @ts-expect-error: The custom Client is an undocumented option.\n    Client: ReadonlyClient,\n    ...config,\n  });\n}\n","// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/021ce8e5a3fb02db6139564345a91fc77cba08a6/src/errors/transaction.ts#L6-L19\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined) return null;\n\n      const trimmedValue =\n        typeof value === \"string\" && value.length > 80\n          ? value.slice(0, 80).concat(\"...\")\n          : value;\n\n      return [key, trimmedValue];\n    })\n    .filter(Boolean) as [string, string][];\n  const maxLength = entries.reduce(\n    (acc, [key]) => Math.max(acc, key.length),\n    0,\n  );\n  return entries\n    .map(([key, value]) => `  ${`${key}`.padEnd(maxLength + 1)}  ${value}`)\n    .join(\"\\n\");\n}\n","import { mkdirSync } from \"node:fs\";\nimport type { Prettify } from \"@/types/utils.js\";\nimport { type PGliteOptions as Options, PGlite } from \"@electric-sql/pglite\";\n\nexport type PGliteOptions = Prettify<Options & { dataDir: string }>;\n\nexport function createPglite(options: PGliteOptions) {\n  mkdirSync(options.dataDir, { recursive: true });\n  return new PGlite(options);\n}\n","import type { Common } from \"@/common/common.js\";\nimport { IgnorableError, NonRetryableError } from \"@/common/errors.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { Kysely, type KyselyConfig, type KyselyProps } from \"kysely\";\n\nconst RETRY_COUNT = 9;\nconst BASE_DURATION = 125;\n\nexport class HeadlessKysely<DB> extends Kysely<DB> {\n  private common: Common;\n  private name: string;\n  private isKilled = false;\n\n  constructor({\n    common,\n    name,\n    ...args\n  }: (KyselyConfig | KyselyProps) & { name: string; common: Common }) {\n    super(args);\n    this.common = common;\n    this.name = name;\n  }\n\n  override async destroy() {\n    this.isKilled = true;\n  }\n\n  wrap = async <T>(\n    options: { method: string; shouldRetry?: (error: Error) => boolean },\n    fn: () => Promise<T>,\n    // TypeScript can't infer that we always return or throw.\n    // @ts-ignore\n  ): Promise<T> => {\n    // First error thrown is often the most useful\n    let firstError: any;\n    let hasError = false;\n\n    for (let i = 0; i <= RETRY_COUNT; i++) {\n      const endClock = startClock();\n      try {\n        const result = await fn();\n        this.common.metrics.ponder_database_method_duration.observe(\n          { service: this.name, method: options.method },\n          endClock(),\n        );\n        return result;\n      } catch (_error) {\n        const error = _error as Error;\n\n        this.common.metrics.ponder_database_method_duration.observe(\n          { service: this.name, method: options.method },\n          endClock(),\n        );\n        this.common.metrics.ponder_database_method_error_total.inc({\n          service: this.name,\n          method: options.method,\n        });\n\n        if (this.isKilled) {\n          this.common.logger.trace({\n            service: this.name,\n            msg: `Ignored error during '${options.method}' database method (service is killed)`,\n          });\n          throw new IgnorableError();\n        }\n\n        if (!hasError) {\n          hasError = true;\n          firstError = error;\n        }\n\n        if (\n          error instanceof NonRetryableError ||\n          options.shouldRetry?.(error) === false\n        ) {\n          this.common.logger.warn({\n            service: this.name,\n            msg: `Failed '${options.method}' database method `,\n          });\n          throw error;\n        }\n\n        if (i === RETRY_COUNT) {\n          this.common.logger.warn({\n            service: this.name,\n            msg: `Failed '${options.method}' database method after '${i + 1}' attempts`,\n            error,\n          });\n          throw firstError;\n        }\n\n        const duration = BASE_DURATION * 2 ** i;\n        this.common.logger.debug({\n          service: this.name,\n          msg: `Failed '${options.method}' database method, retrying after ${duration} milliseconds`,\n          error,\n        });\n        await wait(duration);\n      }\n    }\n  };\n}\n","import type {\n  getAppProgress,\n  getIndexingProgress,\n  getSyncProgress,\n} from \"@/common/metrics.js\";\nimport { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport { Box, Text, render as inkRender } from \"ink\";\nimport React from \"react\";\nimport { ProgressBar } from \"./ProgressBar.js\";\nimport Table from \"./Table.js\";\n\nexport type UiState = {\n  port: number;\n  hostname: string;\n  sync: Awaited<ReturnType<typeof getSyncProgress>>;\n  indexing: Awaited<ReturnType<typeof getIndexingProgress>>;\n  app: Awaited<ReturnType<typeof getAppProgress>>;\n};\n\nexport const buildUiState = (): UiState => {\n  return {\n    port: 42069,\n    hostname: \"localhost\",\n    sync: [],\n    indexing: {\n      hasError: false,\n      overall: {\n        completedSeconds: 0,\n        totalSeconds: 0,\n        progress: 0,\n        completedToTimestamp: 0,\n        totalEvents: 0,\n      },\n      events: [],\n    },\n    app: {\n      progress: 0,\n      eta: undefined,\n      mode: undefined,\n    },\n  };\n};\n\nconst App = (ui: UiState) => {\n  const { sync, indexing, app, port, hostname } = ui;\n\n  return (\n    <Box flexDirection=\"column\">\n      <Text> </Text>\n\n      {indexing.hasError ? (\n        <Text color=\"cyan\">\n          Resolve the error and save your changes to reload the server.\n        </Text>\n      ) : (\n        <>\n          <Text bold={true}>Sync</Text>\n          <Text> </Text>\n          {sync.length === 0 ? (\n            <Text>Waiting to start...</Text>\n          ) : (\n            <Table\n              rows={sync}\n              columns={[\n                {\n                  title: \"Network\",\n                  key: \"networkName\",\n                  align: \"left\",\n                },\n                {\n                  title: \"Status\",\n                  key: \"status\",\n                  align: \"left\",\n                  format: (_, row) =>\n                    row.status === \"historical\"\n                      ? `${row.status} (${formatPercentage(row.progress)})`\n                      : row.status,\n                },\n                {\n                  title: \"Block\",\n                  key: \"block\",\n                  align: \"right\",\n                },\n                {\n                  title: \"RPC (req/s)\",\n                  key: \"rps\",\n                  align: \"right\",\n                  format: (_, row) => row.rps.toFixed(1),\n                },\n              ]}\n            />\n          )}\n          <Text> </Text>\n\n          <Text bold={true}>Indexing</Text>\n          <Text> </Text>\n          {indexing.events.length === 0 ? (\n            <Text>Waiting to start...</Text>\n          ) : (\n            <Table\n              rows={indexing.events}\n              columns={[\n                { title: \"Event\", key: \"eventName\", align: \"left\" },\n                { title: \"Count\", key: \"count\", align: \"right\" },\n                {\n                  title: \"Duration (ms)\",\n                  key: \"averageDuration\",\n                  align: \"right\",\n                  format: (v) =>\n                    v > 0 ? (v < 0.001 ? \"<0.001\" : v.toFixed(3)) : \"-\",\n                },\n              ]}\n            />\n          )}\n          <Text> </Text>\n\n          <Box flexDirection=\"row\">\n            <Text bold={true}>Progress </Text>\n            {app.mode === undefined || app.progress === 0 ? null : (\n              <Text>\n                (\n                {app.mode === \"historical\" ? (\n                  <Text color=\"yellowBright\">historical</Text>\n                ) : app.mode === \"realtime\" ? (\n                  <Text color=\"greenBright\">live</Text>\n                ) : (\n                  <Text color=\"greenBright\">complete</Text>\n                )}\n                )\n              </Text>\n            )}\n          </Box>\n          <Text> </Text>\n          <Box flexDirection=\"row\">\n            <ProgressBar current={app.progress} end={1} width={48} />\n            <Text>\n              {\" \"}\n              {formatPercentage(app.progress)}\n              {app.eta === undefined || app.eta === 0\n                ? null\n                : ` (${formatEta(app.eta)} eta)`}\n            </Text>\n          </Box>\n          <Text> </Text>\n\n          <Box flexDirection=\"column\">\n            <Text bold>GraphQL </Text>\n            <Box flexDirection=\"row\">\n              <Text>\n                Server live at http://{hostname}:{port}\n              </Text>\n            </Box>\n          </Box>\n        </>\n      )}\n    </Box>\n  );\n};\n\nexport const setupInkApp = (ui: UiState) => {\n  const app = inkRender(<App {...ui} />);\n\n  return {\n    render: (newUi: UiState) => {\n      app.rerender(<App {...newUi} />);\n    },\n    unmount: () => {\n      app.clear();\n      app.unmount();\n    },\n  };\n};\n","import { Text } from \"ink\";\nimport React from \"react\";\n\nexport const ProgressBar = ({ current = 5, end = 10, width = 36 }) => {\n  const maxCount = width || process.stdout.columns || 80;\n\n  const fraction = current / end;\n  const count = Math.min(Math.floor(maxCount * fraction), maxCount);\n\n  return (\n    <Text>\n      <Text>{\"█\".repeat(count)}</Text>\n      <Text>{\"░\".repeat(maxCount - count)}</Text>\n    </Text>\n  );\n};\n","import { Box, Text } from \"ink\"; // Assuming you're using ink for CLI UI components\nimport React from \"react\";\n\nconst MAX_COLUMN_WIDTH = 24;\n\nexport function Table<TRow extends { [key: string]: any }>(props: {\n  columns: {\n    title: string;\n    key: keyof TRow;\n    align: \"left\" | \"right\";\n    format?: (value: any, row: TRow) => string | number | React.JSX.Element;\n  }[];\n  rows: TRow[];\n}) {\n  const { columns, rows } = props;\n\n  const formattedRows = rows.map((row) =>\n    columns.reduce(\n      (acc, column) => ({\n        ...acc,\n        [column.key.toString()]: column.format\n          ? column.format(row[column.key], row)\n          : row[column.key],\n      }),\n      {} as TRow,\n    ),\n  );\n\n  const columnWidths = columns.map((column) => {\n    let maxWidth = Math.max(\n      ...formattedRows.map((row) =>\n        row[column.key] !== undefined ? row[column.key].toString().length : 9,\n      ),\n      column.title.length,\n    );\n    maxWidth = Math.min(maxWidth, MAX_COLUMN_WIDTH);\n    return maxWidth;\n  });\n\n  return (\n    <Box flexDirection=\"column\">\n      {/* Top Line */}\n      {/* <Box flexDirection=\"row\" key=\"top\">\n        <Text>┌</Text>\n        {columnWidths.map((width, index) => (\n          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n          <Text key={index}>\n            {\"─\".repeat(width + 2)}\n            {index < columns.length - 1 ? \"┬\" : \"┐\"}\n          </Text>\n        ))}\n      </Box> */}\n\n      {/* Column Titles */}\n      <Box flexDirection=\"row\" key=\"title\">\n        {columns.map(({ title }, index) => (\n          <React.Fragment key={`title-${title}`}>\n            <Text>│</Text>\n            <Box\n              width={columnWidths[index]}\n              justifyContent=\"flex-start\"\n              marginX={1}\n            >\n              <Text bold wrap=\"truncate-end\">\n                {title}\n              </Text>\n            </Box>\n          </React.Fragment>\n        ))}\n        <Text>│</Text>\n      </Box>\n\n      {/* Separator Line */}\n      <Box flexDirection=\"row\" key=\"separator\">\n        <Text>├</Text>\n        {columnWidths.map((width, index) => (\n          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n          <Text key={index}>\n            {\"─\".repeat(width + 2)}\n            {index < columns.length - 1 ? \"┼\" : \"┤\"}\n          </Text>\n        ))}\n      </Box>\n\n      {/* Rows of Data */}\n      {formattedRows.map((row, rowIndex) => (\n        <Box\n          flexDirection=\"row\"\n          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n          key={rowIndex}\n        >\n          {columns.map(({ key, align }, index) => (\n            // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n            <React.Fragment key={index}>\n              <Text>│</Text>\n              <Box\n                width={columnWidths[index]}\n                justifyContent={align === \"left\" ? \"flex-start\" : \"flex-end\"}\n                marginX={1}\n              >\n                <Text wrap=\"truncate-end\">{row[key]}</Text>\n              </Box>\n            </React.Fragment>\n          ))}\n          <Text>│</Text>\n        </Box>\n      ))}\n\n      {/* Bottom Line */}\n      {/* <Box flexDirection=\"row\" key=\"bottom\">\n        <Text>└</Text>\n        {columnWidths.map((width, index) => (\n          // biome-ignore lint/suspicious/noArrayIndexKey: <explanation>\n          <Text key={index}>\n            {\"─\".repeat(width + 2)}\n            {index < columns.length - 1 ? \"┴\" : \"┘\"}\n          </Text>\n        ))}\n      </Box> */}\n    </Box>\n  );\n}\n\nexport default Table;\n","import type { Common } from \"@/common/common.js\";\nimport {\n  getAppProgress,\n  getIndexingProgress,\n  getSyncProgress,\n} from \"@/common/metrics.js\";\nimport { buildUiState, setupInkApp } from \"./app.js\";\n\nexport function createUi({ common }: { common: Common }) {\n  const ui = buildUiState();\n  const { render, unmount } = setupInkApp(ui);\n\n  let isKilled = false;\n\n  const renderInterval = setInterval(async () => {\n    if (isKilled) return;\n\n    ui.sync = await getSyncProgress(common.metrics);\n    ui.indexing = await getIndexingProgress(common.metrics);\n    ui.app = await getAppProgress(common.metrics);\n\n    if (common.options.hostname) ui.hostname = common.options.hostname;\n    ui.port = (await common.metrics.ponder_http_server_port.get())\n      .values[0]!.value;\n\n    render(ui);\n  }, 100);\n\n  const kill = () => {\n    isKilled = true;\n    clearInterval(renderInterval);\n    unmount();\n  };\n\n  return {\n    kill,\n  };\n}\n","import type { Common } from \"@/common/common.js\";\nimport {\n  BigIntSerializationError,\n  FlushError,\n  InvalidStoreMethodError,\n  NotNullConstraintError,\n  RecordNotFoundError,\n  UndefinedTableError,\n  UniqueConstraintError,\n} from \"@/common/errors.js\";\nimport type { Database } from \"@/database/index.js\";\nimport {\n  type Schema,\n  getPrimaryKeyColumns,\n  getTableNames,\n  onchain,\n} from \"@/drizzle/index.js\";\nimport { getColumnCasing } from \"@/drizzle/kit/index.js\";\nimport { encodeCheckpoint, zeroCheckpoint } from \"@/utils/checkpoint.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport { createQueue } from \"@ponder/common\";\nimport {\n  type Column,\n  type QueryWithTypings,\n  type SQL,\n  type SQLWrapper,\n  type Table,\n  and,\n  eq,\n  getTableColumns,\n  sql,\n} from \"drizzle-orm\";\nimport { type PgTable, getTableConfig } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/pg-proxy\";\nimport { type IndexingStore, parseSqlError } from \"./index.js\";\n\nenum EntryType {\n  INSERT = 0,\n  UPDATE = 1,\n  FIND = 2,\n}\n\n/** Cache entries that need to be created in the database. */\ntype InsertEntry = {\n  type: EntryType.INSERT;\n  bytes: number;\n  operationIndex: number;\n  row: { [key: string]: unknown };\n};\n\n/** Cache entries that need to be updated in the database. */\ntype UpdateEntry = {\n  type: EntryType.UPDATE;\n  bytes: number;\n  operationIndex: number;\n  row: { [key: string]: unknown };\n};\n\n/**\n * Cache entries that mirror the database. Can be `null`,\n * meaning the entry doesn't exist.\n */\ntype FindEntry = {\n  type: EntryType.FIND;\n  bytes: number;\n  operationIndex: number;\n  row: { [key: string]: unknown } | typeof empty;\n};\n\n// TODO(kyle) key interning\ntype Key = string;\ntype Entry = InsertEntry | UpdateEntry | FindEntry;\ntype Cache = Map<Table, Map<Key, Entry>>;\n\n/** Empty state for indexing store */\nconst empty = null;\n\n/** Throw an error if `table` is not an `onchainTable`. */\nconst checkOnchainTable = (\n  table: Table,\n  method: \"find\" | \"insert\" | \"update\" | \"delete\",\n) => {\n  if (table === undefined)\n    throw new UndefinedTableError(\n      `Table object passed to db.${method}() is undefined`,\n    );\n\n  if (onchain in table) return;\n\n  throw new InvalidStoreMethodError(\n    method === \"find\"\n      ? `db.find() can only be used with onchain tables, and '${getTableConfig(table).name}' is an offchain table.`\n      : `Indexing functions can only write to onchain tables, and '${getTableConfig(table).name}' is an offchain table.`,\n  );\n};\n\n/**\n * Returns true if the column has a \"default\" value that is used when no value is passed.\n * Handles `.default`, `.$defaultFn()`, `.$onUpdateFn()`.\n */\nconst hasEmptyValue = (column: Column) => {\n  return column.hasDefault;\n};\n\n/**\n * Returns the \"default\" value for `column`.\n */\nconst getEmptyValue = (column: Column, type: EntryType) => {\n  if (type === EntryType.UPDATE && column.onUpdateFn) {\n    return column.onUpdateFn();\n  }\n  if (column.default !== undefined) return column.default;\n  if (column.defaultFn !== undefined) return column.defaultFn();\n  if (column.onUpdateFn !== undefined) return column.onUpdateFn();\n\n  // TODO(kyle) is it an invariant that it doesn't get here\n\n  return undefined;\n};\n\nexport const normalizeColumn = (\n  column: Column,\n  value: unknown,\n  type: EntryType,\n  // @ts-ignore\n): unknown => {\n  if (value === undefined) {\n    if (hasEmptyValue(column)) return getEmptyValue(column, type);\n    return null;\n  }\n  if (column.mapToDriverValue === undefined) return value;\n  try {\n    return column.mapFromDriverValue(column.mapToDriverValue(value));\n  } catch (e) {\n    if (\n      (e as Error)?.message?.includes(\"Do not know how to serialize a BigInt\")\n    ) {\n      const error = new BigIntSerializationError((e as Error).message);\n      error.meta.push(\n        \"Hint:\\n  The JSON column type does not support BigInt values. Use the replaceBigInts() helper function before inserting into the database. Docs: https://ponder.sh/docs/utilities/replace-bigints\",\n      );\n      throw error;\n    }\n  }\n};\n\nexport const createHistoricalIndexingStore = ({\n  common,\n  database,\n  schema,\n  initialCheckpoint,\n}: {\n  common: Common;\n  database: Database;\n  schema: Schema;\n  initialCheckpoint: string;\n}): IndexingStore<\"historical\"> => {\n  // Operation queue to make sure all queries are run in order, circumventing race conditions\n  const queue = createQueue<unknown, () => Promise<unknown>>({\n    browser: false,\n    initialStart: true,\n    concurrency: 1,\n    worker: (fn) => {\n      return fn();\n    },\n  });\n\n  const tableNameCache: Map<Table, string> = new Map();\n  const primaryKeysCache: Map<Table, { sql: string; js: string }[]> = new Map();\n  const cache: Cache = new Map();\n\n  for (const tableName of getTableNames(schema, \"\")) {\n    primaryKeysCache.set(\n      schema[tableName.js] as Table,\n      getPrimaryKeyColumns(schema[tableName.js] as PgTable),\n    );\n\n    cache.set(schema[tableName.js] as Table, new Map());\n    tableNameCache.set(schema[tableName.js] as Table, tableName.user);\n  }\n\n  ////////\n  // Helper functions\n  ////////\n\n  const getCacheKey = (\n    table: Table,\n    row: { [key: string]: unknown },\n  ): string => {\n    const primaryKeys = primaryKeysCache.get(table)!;\n\n    return (\n      primaryKeys\n        // @ts-ignore\n        .map((pk) => normalizeColumn(table[pk.js], row[pk.js]))\n        .join(\"_\")\n    );\n  };\n\n  const getCacheEntry = (table: Table, row: { [key: string]: unknown }) => {\n    return cache.get(table)!.get(getCacheKey(table, row));\n  };\n\n  const setCacheEntry = (\n    table: Table,\n    userRow: { [key: string]: unknown },\n    entryType: Exclude<EntryType, { type: EntryType.FIND }>,\n    existingRow?: { [key: string]: unknown },\n  ): { [key: string]: unknown } => {\n    let row = structuredClone(userRow);\n\n    if (existingRow) {\n      for (const [key, value] of Object.entries(row)) {\n        existingRow[key] = value;\n      }\n      existingRow = normalizeRow(table, existingRow, entryType);\n      const bytes = getBytes(existingRow);\n\n      cacheBytes += bytes;\n\n      cache.get(table)!.set(getCacheKey(table, existingRow), {\n        type: entryType,\n        row: existingRow,\n        operationIndex: totalCacheOps++,\n        bytes,\n      });\n\n      return structuredClone(existingRow);\n    } else {\n      row = normalizeRow(table, row, entryType);\n      const bytes = getBytes(row);\n\n      cacheBytes += bytes;\n\n      cache.get(table)!.set(getCacheKey(table, row), {\n        type: entryType,\n        bytes,\n        operationIndex: totalCacheOps++,\n        row,\n      });\n\n      return structuredClone(row);\n    }\n  };\n\n  const deleteCacheEntry = (table: Table, row: { [key: string]: unknown }) => {\n    const entry = getCacheEntry(table, row);\n    if (entry) {\n      cacheBytes -= entry!.bytes;\n    }\n    return cache.get(table)!.delete(getCacheKey(table, row));\n  };\n\n  const normalizeRow = (\n    table: Table,\n    row: { [key: string]: unknown },\n    type: EntryType,\n  ) => {\n    for (const [columnName, column] of Object.entries(getTableColumns(table))) {\n      // not-null constraint\n      if (\n        type === EntryType.INSERT &&\n        (row[columnName] === undefined || row[columnName] === null) &&\n        column.notNull &&\n        hasEmptyValue(column) === false\n      ) {\n        const error = new NotNullConstraintError(\n          `Column '${tableNameCache.get(table)}.${columnName}' violates not-null constraint.`,\n        );\n        error.meta.push(\n          `db.${type === EntryType.INSERT ? \"insert\" : \"update\"} arguments:\\n${prettyPrint(row)}`,\n        );\n        throw error;\n      }\n\n      row[columnName] = normalizeColumn(column, row[columnName], type);\n    }\n\n    return row;\n  };\n\n  const getBytes = (value: unknown) => {\n    // size of metadata\n    let size = 13;\n\n    if (typeof value === \"number\") {\n      size += 8;\n    } else if (typeof value === \"string\") {\n      size += 2 * value.length;\n    } else if (typeof value === \"boolean\") {\n      size += 4;\n    } else if (typeof value === \"bigint\") {\n      size += 48;\n    } else if (value === null || value === undefined) {\n      size += 8;\n    } else if (Array.isArray(value)) {\n      for (const e of value) {\n        size += getBytes(e);\n      }\n    } else {\n      for (const col of Object.values(value)) {\n        size += getBytes(col);\n      }\n    }\n\n    return size;\n  };\n\n  let isDatabaseEmpty = initialCheckpoint === encodeCheckpoint(zeroCheckpoint);\n  /** Estimated number of bytes used by cache. */\n  let cacheBytes = 0;\n  /** LRU counter. */\n  let totalCacheOps = 0;\n\n  const maxBytes = common.options.indexingCacheMaxBytes;\n  common.logger.debug({\n    service: \"indexing\",\n    msg: `Using a ${Math.round(maxBytes / (1024 * 1024))} MB indexing cache`,\n  });\n\n  /** Returns an sql where condition for `table` with `key`. */\n  const getWhereCondition = (table: Table, key: Object): SQL<unknown> => {\n    primaryKeysCache.get(table)!;\n\n    const conditions: SQLWrapper[] = [];\n\n    for (const { js } of primaryKeysCache.get(table)!) {\n      // @ts-ignore\n      conditions.push(eq(table[js]!, key[js]));\n    }\n\n    return and(...conditions)!;\n  };\n\n  const find = (table: Table, key: object) => {\n    return database.drizzle\n      .select()\n      .from(table)\n      .where(getWhereCondition(table as PgTable, key))\n      .then((res) => (res.length === 0 ? null : res[0]!));\n  };\n\n  // @ts-ignore\n  const indexingStore = {\n    // @ts-ignore\n    find: (table: Table, key) =>\n      queue.add(() =>\n        database.qb.user.wrap(\n          { method: `${tableNameCache.get(table) ?? \"unknown\"}.find()` },\n          async () => {\n            checkOnchainTable(table, \"find\");\n\n            const entry = getCacheEntry(table, key);\n\n            if (entry) {\n              // update lru ordering\n              getCacheEntry(table, key)!.operationIndex = totalCacheOps++;\n\n              return entry.row;\n            } else {\n              if (isDatabaseEmpty) return null;\n\n              const row = await find(table, key);\n              const bytes = getBytes(row);\n\n              cacheBytes += bytes;\n\n              cache.get(table)!.set(getCacheKey(table, key), {\n                type: EntryType.FIND,\n                bytes,\n                operationIndex: totalCacheOps++,\n                row,\n              });\n\n              return find(table, key);\n            }\n          },\n        ),\n      ),\n\n    // @ts-ignore\n    insert(table: Table) {\n      return {\n        values: (values: any) => {\n          // @ts-ignore\n          const inner = {\n            onConflictDoNothing: () =>\n              queue.add(() =>\n                database.qb.user.wrap(\n                  {\n                    method: `${tableNameCache.get(table) ?? \"unknown\"}.insert()`,\n                  },\n                  async () => {\n                    checkOnchainTable(table, \"insert\");\n\n                    if (Array.isArray(values)) {\n                      const rows = [];\n                      for (const value of values) {\n                        const entry = getCacheEntry(table, value);\n\n                        let row: { [key: string]: unknown } | null;\n\n                        if (entry?.row) {\n                          row = entry.row;\n                        } else {\n                          if (isDatabaseEmpty) row = null;\n                          else row = await find(table, value);\n                        }\n\n                        if (row === null) {\n                          rows.push(\n                            setCacheEntry(table, value, EntryType.INSERT),\n                          );\n                        } else {\n                          rows.push(null);\n                        }\n                      }\n                      return rows;\n                    } else {\n                      const entry = getCacheEntry(table, values);\n\n                      let row: { [key: string]: unknown } | null;\n\n                      if (entry?.row) {\n                        row = entry.row;\n                      } else {\n                        if (isDatabaseEmpty) row = null;\n                        else row = await find(table, values);\n                      }\n\n                      if (row === null) {\n                        return setCacheEntry(table, values, EntryType.INSERT);\n                      }\n\n                      return null;\n                    }\n                  },\n                ),\n              ),\n            onConflictDoUpdate: (valuesU: any) =>\n              queue.add(() =>\n                database.qb.user.wrap(\n                  {\n                    method: `${tableNameCache.get(table) ?? \"unknown\"}.insert()`,\n                  },\n                  async () => {\n                    checkOnchainTable(table, \"insert\");\n\n                    if (Array.isArray(values)) {\n                      const rows = [];\n                      for (const value of values) {\n                        const entry = getCacheEntry(table, value);\n                        deleteCacheEntry(table, value);\n\n                        let row: { [key: string]: unknown } | typeof empty;\n\n                        if (entry?.row) {\n                          row = entry.row;\n                        } else {\n                          if (isDatabaseEmpty) row = null;\n                          else row = await find(table, value);\n                        }\n\n                        if (row === null) {\n                          rows.push(\n                            setCacheEntry(table, value, EntryType.INSERT),\n                          );\n                        } else {\n                          if (typeof valuesU === \"function\") {\n                            rows.push(\n                              setCacheEntry(\n                                table,\n                                valuesU(row),\n                                entry?.type === EntryType.INSERT\n                                  ? EntryType.INSERT\n                                  : EntryType.UPDATE,\n                                row,\n                              ),\n                            );\n                          } else {\n                            rows.push(\n                              setCacheEntry(\n                                table,\n                                valuesU,\n                                entry?.type === EntryType.INSERT\n                                  ? EntryType.INSERT\n                                  : EntryType.UPDATE,\n                                row,\n                              ),\n                            );\n                          }\n                        }\n                      }\n                      return rows;\n                    } else {\n                      const entry = getCacheEntry(table, values);\n                      deleteCacheEntry(table, values);\n\n                      let row: { [key: string]: unknown } | typeof empty;\n\n                      if (entry?.row) {\n                        row = entry.row;\n                      } else {\n                        if (isDatabaseEmpty) row = null;\n                        else row = await find(table, values);\n                      }\n\n                      if (row === null) {\n                        return setCacheEntry(table, values, EntryType.INSERT);\n                      } else {\n                        if (typeof valuesU === \"function\") {\n                          return setCacheEntry(\n                            table,\n                            valuesU(row),\n                            entry?.type === EntryType.INSERT\n                              ? EntryType.INSERT\n                              : EntryType.UPDATE,\n                            row,\n                          );\n                        } else {\n                          return setCacheEntry(\n                            table,\n                            valuesU,\n                            entry?.type === EntryType.INSERT\n                              ? EntryType.INSERT\n                              : EntryType.UPDATE,\n                            row,\n                          );\n                        }\n                      }\n                    }\n                  },\n                ),\n              ),\n            // biome-ignore lint/suspicious/noThenProperty: <explanation>\n            then: (onFulfilled, onRejected) =>\n              queue\n                .add(() =>\n                  database.qb.user.wrap(\n                    {\n                      method: `${tableNameCache.get(table) ?? \"unknown\"}.insert()`,\n                    },\n                    async () => {\n                      checkOnchainTable(table, \"insert\");\n\n                      if (Array.isArray(values)) {\n                        const rows = [];\n                        for (const value of values) {\n                          if (getCacheEntry(table, value)?.row) {\n                            const error = new UniqueConstraintError(\n                              `Unique constraint failed for '${tableNameCache.get(table)}'.`,\n                            );\n                            error.meta.push(\n                              `db.insert arguments:\\n${prettyPrint(value)}`,\n                            );\n                            throw error;\n                          } else if (isDatabaseEmpty === false) {\n                            const findResult = await find(table, value);\n\n                            if (findResult) {\n                              const error = new UniqueConstraintError(\n                                `Unique constraint failed for '${tableNameCache.get(table)}'.`,\n                              );\n                              error.meta.push(\n                                `db.insert arguments:\\n${prettyPrint(value)}`,\n                              );\n                              throw error;\n                            }\n                          }\n\n                          rows.push(\n                            setCacheEntry(table, value, EntryType.INSERT),\n                          );\n                        }\n                        return rows;\n                      } else {\n                        if (getCacheEntry(table, values)?.row) {\n                          const error = new UniqueConstraintError(\n                            `Unique constraint failed for '${tableNameCache.get(table)}'.`,\n                          );\n                          error.meta.push(\n                            `db.insert arguments:\\n${prettyPrint(values)}`,\n                          );\n                          throw error;\n                        } else if (isDatabaseEmpty === false) {\n                          const findResult = await find(table, values);\n\n                          if (findResult) {\n                            const error = new UniqueConstraintError(\n                              `Unique constraint failed for '${tableNameCache.get(table)}'.`,\n                            );\n                            error.meta.push(\n                              `db.insert arguments:\\n${prettyPrint(values)}`,\n                            );\n                            throw error;\n                          }\n                        }\n\n                        return setCacheEntry(table, values, EntryType.INSERT);\n                      }\n                    },\n                  ),\n                )\n                .then(onFulfilled, onRejected),\n            catch: (onRejected) => inner.then(undefined, onRejected),\n            finally: (onFinally) =>\n              inner.then(\n                (value: any) => {\n                  onFinally?.();\n                  return value;\n                },\n                (reason: any) => {\n                  onFinally?.();\n                  throw reason;\n                },\n              ),\n            // @ts-ignore\n          } satisfies ReturnType<\n            ReturnType<IndexingStore<\"historical\">[\"insert\"]>[\"values\"]\n          >;\n\n          return inner;\n        },\n      };\n    },\n    // @ts-ignore\n    update(table: Table, key) {\n      return {\n        set: (values: any) =>\n          queue.add(() =>\n            database.qb.user.wrap(\n              { method: `${tableNameCache.get(table) ?? \"unknown\"}.update()` },\n              async () => {\n                checkOnchainTable(table, \"update\");\n\n                const entry = getCacheEntry(table, key);\n                deleteCacheEntry(table, key);\n\n                let row: { [key: string]: unknown };\n\n                if (entry?.row) {\n                  row = entry.row;\n                } else {\n                  if (isDatabaseEmpty) {\n                    const error = new RecordNotFoundError(\n                      `No existing record found in table '${tableNameCache.get(table)}'`,\n                    );\n                    error.meta.push(\n                      `db.update arguments:\\n${prettyPrint(key)}`,\n                    );\n                    throw error;\n                  }\n\n                  const findResult = await find(table, key);\n\n                  if (findResult) {\n                    row = findResult;\n                  } else {\n                    const error = new RecordNotFoundError(\n                      `No existing record found in table '${tableNameCache.get(table)}'`,\n                    );\n                    error.meta.push(\n                      `db.update arguments:\\n${prettyPrint(key)}`,\n                    );\n                    throw error;\n                  }\n                }\n\n                if (typeof values === \"function\") {\n                  return setCacheEntry(\n                    table,\n                    values(row),\n                    entry?.type === EntryType.INSERT\n                      ? EntryType.INSERT\n                      : EntryType.UPDATE,\n                    row,\n                  );\n                } else {\n                  return setCacheEntry(\n                    table,\n                    values,\n                    entry?.type === EntryType.INSERT\n                      ? EntryType.INSERT\n                      : EntryType.UPDATE,\n                    row,\n                  );\n                }\n              },\n            ),\n          ),\n      };\n    },\n    // @ts-ignore\n    delete: (table: Table, key) =>\n      queue.add(() =>\n        database.qb.user.wrap(\n          { method: `${tableNameCache.get(table) ?? \"unknown\"}.delete()` },\n          async () => {\n            checkOnchainTable(table, \"delete\");\n\n            const entry = getCacheEntry(table, key);\n            deleteCacheEntry(table, key);\n\n            if (entry?.row) {\n              if (entry.type === EntryType.INSERT) {\n                return true;\n              }\n\n              await database.drizzle\n                .delete(table)\n                .where(getWhereCondition(table, key));\n\n              return true;\n            } else {\n              if (isDatabaseEmpty) {\n                return false;\n              }\n\n              const deleteResult = await database.drizzle\n                .delete(table as Table)\n                .where(getWhereCondition(table as Table, key))\n                .returning();\n\n              return deleteResult.length > 0;\n            }\n          },\n        ),\n      ),\n    // @ts-ignore\n    sql: drizzle(\n      async (_sql, params, method, typings) => {\n        await database.createTriggers();\n        await indexingStore.flush();\n        await database.removeTriggers();\n\n        const query: QueryWithTypings = { sql: _sql, params, typings };\n\n        const res = await database.qb.user.wrap({ method: \"sql\" }, async () => {\n          try {\n            return await database.drizzle._.session\n              .prepareQuery(query, undefined, undefined, method === \"all\")\n              .execute();\n          } catch (e) {\n            throw parseSqlError(e);\n          }\n        });\n\n        // @ts-ignore\n        return { rows: res.rows.map((row) => Object.values(row)) };\n      },\n      { schema, casing: \"snake_case\" },\n    ),\n    async flush() {\n      await queue.add(async () => {\n        let cacheSize = 0;\n        for (const c of cache.values()) cacheSize += c.size;\n\n        const flushIndex =\n          totalCacheOps -\n          cacheSize * (1 - common.options.indexingCacheFlushRatio);\n        const shouldDelete = cacheBytes > maxBytes;\n        if (shouldDelete) isDatabaseEmpty = false;\n\n        const promises: Promise<void>[] = [];\n\n        for (const [table, tableCache] of cache) {\n          const batchSize = Math.round(\n            common.options.databaseMaxQueryParameters /\n              Object.keys(getTableColumns(table)).length,\n          );\n\n          const insertValues: InsertEntry[\"row\"][] = [];\n          const updateValues: UpdateEntry[\"row\"][] = [];\n\n          for (const [key, entry] of tableCache) {\n            if (entry.type === EntryType.INSERT) {\n              insertValues.push(entry.row);\n            }\n\n            if (entry.type === EntryType.UPDATE) {\n              updateValues.push(entry.row);\n            }\n\n            if (shouldDelete && entry.operationIndex < flushIndex) {\n              tableCache.delete(key);\n              cacheBytes -= entry.bytes;\n            }\n\n            entry.type = EntryType.FIND;\n          }\n\n          if (insertValues.length > 0) {\n            common.logger.debug({\n              service: \"indexing\",\n              msg: `Inserting ${insertValues.length} cached '${tableNameCache.get(table)}' rows into the database`,\n            });\n\n            while (insertValues.length > 0) {\n              const values = insertValues.splice(0, batchSize);\n              promises.push(\n                database.qb.user.wrap(\n                  { method: `${tableNameCache.get(table)}.flush()` },\n                  async () => {\n                    await database.drizzle\n                      .insert(table)\n                      .values(values)\n                      .catch((_error) => {\n                        const error = _error as Error;\n                        common.logger.error({\n                          service: \"indexing\",\n                          msg: \"Internal error occurred while flushing cache. Please report this error here: https://github.com/ponder-sh/ponder/issues\",\n                        });\n                        throw new FlushError(error.message);\n                      });\n                  },\n                ),\n              );\n            }\n          }\n\n          if (updateValues.length > 0) {\n            common.logger.debug({\n              service: \"indexing\",\n              msg: `Updating ${updateValues.length} cached '${tableNameCache.get(table)}' rows in the database`,\n            });\n\n            const primaryKeys = primaryKeysCache.get(table)!;\n            const set: { [column: string]: SQL } = {};\n\n            for (const [columnName, column] of Object.entries(\n              getTableColumns(table),\n            )) {\n              set[columnName] = sql.raw(\n                `excluded.\"${getColumnCasing(column, \"snake_case\")}\"`,\n              );\n            }\n\n            while (updateValues.length > 0) {\n              const values = updateValues.splice(0, batchSize);\n              promises.push(\n                database.qb.user.wrap(\n                  {\n                    method: `${tableNameCache.get(table)}.flush()`,\n                  },\n                  async () => {\n                    await database.drizzle\n                      .insert(table)\n                      .values(values)\n                      .onConflictDoUpdate({\n                        // @ts-ignore\n                        target: primaryKeys.map(({ js }) => table[js]),\n                        set,\n                      })\n                      .catch((_error) => {\n                        const error = _error as Error;\n                        common.logger.error({\n                          service: \"indexing\",\n                          msg: \"Internal error occurred while flushing cache. Please report this error here: https://github.com/ponder-sh/ponder/issues\",\n                        });\n                        throw new FlushError(error.message);\n                      });\n                  },\n                ),\n              );\n            }\n          }\n        }\n\n        await Promise.all(promises);\n      });\n    },\n    isCacheFull() {\n      return cacheBytes > maxBytes;\n    },\n  } satisfies IndexingStore<\"historical\">;\n\n  // @ts-ignore\n  return indexingStore;\n};\n","import {\n  BigIntSerializationError,\n  CheckConstraintError,\n  NotNullConstraintError,\n  UniqueConstraintError,\n  getBaseError,\n} from \"@/common/errors.js\";\nimport type { Schema } from \"@/drizzle/index.js\";\nimport type { Db } from \"@/types/db.js\";\n\nexport type IndexingStore<policy extends \"historical\" | \"realtime\"> =\n  policy extends \"realtime\"\n    ? Db<Schema>\n    : Db<Schema> & {\n        /** Persist the cache to the database. */\n        flush: () => Promise<void>;\n        /** Return `true` if the cache size in bytes is above the limit specified by `option.indexingCacheMaxBytes`. */\n        isCacheFull: () => boolean;\n      };\n\nexport const parseSqlError = (e: any): Error => {\n  let error = getBaseError(e);\n\n  if (error?.message?.includes(\"violates not-null constraint\")) {\n    error = new NotNullConstraintError(error.message);\n  } else if (error?.message?.includes(\"violates unique constraint\")) {\n    error = new UniqueConstraintError(error.message);\n  } else if (error?.message.includes(\"violates check constraint\")) {\n    error = new CheckConstraintError(error.message);\n  } else if (\n    error?.message?.includes(\"Do not know how to serialize a BigInt\")\n  ) {\n    error = new BigIntSerializationError(error.message);\n    error.meta.push(\n      \"Hint:\\n  The JSON column type does not support BigInt values. Use the replaceBigInts() helper function before inserting into the database. Docs: https://ponder.sh/docs/utilities/replace-bigints\",\n    );\n  }\n\n  return error;\n};\n","import type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { Status } from \"@/sync/index.js\";\nimport { sql } from \"kysely\";\n\nexport type MetadataStore = {\n  setStatus: (status: Status) => Promise<void>;\n  getStatus: () => Promise<Status | null>;\n};\n\nexport const getLiveMetadataStore = ({\n  db,\n}: { db: HeadlessKysely<any> }): Pick<MetadataStore, \"getStatus\"> => ({\n  getStatus: async () => {\n    return db.wrap({ method: \"_ponder_meta.getStatus()\" }, async () => {\n      const metadata = await sql\n        .raw<{ value: Status | null }>(`  \nWITH live AS (\n    SELECT value->>'instance_id' as instance_id FROM _ponder_meta WHERE key = 'live'\n)\nSELECT value \nFROM _ponder_meta \nWHERE key = 'status_' || (SELECT instance_id FROM live); \n        `)\n        .execute(db);\n\n      if (!metadata.rows[0]?.value === undefined) {\n        return null;\n      }\n\n      return metadata.rows[0]!.value;\n    });\n  },\n});\n\nexport const getMetadataStore = ({\n  db,\n  instanceId,\n}: {\n  db: HeadlessKysely<any>;\n  instanceId: string;\n}): MetadataStore => ({\n  getStatus: async () => {\n    return db.wrap({ method: \"_ponder_meta.getStatus()\" }, async () => {\n      const metadata = await db\n        .selectFrom(\"_ponder_meta\")\n        .select(\"value\")\n        .where(\"key\", \"=\", `status_${instanceId}`)\n        .executeTakeFirst();\n\n      if (metadata!.value === null) return null;\n\n      return metadata!.value as Status;\n    });\n  },\n  setStatus: (status: Status) => {\n    return db.wrap({ method: \"_ponder_meta.setStatus()\" }, async () => {\n      await db\n        .insertInto(\"_ponder_meta\")\n        .values({\n          key: `status_${instanceId}`,\n          value: status,\n        })\n        .onConflict((oc) =>\n          oc.column(\"key\").doUpdateSet({\n            value: status,\n          }),\n        )\n        .execute();\n    });\n  },\n});\n","import type { Common } from \"@/common/common.js\";\nimport {\n  InvalidStoreMethodError,\n  RecordNotFoundError,\n  UndefinedTableError,\n} from \"@/common/errors.js\";\nimport type { Database } from \"@/database/index.js\";\nimport {\n  type Schema,\n  getPrimaryKeyColumns,\n  getTableNames,\n  onchain,\n} from \"@/drizzle/index.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport {\n  type QueryWithTypings,\n  type SQL,\n  type SQLWrapper,\n  type Table,\n  and,\n  eq,\n} from \"drizzle-orm\";\nimport { type PgTable, getTableConfig } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/pg-proxy\";\nimport { createQueue } from \"../../../common/src/queue.js\";\nimport { normalizeColumn } from \"./historical.js\";\nimport { type IndexingStore, parseSqlError } from \"./index.js\";\n\n/** Throw an error if `table` is not an `onchainTable`. */\nconst checkOnchainTable = (\n  table: Table,\n  method: \"find\" | \"insert\" | \"update\" | \"delete\",\n) => {\n  if (table === undefined)\n    throw new UndefinedTableError(\n      `Table object passed to db.${method}() is undefined`,\n    );\n\n  if (onchain in table) return;\n\n  throw new InvalidStoreMethodError(\n    method === \"find\"\n      ? `db.find() can only be used with onchain tables, and '${getTableConfig(table).name}' is an offchain table.`\n      : `Indexing functions can only write to onchain tables, and '${getTableConfig(table).name}' is an offchain table.`,\n  );\n};\n\nexport const createRealtimeIndexingStore = ({\n  database,\n  schema,\n}: {\n  common: Common;\n  database: Database;\n  schema: Schema;\n}): IndexingStore<\"realtime\"> => {\n  // Operation queue to make sure all queries are run in order, circumventing race conditions\n  const queue = createQueue<unknown, () => Promise<unknown>>({\n    browser: false,\n    initialStart: true,\n    concurrency: 1,\n    worker: (fn) => {\n      return fn();\n    },\n  });\n\n  const tableNameCache: Map<Table, string> = new Map();\n  const primaryKeysCache: Map<Table, { sql: string; js: string }[]> = new Map();\n\n  for (const tableName of getTableNames(schema, \"\")) {\n    primaryKeysCache.set(\n      schema[tableName.js] as Table,\n      getPrimaryKeyColumns(schema[tableName.js] as PgTable),\n    );\n\n    tableNameCache.set(schema[tableName.js] as Table, tableName.user);\n  }\n\n  ////////\n  // Helper functions\n  ////////\n\n  const getCacheKey = (\n    table: Table,\n    row: { [key: string]: unknown },\n  ): string => {\n    const primaryKeys = primaryKeysCache.get(table)!;\n\n    return (\n      primaryKeys\n        // @ts-ignore\n        .map((pk) => normalizeColumn(table[pk.js], row[pk.js]))\n        .join(\"_\")\n    );\n  };\n\n  /** Returns an sql where condition for `table` with `key`. */\n  const getWhereCondition = (table: Table, key: Object): SQL<unknown> => {\n    primaryKeysCache.get(table)!;\n\n    const conditions: SQLWrapper[] = [];\n\n    for (const { js } of primaryKeysCache.get(table)!) {\n      // @ts-ignore\n      conditions.push(eq(table[js]!, key[js]));\n    }\n\n    return and(...conditions)!;\n  };\n\n  const find = (table: Table, key: object) => {\n    return database.drizzle\n      .select()\n      .from(table)\n      .where(getWhereCondition(table, key))\n      .then((res) => (res.length === 0 ? null : res[0]!));\n  };\n\n  // @ts-ignore\n  const indexingStore = {\n    // @ts-ignore\n    find: (table: Table, key) =>\n      queue.add(() =>\n        database.qb.user.wrap(\n          { method: `${tableNameCache.get(table) ?? \"unknown\"}.find()` },\n          async () => {\n            checkOnchainTable(table, \"find\");\n\n            return find(table, key);\n          },\n        ),\n      ),\n\n    // @ts-ignore\n    insert(table: Table) {\n      return {\n        values: (values: any) => {\n          // @ts-ignore\n          const inner = {\n            onConflictDoNothing: () =>\n              queue.add(() =>\n                database.qb.user.wrap(\n                  {\n                    method: `${tableNameCache.get(table) ?? \"unknown\"}.insert()`,\n                  },\n                  async () => {\n                    checkOnchainTable(table, \"insert\");\n\n                    const parseResult = (result: { [x: string]: any }[]) => {\n                      if (Array.isArray(values) === false) {\n                        return result.length === 1 ? result[0] : null;\n                      }\n\n                      const rows = [];\n                      let resultIndex = 0;\n\n                      for (let i = 0; i < values.length; i++) {\n                        if (\n                          getCacheKey(table, values[i]) ===\n                          getCacheKey(table, result[resultIndex]!)\n                        ) {\n                          rows.push(result[resultIndex++]!);\n                        } else {\n                          rows.push(null);\n                        }\n                      }\n\n                      return rows;\n                    };\n\n                    try {\n                      return await database.drizzle\n                        .insert(table)\n                        .values(values)\n                        .onConflictDoNothing()\n                        .returning()\n                        .then(parseResult);\n                    } catch (e) {\n                      throw parseSqlError(e);\n                    }\n                  },\n                ),\n              ),\n            onConflictDoUpdate: (valuesU: any) =>\n              queue.add(() =>\n                database.qb.user.wrap(\n                  {\n                    method: `${tableNameCache.get(table) ?? \"unknown\"}.insert()`,\n                  },\n                  async () => {\n                    checkOnchainTable(table, \"insert\");\n\n                    if (typeof valuesU === \"object\") {\n                      try {\n                        return await database.drizzle\n                          .insert(table)\n                          .values(values)\n                          .onConflictDoUpdate({\n                            target: primaryKeysCache\n                              .get(table)!\n                              // @ts-ignore\n                              .map(({ js }) => table[js]),\n                            set: valuesU,\n                          })\n                          .returning()\n                          .then((res) =>\n                            Array.isArray(values) ? res : res[0],\n                          );\n                      } catch (e) {\n                        throw parseSqlError(e);\n                      }\n                    }\n\n                    if (Array.isArray(values)) {\n                      const rows = [];\n                      for (const value of values) {\n                        const row = await find(table, value);\n\n                        if (row === null) {\n                          try {\n                            rows.push(\n                              await database.drizzle\n                                .insert(table)\n                                .values(value)\n                                .returning()\n                                .then((res) => res[0]),\n                            );\n                          } catch (e) {\n                            throw parseSqlError(e);\n                          }\n                        } else {\n                          try {\n                            rows.push(\n                              await database.drizzle\n                                .update(table)\n                                .set(valuesU(row))\n                                .where(getWhereCondition(table, value))\n                                .returning()\n                                .then((res) => res[0]),\n                            );\n                          } catch (e) {\n                            throw parseSqlError(e);\n                          }\n                        }\n                      }\n                      return rows;\n                    } else {\n                      const row = await find(table, values);\n\n                      if (row === null) {\n                        try {\n                          return await database.drizzle\n                            .insert(table)\n                            .values(values)\n                            .returning()\n                            .then((res) => res[0]);\n                        } catch (e) {\n                          throw parseSqlError(e);\n                        }\n                      } else {\n                        try {\n                          return await database.drizzle\n                            .update(table)\n                            .set(valuesU(row))\n                            .where(getWhereCondition(table, values))\n                            .returning()\n                            .then((res) => res[0]);\n                        } catch (e) {\n                          throw parseSqlError(e);\n                        }\n                      }\n                    }\n                  },\n                ),\n              ),\n            // biome-ignore lint/suspicious/noThenProperty: <explanation>\n            then: (onFulfilled, onRejected) =>\n              queue\n                .add(() =>\n                  database.qb.user.wrap(\n                    {\n                      method: `${tableNameCache.get(table) ?? \"unknown\"}.insert()`,\n                    },\n                    async () => {\n                      checkOnchainTable(table, \"insert\");\n\n                      try {\n                        return await database.drizzle\n                          .insert(table)\n                          .values(values)\n                          .returning()\n                          .then((res) =>\n                            Array.isArray(values) ? res : res[0],\n                          );\n                      } catch (e) {\n                        throw parseSqlError(e);\n                      }\n                    },\n                  ),\n                )\n                .then(onFulfilled, onRejected),\n            catch: (onRejected) => inner.then(undefined, onRejected),\n            finally: (onFinally) =>\n              inner.then(\n                (value: any) => {\n                  onFinally?.();\n                  return value;\n                },\n                (reason: any) => {\n                  onFinally?.();\n                  throw reason;\n                },\n              ),\n            // @ts-ignore\n          } satisfies ReturnType<\n            ReturnType<IndexingStore<\"realtime\">[\"insert\"]>[\"values\"]\n          >;\n\n          return inner;\n        },\n      };\n    },\n    // @ts-ignore\n    update(table: Table, key) {\n      return {\n        set: (values: any) =>\n          queue.add(() =>\n            database.qb.user.wrap(\n              { method: `${tableNameCache.get(table) ?? \"unknown\"}.update()` },\n              async () => {\n                checkOnchainTable(table, \"update\");\n\n                if (typeof values === \"function\") {\n                  const row = await find(table, key);\n\n                  if (row === null) {\n                    const error = new RecordNotFoundError(\n                      `No existing record found in table '${tableNameCache.get(table)}'`,\n                    );\n                    error.meta.push(\n                      `db.update arguments:\\n${prettyPrint(key)}`,\n                    );\n                    throw error;\n                  }\n\n                  try {\n                    return await database.drizzle\n                      .update(table)\n                      .set(values(row))\n                      .where(getWhereCondition(table, key))\n                      .returning()\n                      .then((res) => res[0]);\n                  } catch (e) {\n                    throw parseSqlError(e);\n                  }\n                } else {\n                  try {\n                    return await database.drizzle\n                      .update(table)\n                      .set(values)\n                      .where(getWhereCondition(table, key))\n                      .returning()\n                      .then((res) => res[0]);\n                  } catch (e) {\n                    throw parseSqlError(e);\n                  }\n                }\n              },\n            ),\n          ),\n      };\n    },\n    // @ts-ignore\n    delete: (table: Table, key) =>\n      queue.add(() =>\n        database.qb.user.wrap(\n          { method: `${tableNameCache.get(table) ?? \"unknown\"}.delete()` },\n          async () => {\n            checkOnchainTable(table, \"delete\");\n\n            const deleted = await database.drizzle\n              .delete(table)\n              .where(getWhereCondition(table, key))\n              .returning();\n\n            return deleted.length > 0;\n          },\n        ),\n      ),\n    // @ts-ignore\n    sql: drizzle(\n      (_sql, params, method, typings) =>\n        // @ts-ignore\n        queue.add(async () => {\n          const query: QueryWithTypings = { sql: _sql, params, typings };\n\n          const res = await database.qb.user.wrap(\n            { method: \"sql\" },\n            async () => {\n              try {\n                return await database.drizzle._.session\n                  .prepareQuery(query, undefined, undefined, method === \"all\")\n                  .execute();\n              } catch (e) {\n                throw parseSqlError(e);\n              }\n            },\n          );\n\n          // @ts-ignore\n          return { rows: res.rows.map((row) => Object.values(row)) };\n        }),\n      { schema, casing: \"snake_case\" },\n    ),\n  } satisfies IndexingStore<\"realtime\">;\n\n  // @ts-ignore\n  return indexingStore;\n};\n","import type { AbiEvents, AbiFunctions } from \"@/sync/abi.js\";\nimport type { SyncLog } from \"@/types/sync.js\";\nimport type { Abi, Address, Hex, LogTopic } from \"viem\";\n\nexport type Source = ContractSource | BlockSource;\nexport type ContractSource<\n  filter extends \"log\" | \"trace\" = \"log\" | \"trace\",\n  factory extends Factory | undefined = Factory | undefined,\n> = {\n  filter: filter extends \"log\" ? LogFilter<factory> : CallTraceFilter<factory>;\n} & ContractMetadata;\nexport type BlockSource = { filter: BlockFilter } & BlockMetadata;\n\nexport type Filter = LogFilter | BlockFilter | CallTraceFilter;\nexport type Factory = LogFactory;\n\nexport type ContractMetadata = {\n  type: \"contract\";\n  abi: Abi;\n  abiEvents: AbiEvents;\n  abiFunctions: AbiFunctions;\n  name: string;\n  networkName: string;\n};\nexport type BlockMetadata = {\n  type: \"block\";\n  name: string;\n  networkName: string;\n};\n\nexport type LogFilter<\n  factory extends Factory | undefined = Factory | undefined,\n> = {\n  type: \"log\";\n  chainId: number;\n  address: factory extends Factory ? factory : Address | Address[] | undefined;\n  topics: LogTopic[];\n  includeTransactionReceipts: boolean;\n  fromBlock: number;\n  toBlock: number | undefined;\n};\n\nexport type BlockFilter = {\n  type: \"block\";\n  chainId: number;\n  interval: number;\n  offset: number;\n  fromBlock: number;\n  toBlock: number | undefined;\n};\n\nexport type CallTraceFilter<\n  factory extends Factory | undefined = Factory | undefined,\n> = {\n  type: \"callTrace\";\n  chainId: number;\n  fromAddress: Address[] | undefined;\n  toAddress: factory extends Factory ? factory : Address[] | undefined;\n  functionSelectors: Hex[];\n  includeTransactionReceipts: boolean;\n  fromBlock: number;\n  toBlock: number | undefined;\n};\n\nexport type LogFactory = {\n  type: \"log\";\n  chainId: number;\n  address: Address | Address[];\n  eventSelector: Hex;\n  childAddressLocation: \"topic1\" | \"topic2\" | \"topic3\" | `offset${number}`;\n};\n\n/** Returns true if `address` is an address filter. */\nexport const isAddressFactory = (\n  address: Address | Address[] | Factory | undefined | null,\n): address is LogFactory => {\n  if (address === undefined || address === null || typeof address === \"string\")\n    return false;\n  return Array.isArray(address) ? isAddressFactory(address[0]) : true;\n};\n\nexport const getChildAddress = ({\n  log,\n  factory,\n}: { log: SyncLog; factory: Factory }): Address => {\n  if (factory.childAddressLocation.startsWith(\"offset\")) {\n    const childAddressOffset = Number(\n      factory.childAddressLocation.substring(6),\n    );\n    const start = 2 + 12 * 2 + childAddressOffset * 2;\n    const length = 20 * 2;\n\n    return `0x${log.data.substring(start, start + length)}`;\n  } else {\n    const start = 2 + 12 * 2;\n    const length = 20 * 2;\n    const topicIndex =\n      factory.childAddressLocation === \"topic1\"\n        ? 1\n        : factory.childAddressLocation === \"topic2\"\n          ? 2\n          : 3;\n    return `0x${log.topics[topicIndex]!.substring(start, start + length)}`;\n  }\n};\n","import type { IndexingFunctions } from \"@/build/configAndIndexingFunctions.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { Schema } from \"@/drizzle/index.js\";\nimport type { IndexingStore } from \"@/indexing-store/index.js\";\nimport type { Sync } from \"@/sync/index.js\";\nimport {\n  type ContractSource,\n  type Source,\n  isAddressFactory,\n} from \"@/sync/source.js\";\nimport type { Db } from \"@/types/db.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport type { Abi, Address } from \"viem\";\nimport { checksumAddress, createClient } from \"viem\";\nimport type {\n  BlockEvent,\n  CallTraceEvent,\n  Event,\n  LogEvent,\n  SetupEvent,\n} from \"../sync/events.js\";\nimport { addStackTrace } from \"./addStackTrace.js\";\nimport { type ReadOnlyClient, buildCachedActions } from \"./ponderActions.js\";\n\nexport type Context = {\n  network: { chainId: number; name: string };\n  client: ReadOnlyClient;\n  db: Db<Schema>;\n  contracts: Record<\n    string,\n    {\n      abi: Abi;\n      address?: Address | readonly Address[];\n      startBlock: number;\n      endBlock?: number;\n    }\n  >;\n};\n\nexport type Service = {\n  // static\n  common: Common;\n  indexingFunctions: IndexingFunctions;\n\n  // state\n  isKilled: boolean;\n\n  eventCount: {\n    [eventName: string]: number;\n  };\n  startCheckpoint: Checkpoint;\n\n  /**\n   * Reduce memory usage by reserving space for objects ahead of time\n   * instead of creating a new one for each event.\n   */\n  currentEvent: {\n    contextState: {\n      blockNumber: bigint;\n    };\n    context: Context;\n  };\n\n  // static cache\n  networkByChainId: { [chainId: number]: Network };\n  clientByChainId: { [chainId: number]: Context[\"client\"] };\n  contractsByChainId: { [chainId: number]: Context[\"contracts\"] };\n};\n\nexport const create = ({\n  indexingFunctions,\n  common,\n  sources,\n  networks,\n  sync,\n}: {\n  indexingFunctions: IndexingFunctions;\n  common: Common;\n  sources: Source[];\n  networks: Network[];\n  sync: Sync;\n}): Service => {\n  const contextState: Service[\"currentEvent\"][\"contextState\"] = {\n    blockNumber: undefined!,\n  };\n  const clientByChainId: Service[\"clientByChainId\"] = {};\n  const contractsByChainId: Service[\"contractsByChainId\"] = {};\n\n  const networkByChainId = networks.reduce<Service[\"networkByChainId\"]>(\n    (acc, cur) => {\n      acc[cur.chainId] = cur;\n      return acc;\n    },\n    {},\n  );\n\n  // build contractsByChainId\n  for (const source of sources) {\n    if (source.type === \"block\") continue;\n\n    let address: Address | undefined;\n\n    if (source.filter.type === \"log\") {\n      const _address = source.filter.address;\n      if (\n        isAddressFactory(_address) === false &&\n        Array.isArray(_address) === false &&\n        _address !== undefined\n      ) {\n        address = _address as Address;\n      }\n    } else {\n      const _address = source.filter.toAddress;\n      if (isAddressFactory(_address) === false && _address !== undefined) {\n        address = (_address as Address[])[0];\n      }\n    }\n\n    if (contractsByChainId[source.filter.chainId] === undefined) {\n      contractsByChainId[source.filter.chainId] = {};\n    }\n\n    // Note: multiple sources with the same contract (logs and traces)\n    // should only create one entry in the `contracts` object\n    if (contractsByChainId[source.filter.chainId]![source.name] !== undefined)\n      continue;\n\n    contractsByChainId[source.filter.chainId]![source.name] = {\n      abi: source.abi,\n      address: address ? checksumAddress(address) : address,\n      startBlock: source.filter.fromBlock,\n      endBlock: source.filter.toBlock,\n    };\n  }\n\n  // build cachedActions\n  const cachedActions = buildCachedActions(contextState);\n\n  // build clientByChainId\n  for (const network of networks) {\n    const transport = sync.getCachedTransport(network);\n    clientByChainId[network.chainId] = createClient({\n      transport,\n      chain: network.chain,\n      // @ts-ignore\n    }).extend(cachedActions);\n  }\n\n  // build eventCount\n  const eventCount: Service[\"eventCount\"] = {};\n  for (const eventName of Object.keys(indexingFunctions)) {\n    eventCount[eventName] = 0;\n  }\n\n  return {\n    common,\n    indexingFunctions,\n    isKilled: false,\n    eventCount,\n    startCheckpoint: decodeCheckpoint(sync.getStartCheckpoint()),\n    currentEvent: {\n      contextState,\n      context: {\n        network: { name: undefined!, chainId: undefined! },\n        contracts: undefined!,\n        client: undefined!,\n        db: undefined!,\n      },\n    },\n    networkByChainId,\n    clientByChainId,\n    contractsByChainId,\n  };\n};\n\nexport const processSetupEvents = async (\n  indexingService: Service,\n  {\n    sources,\n    networks,\n  }: {\n    sources: Source[];\n    networks: Network[];\n  },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  for (const eventName of Object.keys(indexingService.indexingFunctions)) {\n    if (!eventName.endsWith(\":setup\")) continue;\n\n    const [contractName] = eventName.split(\":\");\n\n    for (const network of networks) {\n      const source = sources.find(\n        (s) =>\n          s.type === \"contract\" &&\n          s.name === contractName &&\n          s.filter.chainId === network.chainId,\n      )! as ContractSource;\n\n      if (indexingService.isKilled) return { status: \"killed\" };\n      indexingService.eventCount[eventName]!++;\n\n      const result = await executeSetup(indexingService, {\n        event: {\n          type: \"setup\",\n          chainId: network.chainId,\n          checkpoint: encodeCheckpoint({\n            ...zeroCheckpoint,\n            chainId: BigInt(network.chainId),\n            blockNumber: BigInt(source.filter.fromBlock),\n          }),\n\n          name: eventName,\n\n          block: BigInt(source.filter.fromBlock),\n        },\n      });\n\n      if (result.status !== \"success\") {\n        return result;\n      }\n    }\n  }\n\n  return { status: \"success\" };\n};\n\nexport const processEvents = async (\n  indexingService: Service,\n  { events }: { events: Event[] },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  for (let i = 0; i < events.length; i++) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n\n    const event = events[i]!;\n\n    switch (event.type) {\n      case \"log\": {\n        indexingService.eventCount[event.name]!++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${event.name}\", checkpoint=${event.checkpoint})`,\n        });\n\n        const result = await executeLog(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${event.name}\", checkpoint=${event.checkpoint})`,\n        });\n\n        break;\n      }\n\n      case \"block\": {\n        indexingService.eventCount[event.name]!++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${event.name}\", checkpoint=${event.checkpoint})`,\n        });\n\n        const result = await executeBlock(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${event.name}\", checkpoint=${event.checkpoint})`,\n        });\n\n        break;\n      }\n\n      case \"callTrace\": {\n        indexingService.eventCount[event.name]!++;\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Started indexing function (event=\"${event.name}\", checkpoint=${event.checkpoint})`,\n        });\n\n        const result = await executeCallTrace(indexingService, { event });\n        if (result.status !== \"success\") {\n          return result;\n        }\n\n        indexingService.common.logger.trace({\n          service: \"indexing\",\n          msg: `Completed indexing function (event=\"${event.name}\", checkpoint=${event.checkpoint})`,\n        });\n\n        break;\n      }\n\n      default:\n        never(event);\n    }\n\n    // periodically update metrics\n    if (i % 93 === 0) {\n      updateCompletedEvents(indexingService);\n\n      const eventTimestamp = decodeCheckpoint(event.checkpoint).blockTimestamp;\n\n      indexingService.common.metrics.ponder_indexing_completed_seconds.set(\n        eventTimestamp - indexingService.startCheckpoint.blockTimestamp,\n      );\n      indexingService.common.metrics.ponder_indexing_completed_timestamp.set(\n        eventTimestamp,\n      );\n\n      // Note: allows for terminal and logs to be updated\n      await new Promise(setImmediate);\n    }\n  }\n\n  // set completed seconds\n  if (events.length > 0) {\n    const lastEventInBatchTimestamp = decodeCheckpoint(\n      events[events.length - 1]!.checkpoint,\n    ).blockTimestamp;\n\n    indexingService.common.metrics.ponder_indexing_completed_seconds.set(\n      lastEventInBatchTimestamp -\n        indexingService.startCheckpoint.blockTimestamp,\n    );\n    indexingService.common.metrics.ponder_indexing_completed_timestamp.set(\n      lastEventInBatchTimestamp,\n    );\n  }\n  // set completed events\n  updateCompletedEvents(indexingService);\n\n  return { status: \"success\" };\n};\n\nexport const setIndexingStore = (\n  indexingService: Service,\n  indexingStore: IndexingStore<\"historical\" | \"realtime\">,\n) => {\n  indexingService.currentEvent.context.db = {\n    find: indexingStore.find,\n    insert: indexingStore.insert,\n    update: indexingStore.update,\n    delete: indexingStore.delete,\n    sql: indexingStore.sql,\n  };\n};\n\nexport const kill = (indexingService: Service) => {\n  indexingService.common.logger.debug({\n    service: \"indexing\",\n    msg: \"Killed indexing service\",\n  });\n  indexingService.isKilled = true;\n};\n\nexport const updateTotalSeconds = (\n  indexingService: Service,\n  endCheckpoint: Checkpoint,\n) => {\n  indexingService.common.metrics.ponder_indexing_total_seconds.set(\n    endCheckpoint.blockTimestamp -\n      indexingService.startCheckpoint.blockTimestamp,\n  );\n};\n\nconst updateCompletedEvents = (indexingService: Service) => {\n  for (const event of Object.keys(indexingService.eventCount)) {\n    const metricLabel = {\n      event,\n    };\n    indexingService.common.metrics.ponder_indexing_completed_events.set(\n      metricLabel,\n      indexingService.eventCount[event]!,\n    );\n  }\n};\n\nconst executeSetup = async (\n  indexingService: Service,\n  { event }: { event: SetupEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const indexingFunction = indexingFunctions[event.name];\n  const metricLabel = { event: event.name };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.blockNumber = event.block;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error;\n\n    const decodedCheckpoint = decodeCheckpoint(event.checkpoint);\n\n    addStackTrace(error, common.options);\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${event.name}' event in '${networkByChainId[event.chainId]!.name}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeLog = async (\n  indexingService: Service,\n  { event }: { event: LogEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const indexingFunction = indexingFunctions[event.name];\n  const metricLabel = { event: event.name };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      event: event.event,\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error & { meta?: string[] };\n\n    const decodedCheckpoint = decodeCheckpoint(event.checkpoint);\n\n    addStackTrace(error, common.options);\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    if (error.meta.length === 0) {\n      error.meta.push(`Event arguments:\\n${prettyPrint(event.event.args)}`);\n    }\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${event.name}' event in '${networkByChainId[event.chainId]!.name}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeBlock = async (\n  indexingService: Service,\n  { event }: { event: BlockEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const indexingFunction = indexingFunctions[event.name];\n  const metricLabel = { event: event.name };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      event: event.event,\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error & { meta?: string[] };\n\n    const decodedCheckpoint = decodeCheckpoint(event.checkpoint);\n\n    addStackTrace(error, common.options);\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    error.meta.push(\n      `Block:\\n${prettyPrint({\n        hash: event.event.block.hash,\n        number: event.event.block.number,\n        timestamp: event.event.block.timestamp,\n      })}`,\n    );\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing ${event.name} event at chainId=${decodedCheckpoint.chainId}, block=${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n\nconst executeCallTrace = async (\n  indexingService: Service,\n  { event }: { event: CallTraceEvent },\n): Promise<\n  | { status: \"error\"; error: Error }\n  | { status: \"success\" }\n  | { status: \"killed\" }\n> => {\n  const {\n    common,\n    indexingFunctions,\n    currentEvent,\n    networkByChainId,\n    contractsByChainId,\n    clientByChainId,\n  } = indexingService;\n  const indexingFunction = indexingFunctions[event.name];\n  const metricLabel = { event: event.name };\n\n  try {\n    // set currentEvent\n    currentEvent.context.network.chainId = event.chainId;\n    currentEvent.context.network.name = networkByChainId[event.chainId]!.name;\n    currentEvent.context.client = clientByChainId[event.chainId]!;\n    currentEvent.context.contracts = contractsByChainId[event.chainId]!;\n    currentEvent.contextState.blockNumber = event.event.block.number;\n\n    const endClock = startClock();\n\n    await indexingFunction!({\n      event: event.event,\n      context: currentEvent.context,\n    });\n\n    common.metrics.ponder_indexing_function_duration.observe(\n      metricLabel,\n      endClock(),\n    );\n  } catch (_error) {\n    if (indexingService.isKilled) return { status: \"killed\" };\n    const error = _error as Error & { meta?: string[] };\n\n    const decodedCheckpoint = decodeCheckpoint(event.checkpoint);\n\n    addStackTrace(error, common.options);\n\n    error.meta = Array.isArray(error.meta) ? error.meta : [];\n    error.meta.push(`Call trace arguments:\\n${prettyPrint(event.event.args)}`);\n\n    common.logger.error({\n      service: \"indexing\",\n      msg: `Error while processing '${event.name}' event in '${networkByChainId[event.chainId]!.name}' block ${decodedCheckpoint.blockNumber}`,\n      error,\n    });\n\n    common.metrics.ponder_indexing_has_error.set(1);\n\n    return { status: \"error\", error: error };\n  }\n\n  return { status: \"success\" };\n};\n","import { readFileSync } from \"node:fs\";\nimport type { Options } from \"@/common/options.js\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport { type StackFrame, parse as parseStackTrace } from \"stacktrace-parser\";\n\n// Note: this currently works for both indexing functions and api\n// routes only because the api route dir is a subdir of the indexing function\n// dir.\n\nexport const addStackTrace = (error: Error, options: Options) => {\n  if (!error.stack) return;\n\n  const stackTrace = parseStackTrace(error.stack);\n\n  let codeFrame: string | undefined;\n  let userStackTrace: StackFrame[];\n\n  // Find first frame that occurred within user code.\n  const firstUserFrameIndex = stackTrace.findIndex((frame) =>\n    frame.file?.includes(options.indexingDir),\n  );\n\n  if (firstUserFrameIndex >= 0) {\n    userStackTrace = stackTrace.filter((frame) =>\n      frame.file?.includes(options.indexingDir),\n    );\n\n    const firstUserFrame = stackTrace[firstUserFrameIndex];\n    if (firstUserFrame?.file && firstUserFrame?.lineNumber) {\n      try {\n        const sourceContent = readFileSync(firstUserFrame.file, {\n          encoding: \"utf-8\",\n        });\n        codeFrame = codeFrameColumns(\n          sourceContent,\n          {\n            start: {\n              line: firstUserFrame.lineNumber,\n              column: firstUserFrame.column ?? undefined,\n            },\n          },\n          { highlightCode: true },\n        );\n      } catch (err) {\n        // Ignore errors here.\n      }\n    }\n  } else {\n    userStackTrace = stackTrace;\n  }\n\n  const formattedStackTrace = [\n    `${error.name}: ${error.message}`,\n    ...userStackTrace.map(({ file, lineNumber, column, methodName }) => {\n      const prefix = \"    at\";\n      const path = `${file}${lineNumber !== null ? `:${lineNumber}` : \"\"}${\n        column !== null ? `:${column}` : \"\"\n      }`;\n      if (methodName === null || methodName === \"<unknown>\") {\n        return `${prefix} ${path}`;\n      } else {\n        return `${prefix} ${methodName} (${path})`;\n      }\n    }),\n    codeFrame,\n  ].join(\"\\n\");\n\n  error.stack = formattedStackTrace;\n};\n","import type { Prettify } from \"@/types/utils.js\";\nimport type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionArgs,\n  ContractFunctionName,\n  GetBalanceParameters,\n  GetBalanceReturnType,\n  GetCodeParameters,\n  GetCodeReturnType,\n  GetEnsNameParameters,\n  GetEnsNameReturnType,\n  GetStorageAtParameters,\n  GetStorageAtReturnType,\n  MulticallParameters,\n  MulticallReturnType,\n  PublicRpcSchema,\n  ReadContractParameters,\n  ReadContractReturnType,\n  Transport,\n} from \"viem\";\nimport {\n  getBalance as viemGetBalance,\n  getCode as viemGetCode,\n  getEnsName as viemGetEnsName,\n  getStorageAt as viemGetStorageAt,\n  multicall as viemMulticall,\n  readContract as viemReadContract,\n} from \"viem/actions\";\nimport type { Service } from \"./service.js\";\n\nexport type BlockOptions =\n  | {\n      cache?: undefined;\n      blockNumber?: undefined;\n    }\n  | {\n      cache: \"immutable\";\n      blockNumber?: undefined;\n    }\n  | {\n      cache?: undefined;\n      blockNumber: bigint;\n    };\n\nexport type PonderActions = {\n  getBalance: (\n    args: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetBalanceReturnType>;\n  getCode: (\n    args: Omit<GetCodeParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetCodeReturnType>;\n  getStorageAt: (\n    args: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions,\n  ) => Promise<GetStorageAtReturnType>;\n  multicall: <\n    const contracts extends readonly unknown[],\n    allowFailure extends boolean = true,\n  >(\n    args: Omit<\n      MulticallParameters<contracts, allowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions,\n  ) => Promise<MulticallReturnType<contracts, allowFailure>>;\n  readContract: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, \"pure\" | \"view\">,\n    const args extends ContractFunctionArgs<abi, \"pure\" | \"view\", functionName>,\n  >(\n    args: Omit<\n      ReadContractParameters<abi, functionName, args>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions,\n  ) => Promise<ReadContractReturnType<abi, functionName, args>>;\n  getEnsName: (\n    args: Omit<GetEnsNameParameters, \"blockTag\" | \"blockNumber\"> & BlockOptions,\n  ) => Promise<GetEnsNameReturnType>;\n};\n\nexport type ReadOnlyClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n> = Prettify<\n  Client<transport, chain, undefined, PublicRpcSchema, PonderActions>\n>;\n\nexport const buildCachedActions = (\n  contextState: Pick<Service[\"currentEvent\"][\"contextState\"], \"blockNumber\">,\n) => {\n  return <\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined,\n  >(\n    client: Client<TTransport, TChain, TAccount>,\n  ): PonderActions => ({\n    getBalance: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetBalanceParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetBalanceReturnType> =>\n      viemGetBalance(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    getCode: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetCodeParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetCodeReturnType> =>\n      viemGetCode(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    getStorageAt: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetStorageAtParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetStorageAtReturnType> =>\n      viemGetStorageAt(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    multicall: <\n      const contracts extends readonly unknown[],\n      allowFailure extends boolean = true,\n    >({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<\n      MulticallParameters<contracts, allowFailure>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions): Promise<MulticallReturnType<contracts, allowFailure>> =>\n      viemMulticall(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n    // @ts-ignore\n    readContract: <\n      const abi extends Abi | readonly unknown[],\n      functionName extends ContractFunctionName<abi, \"pure\" | \"view\">,\n      const args extends ContractFunctionArgs<\n        abi,\n        \"pure\" | \"view\",\n        functionName\n      >,\n    >({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<\n      ReadContractParameters<abi, functionName, args>,\n      \"blockTag\" | \"blockNumber\"\n    > &\n      BlockOptions): Promise<ReadContractReturnType<abi, functionName, args>> =>\n      viemReadContract(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      } as ReadContractParameters<abi, functionName, args>),\n    getEnsName: ({\n      cache,\n      blockNumber: userBlockNumber,\n      ...args\n    }: Omit<GetEnsNameParameters, \"blockTag\" | \"blockNumber\"> &\n      BlockOptions): Promise<GetEnsNameReturnType> =>\n      viemGetEnsName(client, {\n        ...args,\n        ...(cache === \"immutable\"\n          ? { blockTag: \"latest\" }\n          : { blockNumber: userBlockNumber ?? contextState.blockNumber }),\n      }),\n  });\n};\n","import { type Extend, extend } from \"@/utils/extend.js\";\nimport {\n  create,\n  kill,\n  processEvents,\n  processSetupEvents,\n  setIndexingStore,\n  updateTotalSeconds,\n} from \"./service.js\";\nimport type { Context, Service } from \"./service.js\";\n\nconst methods = {\n  create,\n  kill,\n  processEvents,\n  processSetupEvents,\n  updateTotalSeconds,\n  setIndexingStore,\n};\n\nexport const createIndexingService = extend(create, methods);\n\nexport type IndexingService = Extend<Service, typeof methods>;\n\nexport type { Context };\n","import type { PonderSyncSchema } from \"@/sync-store/encoding.js\";\nimport type { Address, Hex } from \"viem\";\nimport {\n  type BlockFilter,\n  type CallTraceFilter,\n  type Factory,\n  type LogFactory,\n  type LogFilter,\n  isAddressFactory,\n} from \"./source.js\";\n\nexport type LogFilterFragment<\n  factory extends Factory | undefined = Factory | undefined,\n> = factory extends Factory\n  ? PonderSyncSchema[\"factoryLogFilters\"]\n  : PonderSyncSchema[\"logFilters\"];\n\nexport type BlockFilterFragment = PonderSyncSchema[\"blockFilters\"];\n\nexport type TraceFilterFragment<\n  factory extends Factory | undefined = Factory | undefined,\n> = factory extends Factory\n  ? PonderSyncSchema[\"factoryTraceFilters\"]\n  : PonderSyncSchema[\"traceFilters\"];\n\n/**\n * Generates log filter fragments from a log filter.\n *\n * @param logFilter Log filter to be decomposed into fragments.\n * @returns A list of log filter fragments.\n */\nexport const buildLogFilterFragments = <factory extends Factory | undefined>({\n  chainId,\n  address,\n  topics,\n  includeTransactionReceipts,\n}: Omit<\n  LogFilter<factory>,\n  \"fromBlock\" | \"toBlock\"\n>): LogFilterFragment<factory>[] => {\n  const fragments: LogFilterFragment[] = [];\n  const { topic0, topic1, topic2, topic3 } = parseTopics(topics);\n\n  const idCallback = ({\n    chainId,\n    address: address_,\n    topic0: topic0_,\n    topic1: topic1_,\n    topic2: topic2_,\n    topic3: topic3_,\n    includeTransactionReceipts,\n  }: Omit<LogFilterFragment, \"id\" | \"address\"> & {\n    address: Address | null;\n  }) => {\n    return `${chainId}_${address_}_${topic0_}_${topic1_}_${topic2_}_${topic3_}_${\n      includeTransactionReceipts\n    }`;\n  };\n\n  const factoryIdCallback = ({\n    chainId,\n    address: address_,\n    eventSelector: eventSelector_,\n    childAddressLocation: childAddressLocation_,\n    topic0: topic0_,\n    topic1: topic1_,\n    topic2: topic2_,\n    topic3: topic3_,\n    includeTransactionReceipts,\n  }: Omit<LogFilterFragment, \"id\" | \"address\"> & {\n    address: Address;\n    eventSelector: LogFactory[\"eventSelector\"];\n    childAddressLocation: LogFactory[\"childAddressLocation\"];\n  }) => {\n    return `${chainId}_${address_}_${eventSelector_}_${childAddressLocation_}_${topic0_}_${topic1_}_${topic2_}_${topic3_}_${\n      includeTransactionReceipts\n    }`;\n  };\n\n  if (isAddressFactory(address)) {\n    for (const factoryAddress_ of Array.isArray(address.address)\n      ? address.address\n      : [address.address]) {\n      for (const topic0_ of Array.isArray(topic0) ? topic0 : [topic0]) {\n        for (const topic1_ of Array.isArray(topic1) ? topic1 : [topic1]) {\n          for (const topic2_ of Array.isArray(topic2) ? topic2 : [topic2]) {\n            for (const topic3_ of Array.isArray(topic3) ? topic3 : [topic3]) {\n              fragments.push({\n                id: factoryIdCallback({\n                  chainId,\n                  address: factoryAddress_,\n                  eventSelector: address.eventSelector,\n                  childAddressLocation: address.childAddressLocation,\n                  topic0: topic0_,\n                  topic1: topic1_,\n                  topic2: topic2_,\n                  topic3: topic3_,\n                  includeTransactionReceipts: includeTransactionReceipts\n                    ? 1\n                    : 0,\n                }),\n                chainId,\n                address: factoryAddress_,\n                eventSelector: address.eventSelector,\n                childAddressLocation: address.childAddressLocation,\n                topic0: topic0_,\n                topic1: topic1_,\n                topic2: topic2_,\n                topic3: topic3_,\n                includeTransactionReceipts: includeTransactionReceipts ? 1 : 0,\n              });\n            }\n          }\n        }\n      }\n    }\n  } else {\n    for (const address_ of Array.isArray(address)\n      ? address\n      : [address ?? null]) {\n      for (const topic0_ of Array.isArray(topic0) ? topic0 : [topic0]) {\n        for (const topic1_ of Array.isArray(topic1) ? topic1 : [topic1]) {\n          for (const topic2_ of Array.isArray(topic2) ? topic2 : [topic2]) {\n            for (const topic3_ of Array.isArray(topic3) ? topic3 : [topic3]) {\n              fragments.push({\n                id: idCallback({\n                  chainId,\n                  address: address_,\n                  topic0: topic0_,\n                  topic1: topic1_,\n                  topic2: topic2_,\n                  topic3: topic3_,\n                  includeTransactionReceipts: includeTransactionReceipts\n                    ? 1\n                    : 0,\n                }),\n                chainId,\n                address: address_,\n                topic0: topic0_,\n                topic1: topic1_,\n                topic2: topic2_,\n                topic3: topic3_,\n                includeTransactionReceipts: includeTransactionReceipts ? 1 : 0,\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return fragments as LogFilterFragment<factory>[];\n};\n\nfunction parseTopics(topics: (Hex | Hex[] | null)[] | undefined) {\n  return {\n    topic0: topics?.[0] ?? null,\n    topic1: topics?.[1] ?? null,\n    topic2: topics?.[2] ?? null,\n    topic3: topics?.[3] ?? null,\n  } as {\n    topic0: Hex | Hex[] | null;\n    topic1: Hex | Hex[] | null;\n    topic2: Hex | Hex[] | null;\n    topic3: Hex | Hex[] | null;\n  };\n}\n\nexport const buildBlockFilterFragment = ({\n  chainId,\n  interval,\n  offset,\n}: Omit<BlockFilter, \"fromBlock\" | \"toBlock\">): BlockFilterFragment => {\n  return {\n    id: `${chainId}_${interval}_${offset}`,\n    chainId,\n    interval,\n    offset,\n  };\n};\n\nexport const buildTraceFilterFragments = <factory extends Factory | undefined>({\n  chainId,\n  fromAddress,\n  toAddress,\n}: Omit<CallTraceFilter<factory>, \"fromBlock\" | \"toBlock\"> & {\n  chainId: number;\n}): TraceFilterFragment<factory>[] => {\n  const fragments: TraceFilterFragment[] = [];\n\n  const idCallback = ({\n    chainId,\n    fromAddress,\n    toAddress,\n  }: Omit<TraceFilterFragment, \"id\" | \"toAddress\"> & {\n    toAddress: Address | null;\n  }) => {\n    return `${chainId}_${fromAddress}_${toAddress}`;\n  };\n\n  const factoryIdCallback = ({\n    chainId,\n    fromAddress,\n    address,\n    eventSelector,\n    childAddressLocation,\n  }: Omit<TraceFilterFragment, \"id\" | \"toAddress\"> & {\n    address: Address;\n    eventSelector: LogFactory[\"eventSelector\"];\n    childAddressLocation: LogFactory[\"childAddressLocation\"];\n  }) => {\n    return `${chainId}_${address}_${eventSelector}_${childAddressLocation}_${fromAddress}`;\n  };\n\n  if (isAddressFactory(toAddress)) {\n    for (const _fromAddress of Array.isArray(fromAddress)\n      ? fromAddress\n      : [null]) {\n      for (const _factoryAddress of Array.isArray(toAddress.address)\n        ? toAddress.address\n        : [toAddress.address]) {\n        fragments.push({\n          id: factoryIdCallback({\n            chainId,\n            fromAddress: _fromAddress,\n            address: _factoryAddress,\n            eventSelector: toAddress.eventSelector,\n            childAddressLocation: toAddress.childAddressLocation,\n          }),\n          chainId,\n          address: _factoryAddress,\n          eventSelector: toAddress.eventSelector,\n          childAddressLocation: toAddress.childAddressLocation,\n          fromAddress: _fromAddress,\n        });\n      }\n    }\n  } else {\n    for (const _fromAddress of Array.isArray(fromAddress)\n      ? fromAddress\n      : [null]) {\n      for (const _toAddress of Array.isArray(toAddress) ? toAddress : [null]) {\n        fragments.push({\n          id: idCallback({\n            chainId,\n            fromAddress: _fromAddress,\n            toAddress: _toAddress,\n          }),\n          chainId,\n          toAddress: _toAddress,\n          fromAddress: _fromAddress,\n        });\n      }\n    }\n  }\n\n  return fragments as TraceFilterFragment<factory>[];\n};\n","export type Interval = [number, number];\n\n/**\n * Return the total sum of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the sum of.\n * @returns Sum of the intervals.\n */\nexport function intervalSum(intervals: Interval[]) {\n  let totalSum = 0;\n\n  for (const [start, end] of intervals) {\n    totalSum += end - start + 1;\n  }\n\n  return totalSum;\n}\n\n/**\n * Return the union of a list of numeric intervals.\n *\n * @param intervals List of numeric intervals to find the union of.\n * @returns Union of the intervals, represented as a list of intervals.\n */\nexport function intervalUnion(intervals_: Interval[]) {\n  if (intervals_.length === 0) return [];\n\n  // Create copies to avoid mutating the originals.\n  const intervals = intervals_.map((interval) => [...interval] as Interval);\n  // Sort intervals based on the left end.\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  const result: Interval[] = [];\n  let currentInterval = intervals[0]!;\n\n  for (let i = 1; i < intervals.length; i++) {\n    const nextInterval = intervals[i]!;\n\n    if (currentInterval[1] >= nextInterval[0] - 1) {\n      // Merge overlapping intervals\n      currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);\n    } else {\n      // No overlap, add current interval to result\n      result.push(currentInterval);\n      currentInterval = nextInterval;\n    }\n  }\n\n  result.push(currentInterval); // Add the last interval\n  return result;\n}\n\n/**\n * Return the intersection of two lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersection(\n  list1: Interval[],\n  list2: Interval[],\n): Interval[] {\n  const result: Interval[] = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < list1.length && j < list2.length) {\n    const [start1, end1] = list1[i]!;\n    const [start2, end2] = list2[j]!;\n\n    const intersectionStart = Math.max(start1, start2);\n    const intersectionEnd = Math.min(end1, end2);\n\n    if (intersectionStart <= intersectionEnd) {\n      result.push([intersectionStart, intersectionEnd]);\n    }\n\n    if (end1 < end2) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  // Merge potentially overlapping intervals before returning.\n  return intervalUnion(result);\n}\n\n/**\n * Return the intersection of many lists of numeric intervals.\n *\n * @param list1 First list of numeric intervals.\n * @param list2 Second list of numeric intervals.\n * @returns Intersection of the intervals, represented as a list of intervals.\n */\nexport function intervalIntersectionMany(lists: Interval[][]): Interval[] {\n  if (lists.length === 0) return [];\n  if (lists.length === 1) return lists[0]!;\n\n  let result: Interval[] = lists[0]!;\n\n  for (let i = 1; i < lists.length; i++) {\n    result = intervalIntersection(result, lists[i]!);\n  }\n\n  return intervalUnion(result);\n}\n\n/**\n * Return the difference between two lists of numeric intervals (initial - remove).\n *\n * @param initial Starting/base list of numeric intervals.\n * @param remove List of numeric intervals to remove.\n * @returns Difference of the intervals, represented as a list of intervals.\n */\nexport function intervalDifference(\n  initial: Interval[],\n  remove: Interval[],\n): Interval[] {\n  // Create copies to avoid mutating the originals.\n  const initial_ = initial.map((interval) => [...interval] as Interval);\n  const remove_ = remove.map((interval) => [...interval] as Interval);\n\n  const result: Interval[] = [];\n\n  let i = 0;\n  let j = 0;\n\n  while (i < initial.length && j < remove.length) {\n    const interval1 = initial_[i]!;\n    const interval2 = remove_[j]!;\n\n    if (interval1[1] < interval2[0]) {\n      // No overlap, add interval1 to the result\n      result.push(interval1);\n      i++;\n    } else if (interval2[1] < interval1[0]) {\n      // No overlap, move to the next interval in remove\n      j++;\n    } else {\n      // There is an overlap\n      if (interval1[0] < interval2[0]) {\n        // Add the left part of interval1\n        result.push([interval1[0], interval2[0] - 1]);\n      }\n      if (interval1[1] > interval2[1]) {\n        // Update interval1's start to exclude the overlap\n        interval1[0] = interval2[1] + 1;\n        j++;\n      } else {\n        // No more overlap, move to the next interval in initial\n        i++;\n      }\n    }\n  }\n\n  // Add any remaining intervals from initial\n  while (i < initial_.length) {\n    result.push(initial_[i]!);\n    i++;\n  }\n\n  return result;\n}\n\nexport function sortIntervals(intervals: Interval[]) {\n  return intervals.sort((a, b) => (a[0] < b[0] ? -1 : 1));\n}\n\nexport function getChunks({\n  interval,\n  maxChunkSize,\n}: {\n  interval: Interval;\n  maxChunkSize: number;\n}) {\n  const _chunks: Interval[] = [];\n\n  const [startBlock, endBlock] = interval;\n\n  let fromBlock = startBlock;\n  let toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n\n  while (fromBlock <= endBlock) {\n    _chunks.push([fromBlock, toBlock]);\n\n    fromBlock = toBlock + 1;\n    toBlock = Math.min(fromBlock + maxChunkSize - 1, endBlock);\n  }\n\n  return _chunks;\n}\n","import type { Common } from \"@/common/common.js\";\nimport { NonRetryableError } from \"@/common/errors.js\";\nimport type { HeadlessKysely } from \"@/database/kysely.js\";\nimport type { RawEvent } from \"@/sync/events.js\";\nimport {\n  type BlockFilterFragment,\n  type LogFilterFragment,\n  type TraceFilterFragment,\n  buildBlockFilterFragment,\n  buildLogFilterFragments,\n  buildTraceFilterFragments,\n} from \"@/sync/fragments.js\";\nimport {\n  type BlockFilter,\n  type CallTraceFilter,\n  type Factory,\n  type Filter,\n  type LogFactory,\n  type LogFilter,\n  isAddressFactory,\n} from \"@/sync/source.js\";\nimport type { CallTrace, Log, TransactionReceipt } from \"@/types/eth.js\";\nimport type {\n  LightBlock,\n  SyncBlock,\n  SyncCallTrace,\n  SyncLog,\n  SyncTransaction,\n  SyncTransactionReceipt,\n} from \"@/types/sync.js\";\nimport type { NonNull } from \"@/types/utils.js\";\nimport { EVENT_TYPES, encodeCheckpoint } from \"@/utils/checkpoint.js\";\nimport {\n  type Interval,\n  intervalIntersectionMany,\n  intervalUnion,\n} from \"@/utils/interval.js\";\nimport { never } from \"@/utils/never.js\";\nimport {\n  type Insertable,\n  type Kysely,\n  type SelectQueryBuilder,\n  sql as ksql,\n} from \"kysely\";\nimport {\n  type Address,\n  type Hash,\n  type Hex,\n  checksumAddress,\n  hexToBigInt,\n  hexToNumber,\n} from \"viem\";\nimport {\n  type PonderSyncSchema,\n  encodeBlock,\n  encodeCallTrace,\n  encodeLog,\n  encodeTransaction,\n  encodeTransactionReceipt,\n} from \"./encoding.js\";\n\nexport type SyncStore = {\n  insertInterval(args: {\n    filter: Filter;\n    interval: Interval;\n  }): Promise<void>;\n  getIntervals(args: {\n    filter: Filter;\n  }): Promise<Interval[]>;\n  getChildAddresses(args: {\n    filter: Factory;\n    limit?: number;\n  }): Promise<Address[]>;\n  filterChildAddresses(args: {\n    filter: Factory;\n    addresses: Address[];\n  }): Promise<Set<Address>>;\n  insertLogs(args: {\n    logs: { log: SyncLog; block?: SyncBlock }[];\n    shouldUpdateCheckpoint: boolean;\n    chainId: number;\n  }): Promise<void>;\n  insertBlocks(args: { blocks: SyncBlock[]; chainId: number }): Promise<void>;\n  /** Return true if the block receipt is present in the database. */\n  hasBlock(args: { hash: Hash }): Promise<boolean>;\n  insertTransactions(args: {\n    transactions: SyncTransaction[];\n    chainId: number;\n  }): Promise<void>;\n  /** Return true if the transaction is present in the database. */\n  hasTransaction(args: { hash: Hash }): Promise<boolean>;\n  insertTransactionReceipts(args: {\n    transactionReceipts: SyncTransactionReceipt[];\n    chainId: number;\n  }): Promise<void>;\n  /** Return true if the transaction receipt is present in the database. */\n  hasTransactionReceipt(args: { hash: Hash }): Promise<boolean>;\n  insertCallTraces(args: {\n    callTraces: { callTrace: SyncCallTrace; block: SyncBlock }[];\n    chainId: number;\n  }): Promise<void>;\n  /** Returns an ordered list of events based on the `filters` and pagination arguments. */\n  getEvents(args: {\n    filters: Filter[];\n    from: string;\n    to: string;\n    limit: number;\n  }): Promise<{ events: RawEvent[]; cursor: string }>;\n  insertRpcRequestResult(args: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n    result: string;\n  }): Promise<void>;\n  getRpcRequestResult(args: {\n    request: string;\n    blockNumber: bigint;\n    chainId: number;\n  }): Promise<string | null>;\n  pruneRpcRequestResult(args: {\n    blocks: Pick<LightBlock, \"number\">[];\n    chainId: number;\n  }): Promise<void>;\n  pruneByChain(args: {\n    fromBlock: number;\n    chainId: number;\n  }): Promise<void>;\n};\n\nconst logFactorySQL = (\n  qb: SelectQueryBuilder<PonderSyncSchema, \"logs\", {}>,\n  factory: LogFactory,\n) =>\n  qb\n    .select(\n      (() => {\n        if (factory.childAddressLocation.startsWith(\"offset\")) {\n          const childAddressOffset = Number(\n            factory.childAddressLocation.substring(6),\n          );\n          const start = 2 + 12 * 2 + childAddressOffset * 2 + 1;\n          const length = 20 * 2;\n          return ksql<Hex>`'0x' || substring(data from ${start}::int for ${length}::int)`;\n        } else {\n          const start = 2 + 12 * 2 + 1;\n          const length = 20 * 2;\n          return ksql<Hex>`'0x' || substring(${ksql.ref(\n            factory.childAddressLocation,\n          )} from ${start}::integer for ${length}::integer)`;\n        }\n      })().as(\"childAddress\"),\n    )\n    .$call((qb) => {\n      if (Array.isArray(factory.address)) {\n        return qb.where(\"address\", \"in\", factory.address);\n      }\n      return qb.where(\"address\", \"=\", factory.address);\n    })\n    .where(\"topic0\", \"=\", factory.eventSelector)\n    .where(\"chainId\", \"=\", factory.chainId);\n\nexport const createSyncStore = ({\n  common,\n  db,\n}: {\n  common: Common;\n  db: HeadlessKysely<PonderSyncSchema>;\n}): SyncStore => ({\n  insertInterval: async ({ filter, interval }) =>\n    db.wrap({ method: \"insertInterval\" }, async () => {\n      const startBlock = BigInt(interval[0]);\n      const endBlock = BigInt(interval[1]);\n\n      switch (filter.type) {\n        case \"log\": {\n          for (const fragment of buildLogFilterFragments(filter)) {\n            if (isAddressFactory(filter.address)) {\n              await db\n                .insertInto(\"factoryLogFilterIntervals\")\n                .values({\n                  factoryId: fragment.id,\n                  startBlock,\n                  endBlock,\n                })\n                .execute();\n            } else {\n              await db\n                .insertInto(\"logFilterIntervals\")\n                .values({\n                  logFilterId: fragment.id,\n                  startBlock,\n                  endBlock,\n                })\n                .execute();\n            }\n          }\n          break;\n        }\n\n        case \"block\": {\n          const fragment = buildBlockFilterFragment(filter);\n          await db\n            .insertInto(\"blockFilterIntervals\")\n            .values({\n              blockFilterId: fragment.id,\n              startBlock,\n              endBlock,\n            })\n            .execute();\n          break;\n        }\n\n        case \"callTrace\": {\n          for (const fragment of buildTraceFilterFragments(filter)) {\n            if (isAddressFactory(filter.toAddress)) {\n              await db\n                .insertInto(\"factoryTraceFilterIntervals\")\n                .values({\n                  factoryId: fragment.id,\n                  startBlock,\n                  endBlock,\n                })\n                .execute();\n            } else {\n              await db\n                .insertInto(\"traceFilterIntervals\")\n                .values({\n                  traceFilterId: fragment.id,\n                  startBlock,\n                  endBlock,\n                })\n                .execute();\n            }\n          }\n          break;\n        }\n\n        default:\n          never(filter);\n      }\n    }),\n  getIntervals: async ({ filter }) =>\n    db.wrap({ method: \"getIntervals\" }, async () => {\n      const topicSQL = (\n        qb: SelectQueryBuilder<\n          PonderSyncSchema,\n          | \"logFilters\"\n          | \"logFilterIntervals\"\n          | \"factoryLogFilters\"\n          | \"factoryLogFilterIntervals\",\n          {}\n        >,\n        fragment: LogFilterFragment,\n      ) =>\n        qb\n          .where((eb) =>\n            eb.or([\n              eb(\"topic0\", \"is\", null),\n              eb(\"topic0\", \"=\", fragment.topic0),\n            ]),\n          )\n          .where((eb) =>\n            eb.or([\n              eb(\"topic1\", \"is\", null),\n              eb(\"topic1\", \"=\", fragment.topic1),\n            ]),\n          )\n          .where((eb) =>\n            eb.or([\n              eb(\"topic2\", \"is\", null),\n              eb(\"topic2\", \"=\", fragment.topic2),\n            ]),\n          )\n          .where((eb) =>\n            eb.or([\n              eb(\"topic3\", \"is\", null),\n              eb(\"topic3\", \"=\", fragment.topic3),\n            ]),\n          );\n\n      let fragments:\n        | LogFilterFragment[]\n        | TraceFilterFragment[]\n        | BlockFilterFragment[];\n      let table:\n        | \"logFilter\"\n        | \"factoryLogFilter\"\n        | \"traceFilter\"\n        | \"factoryTraceFilter\"\n        | \"blockFilter\";\n      let idCol:\n        | \"logFilterId\"\n        | \"traceFilterId\"\n        | \"blockFilterId\"\n        | \"factoryId\";\n      let fragmentSelect: (\n        fragment: any,\n        qb: SelectQueryBuilder<PonderSyncSchema, keyof PonderSyncSchema, {}>,\n      ) => SelectQueryBuilder<PonderSyncSchema, keyof PonderSyncSchema, {}>;\n\n      switch (filter.type) {\n        case \"log\":\n          {\n            if (isAddressFactory(filter.address)) {\n              fragments = buildLogFilterFragments(filter);\n              table = \"factoryLogFilter\";\n              idCol = \"factoryId\";\n              // @ts-ignore\n              fragmentSelect = (fragment: LogFilterFragment<LogFactory>, qb) =>\n                qb\n                  .where(\"address\", \"=\", fragment.address)\n                  .where(\"eventSelector\", \"=\", fragment.eventSelector)\n                  .where(\n                    \"childAddressLocation\",\n                    \"=\",\n                    fragment.childAddressLocation,\n                  )\n                  .where(\n                    \"includeTransactionReceipts\",\n                    \">=\",\n                    fragment.includeTransactionReceipts,\n                  )\n                  .$call((qb) => topicSQL(qb, fragment));\n            } else {\n              fragments = buildLogFilterFragments(filter);\n              table = \"logFilter\";\n              idCol = \"logFilterId\";\n              // @ts-ignore\n              fragmentSelect = (fragment: LogFilterFragment<undefined>, qb) =>\n                qb\n                  .where((eb) =>\n                    eb.or([\n                      eb(\"address\", \"is\", null),\n                      eb(\"address\", \"=\", fragment.address),\n                    ]),\n                  )\n                  .where(\n                    \"includeTransactionReceipts\",\n                    \">=\",\n                    fragment.includeTransactionReceipts,\n                  )\n                  .$call((qb) => topicSQL(qb, fragment));\n            }\n          }\n          break;\n\n        case \"block\":\n          {\n            fragments = [buildBlockFilterFragment(filter)];\n            table = \"blockFilter\";\n            idCol = \"blockFilterId\";\n            fragmentSelect = (fragment, qb) =>\n              qb.where(\"blockFilterId\", \"=\", fragment.id);\n          }\n          break;\n\n        case \"callTrace\":\n          {\n            if (isAddressFactory(filter.toAddress)) {\n              fragments = buildTraceFilterFragments(filter);\n              table = \"factoryTraceFilter\";\n              idCol = \"factoryId\";\n              fragmentSelect = (fragment: TraceFilterFragment<Factory>, qb) =>\n                qb\n                  .where(\"address\", \"=\", fragment.address)\n                  .where(\"eventSelector\", \"=\", fragment.eventSelector)\n                  .where(\n                    \"childAddressLocation\",\n                    \"=\",\n                    fragment.childAddressLocation,\n                  )\n                  .where((eb) =>\n                    eb.or([\n                      eb(\"fromAddress\", \"is\", null),\n                      eb(\"fromAddress\", \"=\", fragment.fromAddress),\n                    ]),\n                  );\n            } else {\n              fragments = buildTraceFilterFragments(filter);\n              table = \"traceFilter\";\n              idCol = \"traceFilterId\";\n              fragmentSelect = (fragment: TraceFilterFragment<undefined>, qb) =>\n                qb\n                  .where((eb) =>\n                    eb.or([\n                      eb(\"fromAddress\", \"is\", null),\n                      eb(\"fromAddress\", \"=\", fragment.fromAddress),\n                    ]),\n                  )\n                  .where((eb) =>\n                    eb.or([\n                      eb(\"toAddress\", \"is\", null),\n                      eb(\"toAddress\", \"=\", fragment.toAddress),\n                    ]),\n                  );\n            }\n          }\n          break;\n\n        default:\n          never(filter);\n      }\n\n      // First, attempt to merge overlapping and adjacent intervals.\n      for (const fragment of fragments!) {\n        await db\n          .insertInto(`${table!}s`)\n          .values(fragment)\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n\n        let mergeComplete = false;\n        while (mergeComplete === false) {\n          await db.transaction().execute(async (tx) => {\n            // This is a trick to add a LIMIT to a DELETE statement\n            const existingIntervals = await tx\n              .deleteFrom(`${table}Intervals`)\n              .where(\n                \"id\",\n                \"in\",\n                tx\n                  .selectFrom(`${table}Intervals`)\n                  .where(idCol, \"=\", fragment.id)\n                  .select(\"id\")\n                  .orderBy(\"startBlock asc\")\n                  .limit(common.options.syncStoreMaxIntervals),\n              )\n              .returning([\"startBlock\", \"endBlock\"])\n              .execute();\n\n            const mergedIntervals = intervalUnion(\n              existingIntervals.map((i) => [\n                Number(i.startBlock),\n                Number(i.endBlock),\n              ]),\n            );\n\n            const mergedIntervalRows = mergedIntervals.map(\n              ([startBlock, endBlock]) => ({\n                [idCol as string]: fragment.id,\n                startBlock: BigInt(startBlock),\n                endBlock: BigInt(endBlock),\n              }),\n            );\n\n            if (mergedIntervalRows.length > 0) {\n              await tx\n                .insertInto(`${table}Intervals`)\n                .values(mergedIntervalRows)\n                .execute();\n            }\n\n            if (\n              mergedIntervalRows.length === common.options.syncStoreMaxIntervals\n            ) {\n              // This occurs when there are too many non-mergeable ranges with the same logFilterId. Should be almost impossible.\n              throw new NonRetryableError(\n                `'${table}Intervals' table for chain '${fragment.chainId}' has reached an unrecoverable level of fragmentation.`,\n              );\n            }\n\n            if (\n              existingIntervals.length !== common.options.syncStoreMaxIntervals\n            ) {\n              mergeComplete = true;\n            }\n          });\n        }\n      }\n\n      const intervals: Interval[][] = [];\n      for (const fragment of fragments!) {\n        const _intervals = await db\n          .selectFrom(`${table!}Intervals`)\n          .innerJoin(`${table!}s`, idCol!, `${table!}s.id`)\n          .$call((qb) => fragmentSelect(fragment, qb as any))\n          .where(\"chainId\", \"=\", fragment.chainId)\n          .select([\"startBlock\", \"endBlock\"])\n          .execute();\n\n        const union = intervalUnion(\n          _intervals.map(({ startBlock, endBlock }) => [\n            Number(startBlock),\n            Number(endBlock),\n          ]),\n        );\n\n        intervals.push(union);\n      }\n\n      return intervalIntersectionMany(intervals);\n    }),\n  getChildAddresses: ({ filter, limit }) =>\n    db.wrap({ method: \"getChildAddresses\" }, async () => {\n      return await db\n        .selectFrom(\"logs\")\n        .$call((qb) => logFactorySQL(qb, filter))\n        .orderBy(\"id asc\")\n        .$if(limit !== undefined, (qb) => qb.limit(limit!))\n        .execute()\n        .then((addresses) => addresses.map(({ childAddress }) => childAddress));\n    }),\n  filterChildAddresses: ({ filter, addresses }) =>\n    db.wrap({ method: \"filterChildAddresses\" }, async () => {\n      const result = await db\n        .with(\n          \"addresses(address)\",\n          () =>\n            ksql`( values ${ksql.join(addresses.map((a) => ksql`( ${ksql.val(a)} )`))} )`,\n        )\n        .with(\"childAddresses\", (db) =>\n          db.selectFrom(\"logs\").$call((qb) => logFactorySQL(qb, filter)),\n        )\n        .selectFrom(\"addresses\")\n        .where(\n          \"addresses.address\",\n          \"in\",\n          ksql`(SELECT \"childAddress\" FROM \"childAddresses\")`,\n        )\n        .selectAll()\n        .execute();\n\n      return new Set<Address>([...result.map(({ address }) => address)]);\n    }),\n  insertLogs: async ({ logs, shouldUpdateCheckpoint, chainId }) => {\n    if (logs.length === 0) return;\n    await db.wrap({ method: \"insertLogs\" }, async () => {\n      // Calculate `batchSize` based on how many parameters the\n      // input will have\n      const batchSize = Math.floor(\n        common.options.databaseMaxQueryParameters /\n          Object.keys(encodeLog({ log: logs[0]!.log, chainId })).length,\n      );\n\n      /**\n       * As an optimization, logs that are matched by a factory do\n       * not contain a checkpoint, because not corresponding block is\n       * fetched (no block.timestamp). However, when a log is matched by\n       * both a log filter and a factory, the checkpoint must be included\n       * in the db.\n       */\n\n      for (let i = 0; i < logs.length; i += batchSize) {\n        await db\n          .insertInto(\"logs\")\n          .values(\n            logs\n              .slice(i, i + batchSize)\n              .map(({ log, block }) => encodeLog({ log, block, chainId })),\n          )\n          .onConflict((oc) =>\n            oc.column(\"id\").$call((qb) =>\n              shouldUpdateCheckpoint\n                ? qb.doUpdateSet((eb) => ({\n                    checkpoint: eb.ref(\"excluded.checkpoint\"),\n                  }))\n                : qb.doNothing(),\n            ),\n          )\n          .execute();\n      }\n    });\n  },\n  insertBlocks: async ({ blocks, chainId }) => {\n    if (blocks.length === 0) return;\n    await db.wrap({ method: \"insertBlocks\" }, async () => {\n      // Calculate `batchSize` based on how many parameters the\n      // input will have\n      const batchSize = Math.floor(\n        common.options.databaseMaxQueryParameters /\n          Object.keys(encodeBlock({ block: blocks[0]!, chainId })).length,\n      );\n\n      for (let i = 0; i < blocks.length; i += batchSize) {\n        await db\n          .insertInto(\"blocks\")\n          .values(\n            blocks\n              .slice(i, i + batchSize)\n              .map((block) => encodeBlock({ block, chainId })),\n          )\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n    });\n  },\n  hasBlock: async ({ hash }) =>\n    db.wrap({ method: \"hasBlock\" }, async () => {\n      return await db\n        .selectFrom(\"blocks\")\n        .select(\"hash\")\n        .where(\"hash\", \"=\", hash)\n        .executeTakeFirst()\n        .then((result) => result !== undefined);\n    }),\n  insertTransactions: async ({ transactions, chainId }) => {\n    if (transactions.length === 0) return;\n    await db.wrap({ method: \"insertTransactions\" }, async () => {\n      // Calculate `batchSize` based on how many parameters the\n      // input will have\n      const batchSize = Math.floor(\n        common.options.databaseMaxQueryParameters /\n          Object.keys(\n            encodeTransaction({\n              transaction: transactions[0]!,\n              chainId,\n            }),\n          ).length,\n      );\n\n      for (let i = 0; i < transactions.length; i += batchSize) {\n        await db\n          .insertInto(\"transactions\")\n          .values(\n            transactions\n              .slice(i, i + batchSize)\n              .map((transaction) =>\n                encodeTransaction({ transaction, chainId }),\n              ),\n          )\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n    });\n  },\n  hasTransaction: async ({ hash }) =>\n    db.wrap({ method: \"hasTransaction\" }, async () => {\n      return await db\n        .selectFrom(\"transactions\")\n        .select(\"hash\")\n        .where(\"hash\", \"=\", hash)\n        .executeTakeFirst()\n        .then((result) => result !== undefined);\n    }),\n  insertTransactionReceipts: async ({ transactionReceipts, chainId }) => {\n    if (transactionReceipts.length === 0) return;\n    await db.wrap({ method: \"insertTransactionReceipts\" }, async () => {\n      // Calculate `batchSize` based on how many parameters the\n      // input will have\n      const batchSize = Math.floor(\n        common.options.databaseMaxQueryParameters /\n          Object.keys(\n            encodeTransactionReceipt({\n              transactionReceipt: transactionReceipts[0]!,\n              chainId,\n            }),\n          ).length,\n      );\n\n      for (let i = 0; i < transactionReceipts.length; i += batchSize) {\n        await db\n          .insertInto(\"transactionReceipts\")\n          .values(\n            transactionReceipts\n              .slice(i, i + batchSize)\n              .map((transactionReceipt) =>\n                encodeTransactionReceipt({\n                  transactionReceipt,\n                  chainId,\n                }),\n              ),\n          )\n          .onConflict((oc) => oc.column(\"transactionHash\").doNothing())\n          .execute();\n      }\n    });\n  },\n  hasTransactionReceipt: async ({ hash }) =>\n    db.wrap({ method: \"hasTransactionReceipt\" }, async () => {\n      return await db\n        .selectFrom(\"transactionReceipts\")\n        .select(\"transactionHash\")\n        .where(\"transactionHash\", \"=\", hash)\n        .executeTakeFirst()\n        .then((result) => result !== undefined);\n    }),\n  insertCallTraces: async ({ callTraces, chainId }) => {\n    if (callTraces.length === 0) return;\n    await db.wrap({ method: \"insertCallTrace\" }, async () => {\n      // Delete existing traces with the same `transactionHash`. Then, calculate \"callTraces.checkpoint\"\n      // based on the ordering of \"callTraces.traceAddress\" and add all traces to \"callTraces\" table.\n      const traceByTransactionHash: {\n        [transactionHash: Hex]: { traces: SyncCallTrace[]; block: SyncBlock };\n      } = {};\n\n      for (const { callTrace, block } of callTraces) {\n        if (traceByTransactionHash[callTrace.transactionHash] === undefined) {\n          traceByTransactionHash[callTrace.transactionHash] = {\n            traces: [],\n            block,\n          };\n        }\n        traceByTransactionHash[callTrace.transactionHash]!.traces.push(\n          callTrace,\n        );\n      }\n\n      const values: Insertable<PonderSyncSchema[\"callTraces\"]>[] = [];\n\n      await db.transaction().execute(async (tx) => {\n        for (const transactionHash of Object.keys(traceByTransactionHash)) {\n          const block = traceByTransactionHash[transactionHash as Hex]!.block;\n          const traces = await tx\n            .deleteFrom(\"callTraces\")\n            .returningAll()\n            .where(\"transactionHash\", \"=\", transactionHash as Hex)\n            .where(\"chainId\", \"=\", chainId)\n            .execute();\n\n          traces.push(\n            // @ts-ignore\n            ...traceByTransactionHash[transactionHash as Hex]!.traces.map(\n              (trace) => encodeCallTrace({ trace, chainId }),\n            ),\n          );\n\n          // Use lexographical sort of stringified `traceAddress`.\n          traces.sort((a, b) => {\n            return a.traceAddress < b.traceAddress ? -1 : 1;\n          });\n\n          for (let i = 0; i < traces.length; i++) {\n            const trace = traces[i]!;\n\n            const checkpoint = encodeCheckpoint({\n              blockTimestamp: hexToNumber(block.timestamp),\n              chainId: BigInt(chainId),\n              blockNumber: hexToBigInt(block.number),\n              transactionIndex: BigInt(trace.transactionPosition),\n              eventType: EVENT_TYPES.callTraces,\n              eventIndex: BigInt(i),\n            });\n            trace.checkpoint = checkpoint;\n            values.push(trace);\n          }\n        }\n\n        // Calculate `batchSize` based on how many parameters the\n        // input will have\n        const batchSize = Math.floor(\n          common.options.databaseMaxQueryParameters /\n            Object.keys(values[0]!).length,\n        );\n\n        for (let i = 0; i < values.length; i += batchSize) {\n          await tx\n            .insertInto(\"callTraces\")\n            .values(values.slice(i, i + batchSize))\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute();\n        }\n      });\n    });\n  },\n  getEvents: async ({ filters, from, to, limit }) => {\n    const addressSQL = (\n      qb: SelectQueryBuilder<\n        PonderSyncSchema,\n        \"logs\" | \"blocks\" | \"callTraces\",\n        {}\n      >,\n      address: LogFilter[\"address\"],\n      column: \"address\" | \"from\" | \"to\",\n    ) => {\n      if (typeof address === \"string\") return qb.where(column, \"=\", address);\n      if (isAddressFactory(address)) {\n        return qb.where(\n          column,\n          \"in\",\n          db.selectFrom(\"logs\").$call((qb) => logFactorySQL(qb, address)),\n        );\n      }\n      if (Array.isArray(address)) return qb.where(column, \"in\", address);\n\n      return qb;\n    };\n\n    const logSQL = (\n      filter: LogFilter,\n      db: Kysely<PonderSyncSchema>,\n      index: number,\n    ) =>\n      db\n        .selectFrom(\"logs\")\n        .select([\n          ksql.raw(`'${index}'`).as(\"filterIndex\"),\n          \"checkpoint\",\n          \"chainId\",\n          \"blockHash\",\n          \"transactionHash\",\n          \"id as logId\",\n          ksql`null`.as(\"callTraceId\"),\n        ])\n        .where(\"chainId\", \"=\", filter.chainId)\n        .$if(filter.topics !== undefined, (qb) => {\n          for (const idx_ of [0, 1, 2, 3]) {\n            const idx = idx_ as 0 | 1 | 2 | 3;\n            // If it's an array of length 1, collapse it.\n            const raw = filter.topics![idx] ?? null;\n            if (raw === null) continue;\n            const topic =\n              Array.isArray(raw) && raw.length === 1 ? raw[0]! : raw;\n            if (Array.isArray(topic)) {\n              qb = qb.where((eb) =>\n                eb.or(topic.map((t) => eb(`logs.topic${idx}`, \"=\", t))),\n              );\n            } else {\n              qb = qb.where(`logs.topic${idx}`, \"=\", topic);\n            }\n          }\n          return qb;\n        })\n        .$call((qb) => addressSQL(qb as any, filter.address, \"address\"))\n        .where(\"blockNumber\", \">=\", filter.fromBlock.toString())\n        .$if(filter.toBlock !== undefined, (qb) =>\n          qb.where(\"blockNumber\", \"<=\", filter.toBlock!.toString()),\n        );\n\n    const callTraceSQL = (\n      filter: CallTraceFilter,\n      db: Kysely<PonderSyncSchema>,\n      index: number,\n    ) =>\n      db\n        .selectFrom(\"callTraces\")\n        .select([\n          ksql.raw(`'${index}'`).as(\"filterIndex\"),\n          \"checkpoint\",\n          \"chainId\",\n          \"blockHash\",\n          \"transactionHash\",\n          ksql`null`.as(\"logId\"),\n          \"id as callTraceId\",\n        ])\n        .where(\"chainId\", \"=\", filter.chainId)\n        .where((eb) =>\n          eb.or(\n            filter.functionSelectors.map((fs) =>\n              eb(\"callTraces.functionSelector\", \"=\", fs),\n            ),\n          ),\n        )\n        .where(ksql`${ksql.ref(\"callTraces.error\")} IS NULL`)\n        .$call((qb) => addressSQL(qb as any, filter.fromAddress, \"from\"))\n        .$call((qb) => addressSQL(qb, filter.toAddress, \"to\"))\n        .where(\"blockNumber\", \">=\", filter.fromBlock.toString())\n        .$if(filter.toBlock !== undefined, (qb) =>\n          qb.where(\"blockNumber\", \"<=\", filter.toBlock!.toString()),\n        );\n\n    const blockSQL = (\n      filter: BlockFilter,\n      db: Kysely<PonderSyncSchema>,\n      index: number,\n    ) =>\n      db\n        .selectFrom(\"blocks\")\n        .select([\n          ksql.raw(`'${index}'`).as(\"filterIndex\"),\n          \"checkpoint\",\n          \"chainId\",\n          \"hash as blockHash\",\n          ksql`null`.as(\"transactionHash\"),\n          ksql`null`.as(\"logId\"),\n          ksql`null`.as(\"callTraceId\"),\n        ])\n        .where(\"chainId\", \"=\", filter.chainId)\n        .$if(filter !== undefined && filter.interval !== undefined, (qb) =>\n          qb.where(ksql`(number - ${filter.offset}) % ${filter.interval} = 0`),\n        )\n        .where(\"number\", \">=\", filter.fromBlock.toString())\n        .$if(filter.toBlock !== undefined, (qb) =>\n          qb.where(\"number\", \"<=\", filter.toBlock!.toString()),\n        );\n\n    const rows = await db.wrap(\n      {\n        method: \"getEvents\",\n        shouldRetry(error) {\n          return error.message.includes(\"statement timeout\") === false;\n        },\n      },\n      async () => {\n        let query:\n          | SelectQueryBuilder<\n              PonderSyncSchema,\n              \"logs\" | \"callTraces\" | \"blocks\",\n              {\n                filterIndex: number;\n                checkpoint: string;\n                chainId: number;\n                blockHash: string;\n                transactionHash: string;\n                logId: string;\n                callTraceId: string;\n              }\n            >\n          | undefined;\n\n        for (let i = 0; i < filters.length; i++) {\n          const filter = filters[i]!;\n\n          const _query =\n            filter.type === \"log\"\n              ? logSQL(filter, db, i)\n              : filter.type === \"callTrace\"\n                ? callTraceSQL(filter, db, i)\n                : blockSQL(filter, db, i);\n\n          // @ts-ignore\n          query = query === undefined ? _query : query.unionAll(_query);\n        }\n\n        return await db\n          .with(\"event\", () => query!)\n          .selectFrom(\"event\")\n          .select([\n            \"event.filterIndex as event_filterIndex\",\n            \"event.checkpoint as event_checkpoint\",\n          ])\n          .innerJoin(\"blocks\", \"blocks.hash\", \"event.blockHash\")\n          .select([\n            \"blocks.baseFeePerGas as block_baseFeePerGas\",\n            \"blocks.difficulty as block_difficulty\",\n            \"blocks.extraData as block_extraData\",\n            \"blocks.gasLimit as block_gasLimit\",\n            \"blocks.gasUsed as block_gasUsed\",\n            \"blocks.hash as block_hash\",\n            \"blocks.logsBloom as block_logsBloom\",\n            \"blocks.miner as block_miner\",\n            \"blocks.mixHash as block_mixHash\",\n            \"blocks.nonce as block_nonce\",\n            \"blocks.number as block_number\",\n            \"blocks.parentHash as block_parentHash\",\n            \"blocks.receiptsRoot as block_receiptsRoot\",\n            \"blocks.sha3Uncles as block_sha3Uncles\",\n            \"blocks.size as block_size\",\n            \"blocks.stateRoot as block_stateRoot\",\n            \"blocks.timestamp as block_timestamp\",\n            \"blocks.totalDifficulty as block_totalDifficulty\",\n            \"blocks.transactionsRoot as block_transactionsRoot\",\n          ])\n          .leftJoin(\"logs\", \"logs.id\", \"event.logId\")\n          .select([\n            \"logs.address as log_address\",\n            \"logs.blockHash as log_blockHash\",\n            \"logs.blockNumber as log_blockNumber\",\n            \"logs.chainId as log_chainId\",\n            \"logs.data as log_data\",\n            \"logs.id as log_id\",\n            \"logs.logIndex as log_logIndex\",\n            \"logs.topic0 as log_topic0\",\n            \"logs.topic1 as log_topic1\",\n            \"logs.topic2 as log_topic2\",\n            \"logs.topic3 as log_topic3\",\n            \"logs.transactionHash as log_transactionHash\",\n            \"logs.transactionIndex as log_transactionIndex\",\n          ])\n          .leftJoin(\n            \"transactions\",\n            \"transactions.hash\",\n            \"event.transactionHash\",\n          )\n          .select([\n            \"transactions.accessList as tx_accessList\",\n            \"transactions.blockHash as tx_blockHash\",\n            \"transactions.blockNumber as tx_blockNumber\",\n            \"transactions.from as tx_from\",\n            \"transactions.gas as tx_gas\",\n            \"transactions.gasPrice as tx_gasPrice\",\n            \"transactions.hash as tx_hash\",\n            \"transactions.input as tx_input\",\n            \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n            \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n            \"transactions.nonce as tx_nonce\",\n            \"transactions.r as tx_r\",\n            \"transactions.s as tx_s\",\n            \"transactions.to as tx_to\",\n            \"transactions.transactionIndex as tx_transactionIndex\",\n            \"transactions.type as tx_type\",\n            \"transactions.value as tx_value\",\n            \"transactions.v as tx_v\",\n          ])\n          .leftJoin(\"callTraces\", \"callTraces.id\", \"event.callTraceId\")\n          .select([\n            \"callTraces.id as callTrace_id\",\n            \"callTraces.callType as callTrace_callType\",\n            \"callTraces.from as callTrace_from\",\n            \"callTraces.gas as callTrace_gas\",\n            \"callTraces.input as callTrace_input\",\n            \"callTraces.to as callTrace_to\",\n            \"callTraces.value as callTrace_value\",\n            \"callTraces.blockHash as callTrace_blockHash\",\n            \"callTraces.blockNumber as callTrace_blockNumber\",\n            \"callTraces.gasUsed as callTrace_gasUsed\",\n            \"callTraces.output as callTrace_output\",\n            \"callTraces.subtraces as callTrace_subtraces\",\n            \"callTraces.traceAddress as callTrace_traceAddress\",\n            \"callTraces.transactionHash as callTrace_transactionHash\",\n            \"callTraces.transactionPosition as callTrace_transactionPosition\",\n          ])\n          .leftJoin(\n            \"transactionReceipts\",\n            \"transactionReceipts.transactionHash\",\n            \"event.transactionHash\",\n          )\n          .select([\n            \"transactionReceipts.blockHash as txr_blockHash\",\n            \"transactionReceipts.blockNumber as txr_blockNumber\",\n            \"transactionReceipts.contractAddress as txr_contractAddress\",\n            \"transactionReceipts.cumulativeGasUsed as txr_cumulativeGasUsed\",\n            \"transactionReceipts.effectiveGasPrice as txr_effectiveGasPrice\",\n            \"transactionReceipts.from as txr_from\",\n            \"transactionReceipts.gasUsed as txr_gasUsed\",\n            \"transactionReceipts.logs as txr_logs\",\n            \"transactionReceipts.logsBloom as txr_logsBloom\",\n            \"transactionReceipts.status as txr_status\",\n            \"transactionReceipts.to as txr_to\",\n            \"transactionReceipts.transactionHash as txr_transactionHash\",\n            \"transactionReceipts.transactionIndex as txr_transactionIndex\",\n            \"transactionReceipts.type as txr_type\",\n          ])\n          .where(\"event.checkpoint\", \">\", from)\n          .where(\"event.checkpoint\", \"<=\", to)\n          .orderBy(\"event.checkpoint\", \"asc\")\n          .orderBy(\"event.filterIndex\", \"asc\")\n          .limit(limit)\n          .execute();\n      },\n    );\n\n    const events = rows.map((_row) => {\n      // Without this cast, the block_ and tx_ fields are all nullable\n      // which makes this very annoying. Should probably add a runtime check\n      // that those fields are indeed present before continuing here.\n      const row = _row as NonNull<(typeof rows)[number]>;\n\n      const filter = filters[row.event_filterIndex]!;\n\n      const hasLog = row.log_id !== null;\n      const hasTransaction = row.tx_hash !== null;\n      const hasCallTrace = row.callTrace_id !== null;\n      const hasTransactionReceipt =\n        (filter.type === \"log\" || filter.type === \"callTrace\") &&\n        filter.includeTransactionReceipts;\n\n      return {\n        chainId: filter.chainId,\n        sourceIndex: Number(row.event_filterIndex),\n        checkpoint: row.event_checkpoint,\n        block: {\n          baseFeePerGas:\n            row.block_baseFeePerGas !== null\n              ? BigInt(row.block_baseFeePerGas)\n              : null,\n          difficulty: BigInt(row.block_difficulty),\n          extraData: row.block_extraData,\n          gasLimit: BigInt(row.block_gasLimit),\n          gasUsed: BigInt(row.block_gasUsed),\n          hash: row.block_hash,\n          logsBloom: row.block_logsBloom,\n          miner: checksumAddress(row.block_miner),\n          mixHash: row.block_mixHash,\n          nonce: row.block_nonce,\n          number: BigInt(row.block_number),\n          parentHash: row.block_parentHash,\n          receiptsRoot: row.block_receiptsRoot,\n          sha3Uncles: row.block_sha3Uncles,\n          size: BigInt(row.block_size),\n          stateRoot: row.block_stateRoot,\n          timestamp: BigInt(row.block_timestamp),\n          totalDifficulty:\n            row.block_totalDifficulty !== null\n              ? BigInt(row.block_totalDifficulty)\n              : null,\n          transactionsRoot: row.block_transactionsRoot,\n        },\n        log: hasLog\n          ? {\n              address: checksumAddress(row.log_address!),\n              blockHash: row.log_blockHash,\n              blockNumber: BigInt(row.log_blockNumber),\n              data: row.log_data,\n              id: row.log_id as Log[\"id\"],\n              logIndex: Number(row.log_logIndex),\n              removed: false,\n              topics: [\n                row.log_topic0,\n                row.log_topic1,\n                row.log_topic2,\n                row.log_topic3,\n              ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n              transactionHash: row.log_transactionHash,\n              transactionIndex: Number(row.log_transactionIndex),\n            }\n          : undefined,\n        transaction: hasTransaction\n          ? {\n              blockHash: row.tx_blockHash,\n              blockNumber: BigInt(row.tx_blockNumber),\n              from: checksumAddress(row.tx_from),\n              gas: BigInt(row.tx_gas),\n              hash: row.tx_hash,\n              input: row.tx_input,\n              nonce: Number(row.tx_nonce),\n              r: row.tx_r,\n              s: row.tx_s,\n              to: row.tx_to ? checksumAddress(row.tx_to) : row.tx_to,\n              transactionIndex: Number(row.tx_transactionIndex),\n              value: BigInt(row.tx_value),\n              v: row.tx_v !== null ? BigInt(row.tx_v) : null,\n              ...(row.tx_type === \"0x0\"\n                ? {\n                    type: \"legacy\",\n                    gasPrice: BigInt(row.tx_gasPrice),\n                  }\n                : row.tx_type === \"0x1\"\n                  ? {\n                      type: \"eip2930\",\n                      gasPrice: BigInt(row.tx_gasPrice),\n                      accessList: JSON.parse(row.tx_accessList),\n                    }\n                  : row.tx_type === \"0x2\"\n                    ? {\n                        type: \"eip1559\",\n                        maxFeePerGas: BigInt(row.tx_maxFeePerGas),\n                        maxPriorityFeePerGas: BigInt(\n                          row.tx_maxPriorityFeePerGas,\n                        ),\n                      }\n                    : row.tx_type === \"0x7e\"\n                      ? {\n                          type: \"deposit\",\n                          maxFeePerGas:\n                            row.tx_maxFeePerGas !== null\n                              ? BigInt(row.tx_maxFeePerGas)\n                              : undefined,\n                          maxPriorityFeePerGas:\n                            row.tx_maxPriorityFeePerGas !== null\n                              ? BigInt(row.tx_maxPriorityFeePerGas)\n                              : undefined,\n                        }\n                      : {\n                          type: row.tx_type,\n                        }),\n            }\n          : undefined,\n        trace: hasCallTrace\n          ? {\n              id: row.callTrace_id,\n              from: checksumAddress(row.callTrace_from),\n              to: checksumAddress(row.callTrace_to),\n              gas: BigInt(row.callTrace_gas),\n              value: BigInt(row.callTrace_value),\n              input: row.callTrace_input,\n              output: row.callTrace_output,\n              gasUsed: BigInt(row.callTrace_gasUsed),\n              subtraces: row.callTrace_subtraces,\n              traceAddress: JSON.parse(row.callTrace_traceAddress),\n              blockHash: row.callTrace_blockHash,\n              blockNumber: BigInt(row.callTrace_blockNumber),\n              transactionHash: row.callTrace_transactionHash,\n              transactionIndex: row.callTrace_transactionPosition,\n              callType: row.callTrace_callType as CallTrace[\"callType\"],\n            }\n          : undefined,\n        transactionReceipt: hasTransactionReceipt\n          ? {\n              blockHash: row.txr_blockHash,\n              blockNumber: BigInt(row.txr_blockNumber),\n              contractAddress: row.txr_contractAddress\n                ? checksumAddress(row.txr_contractAddress)\n                : null,\n              cumulativeGasUsed: BigInt(row.txr_cumulativeGasUsed),\n              effectiveGasPrice: BigInt(row.txr_effectiveGasPrice),\n              from: checksumAddress(row.txr_from),\n              gasUsed: BigInt(row.txr_gasUsed),\n              logs: JSON.parse(row.txr_logs).map((log: SyncLog) => ({\n                id: `${log.blockHash}-${log.logIndex}`,\n                address: checksumAddress(log.address),\n                blockHash: log.blockHash,\n                blockNumber: hexToBigInt(log.blockNumber),\n                data: log.data,\n                logIndex: hexToNumber(log.logIndex),\n                removed: false,\n                topics: [\n                  log.topics[0] ?? null,\n                  log.topics[1] ?? null,\n                  log.topics[2] ?? null,\n                  log.topics[3] ?? null,\n                ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n                transactionHash: log.transactionHash,\n                transactionIndex: hexToNumber(log.transactionIndex),\n              })),\n              logsBloom: row.txr_logsBloom,\n              status:\n                row.txr_status === \"0x1\"\n                  ? \"success\"\n                  : row.txr_status === \"0x0\"\n                    ? \"reverted\"\n                    : (row.txr_status as TransactionReceipt[\"status\"]),\n              to: row.txr_to ? checksumAddress(row.txr_to) : null,\n              transactionHash: row.txr_transactionHash,\n              transactionIndex: Number(row.txr_transactionIndex),\n              type:\n                row.txr_type === \"0x0\"\n                  ? \"legacy\"\n                  : row.txr_type === \"0x1\"\n                    ? \"eip2930\"\n                    : row.tx_type === \"0x2\"\n                      ? \"eip1559\"\n                      : row.tx_type === \"0x7e\"\n                        ? \"deposit\"\n                        : row.tx_type,\n            }\n          : undefined,\n      } satisfies RawEvent;\n    });\n\n    let cursor: string;\n    if (events.length !== limit) {\n      cursor = to;\n    } else {\n      cursor = events[events.length - 1]!.checkpoint!;\n    }\n\n    return { events, cursor };\n  },\n  insertRpcRequestResult: async ({ request, blockNumber, chainId, result }) =>\n    db.wrap({ method: \"insertRpcRequestResult\" }, async () => {\n      await db\n        .insertInto(\"rpcRequestResults\")\n        .values({\n          request,\n          blockNumber,\n          chainId,\n          result,\n        })\n        .onConflict((oc) =>\n          oc\n            .columns([\"request\", \"chainId\", \"blockNumber\"])\n            .doUpdateSet({ result }),\n        )\n        .execute();\n    }),\n  getRpcRequestResult: async ({ request, blockNumber, chainId }) =>\n    db.wrap({ method: \"getRpcRequestResult\" }, async () => {\n      const result = await db\n        .selectFrom(\"rpcRequestResults\")\n        .select(\"result\")\n        .where(\"request\", \"=\", request)\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \"=\", blockNumber.toString())\n        .executeTakeFirst();\n\n      return result?.result ?? null;\n    }),\n  pruneRpcRequestResult: async ({ blocks, chainId }) =>\n    db.wrap({ method: \"pruneRpcRequestResult\" }, async () => {\n      if (blocks.length === 0) return;\n\n      const numbers = blocks.map(({ number }) =>\n        hexToBigInt(number).toString(),\n      );\n\n      await db\n        .deleteFrom(\"rpcRequestResults\")\n        .where(\"chainId\", \"=\", chainId)\n        .where(\"blockNumber\", \"in\", numbers)\n        .execute();\n    }),\n  pruneByChain: async ({ fromBlock, chainId }) =>\n    db.wrap({ method: \"pruneByChain\" }, () =>\n      db.transaction().execute(async (tx) => {\n        await tx\n          .with(\"deleteLogFilter(logFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"logFilterIntervals\")\n              .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n              .select(\"logFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", fromBlock.toString()),\n          )\n          .deleteFrom(\"logFilterIntervals\")\n          .where(\n            \"logFilterId\",\n            \"in\",\n            ksql`(SELECT \"logFilterId\" FROM ${ksql.table(\"deleteLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateLogFilter(logFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"logFilterIntervals\")\n              .innerJoin(\"logFilters\", \"logFilterId\", \"logFilters.id\")\n              .select(\"logFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", fromBlock.toString())\n              .where(\"endBlock\", \">\", fromBlock.toString()),\n          )\n          .updateTable(\"logFilterIntervals\")\n          .set({\n            endBlock: fromBlock.toString(),\n          })\n          .where(\n            \"logFilterId\",\n            \"in\",\n            ksql`(SELECT \"logFilterId\" FROM ${ksql.table(\"updateLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteFactoryLogFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryLogFilterIntervals\")\n              .innerJoin(\n                \"factoryLogFilters\",\n                \"factoryId\",\n                \"factoryLogFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", fromBlock.toString()),\n          )\n          .deleteFrom(\"factoryLogFilterIntervals\")\n          .where(\n            \"factoryId\",\n            \"in\",\n            ksql`(SELECT \"factoryId\" FROM ${ksql.table(\"deleteFactoryLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateFactoryLogFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryLogFilterIntervals\")\n              .innerJoin(\n                \"factoryLogFilters\",\n                \"factoryId\",\n                \"factoryLogFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", fromBlock.toString())\n              .where(\"endBlock\", \">\", fromBlock.toString()),\n          )\n          .updateTable(\"factoryLogFilterIntervals\")\n          .set({\n            endBlock: BigInt(fromBlock),\n          })\n          .where(\n            \"factoryId\",\n            \"in\",\n            ksql`(SELECT \"factoryId\" FROM ${ksql.table(\"updateFactoryLogFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteTraceFilter(traceFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"traceFilterIntervals\")\n              .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n              .select(\"traceFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", fromBlock.toString()),\n          )\n          .deleteFrom(\"traceFilterIntervals\")\n          .where(\n            \"traceFilterId\",\n            \"in\",\n            ksql`(SELECT \"traceFilterId\" FROM ${ksql.table(\"deleteTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateTraceFilter(traceFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"traceFilterIntervals\")\n              .innerJoin(\"traceFilters\", \"traceFilterId\", \"traceFilters.id\")\n              .select(\"traceFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", fromBlock.toString())\n              .where(\"endBlock\", \">\", fromBlock.toString()),\n          )\n          .updateTable(\"traceFilterIntervals\")\n          .set({\n            endBlock: BigInt(fromBlock),\n          })\n          .where(\n            \"traceFilterId\",\n            \"in\",\n            ksql`(SELECT \"traceFilterId\" FROM ${ksql.table(\"updateTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteFactoryTraceFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryTraceFilterIntervals\")\n              .innerJoin(\n                \"factoryTraceFilters\",\n                \"factoryId\",\n                \"factoryTraceFilters.id\",\n              )\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", fromBlock.toString()),\n          )\n          .deleteFrom(\"factoryTraceFilterIntervals\")\n          .where(\n            \"factoryId\",\n            \"in\",\n            ksql`(SELECT \"factoryId\" FROM ${ksql.table(\"deleteFactoryTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateFactoryTraceFilter(factoryId)\", (qb) =>\n            qb\n              .selectFrom(\"factoryTraceFilterIntervals\")\n              .innerJoin(\n                \"factoryTraceFilters\",\n                \"factoryId\",\n                \"factoryTraceFilters.id\",\n              )\n\n              .select(\"factoryId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", fromBlock.toString())\n              .where(\"endBlock\", \">\", fromBlock.toString()),\n          )\n          .updateTable(\"factoryTraceFilterIntervals\")\n          .set({\n            endBlock: BigInt(fromBlock),\n          })\n          .where(\n            \"factoryId\",\n            \"in\",\n            ksql`(SELECT \"factoryId\" FROM ${ksql.table(\"updateFactoryTraceFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"deleteBlockFilter(blockFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"blockFilterIntervals\")\n              .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n              .select(\"blockFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \">=\", fromBlock.toString()),\n          )\n          .deleteFrom(\"blockFilterIntervals\")\n          .where(\n            \"blockFilterId\",\n            \"in\",\n            ksql`(SELECT \"blockFilterId\" FROM ${ksql.table(\"deleteBlockFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .with(\"updateBlockFilter(blockFilterId)\", (qb) =>\n            qb\n              .selectFrom(\"blockFilterIntervals\")\n              .innerJoin(\"blockFilters\", \"blockFilterId\", \"blockFilters.id\")\n              .select(\"blockFilterId\")\n              .where(\"chainId\", \"=\", chainId)\n              .where(\"startBlock\", \"<\", fromBlock.toString())\n              .where(\"endBlock\", \">\", fromBlock.toString()),\n          )\n          .updateTable(\"blockFilterIntervals\")\n          .set({\n            endBlock: BigInt(fromBlock),\n          })\n          .where(\n            \"blockFilterId\",\n            \"in\",\n            ksql`(SELECT \"blockFilterId\" FROM ${ksql.table(\"updateBlockFilter\")})`,\n          )\n          .execute();\n\n        await tx\n          .deleteFrom(\"logs\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", fromBlock.toString())\n          .execute();\n        await tx\n          .deleteFrom(\"blocks\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"number\", \">=\", fromBlock.toString())\n          .execute();\n        await tx\n          .deleteFrom(\"rpcRequestResults\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", fromBlock.toString())\n          .execute();\n        await tx\n          .deleteFrom(\"callTraces\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", fromBlock.toString())\n          .execute();\n        await tx\n          .deleteFrom(\"transactions\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", fromBlock.toString())\n          .execute();\n        await tx\n          .deleteFrom(\"transactionReceipts\")\n          .where(\"chainId\", \"=\", chainId)\n          .where(\"blockNumber\", \">=\", fromBlock.toString())\n          .execute();\n      }),\n    ),\n});\n","import type {\n  SyncBlock,\n  SyncCallTrace,\n  SyncLog,\n  SyncTransaction,\n  SyncTransactionReceipt,\n} from \"@/types/sync.js\";\nimport {\n  EVENT_TYPES,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { ColumnType, Generated, Insertable } from \"kysely\";\nimport type { Address, Hash, Hex } from \"viem\";\nimport { hexToBigInt, hexToNumber } from \"viem\";\n\ntype BlocksTable = {\n  hash: Hash;\n  chainId: number;\n  checkpoint: string;\n  number: ColumnType<string, string | bigint, string | bigint>;\n  timestamp: ColumnType<string, string | bigint, string | bigint>;\n  baseFeePerGas: ColumnType<string, string | bigint, string | bigint> | null;\n  difficulty: ColumnType<string, string | bigint, string | bigint>;\n  extraData: Hex;\n  gasLimit: ColumnType<string, string | bigint, string | bigint>;\n  gasUsed: ColumnType<string, string | bigint, string | bigint>;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash | null;\n  nonce: Hex | null;\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash | null;\n  size: ColumnType<string, string | bigint, string | bigint>;\n  stateRoot: Hash;\n  totalDifficulty: ColumnType<string, string | bigint, string | bigint> | null;\n  transactionsRoot: Hash;\n};\n\nexport const encodeBlock = ({\n  block,\n  chainId,\n}: {\n  block: SyncBlock;\n  chainId: number;\n}): Insertable<BlocksTable> => {\n  return {\n    hash: block.hash,\n    chainId,\n    checkpoint: encodeCheckpoint({\n      blockTimestamp: hexToNumber(block.timestamp),\n      chainId: BigInt(chainId),\n      blockNumber: hexToBigInt(block.number),\n      transactionIndex: maxCheckpoint.transactionIndex,\n      eventType: EVENT_TYPES.blocks,\n      eventIndex: zeroCheckpoint.eventIndex,\n    }),\n    baseFeePerGas: block.baseFeePerGas\n      ? hexToBigInt(block.baseFeePerGas)\n      : null,\n    difficulty: hexToBigInt(block.difficulty),\n    number: hexToBigInt(block.number),\n    timestamp: hexToBigInt(block.timestamp),\n    extraData: block.extraData,\n    gasLimit: hexToBigInt(block.gasLimit),\n    gasUsed: hexToBigInt(block.gasUsed),\n    logsBloom: block.logsBloom!,\n    miner: toLowerCase(block.miner),\n    mixHash: block.mixHash ?? null,\n    nonce: block.nonce ?? null,\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles ?? null,\n    size: hexToBigInt(block.size),\n    stateRoot: block.stateRoot,\n    totalDifficulty: block.totalDifficulty\n      ? hexToBigInt(block.totalDifficulty)\n      : null,\n    transactionsRoot: block.transactionsRoot,\n  };\n};\n\ntype LogsTable = {\n  id: string;\n  chainId: number;\n  checkpoint: string | null;\n  blockHash: Hash;\n  blockNumber: ColumnType<string, string | bigint, string | bigint>;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n  address: Address;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  data: Hex;\n};\n\nexport const encodeLog = ({\n  log,\n  block,\n  chainId,\n}: {\n  log: SyncLog;\n  block?: SyncBlock;\n  chainId: number;\n}): Insertable<LogsTable> => {\n  return {\n    id: `${log.blockHash}-${log.logIndex}`,\n    chainId,\n    checkpoint:\n      block === undefined\n        ? null\n        : encodeCheckpoint({\n            blockTimestamp: hexToNumber(block.timestamp),\n            chainId: BigInt(chainId),\n            blockNumber: hexToBigInt(log.blockNumber),\n            transactionIndex: hexToBigInt(log.transactionIndex),\n            eventType: EVENT_TYPES.logs,\n            eventIndex: hexToBigInt(log.logIndex),\n          }),\n    blockHash: log.blockHash,\n    blockNumber: hexToBigInt(log.blockNumber),\n    logIndex: hexToNumber(log.logIndex),\n    transactionHash: log.transactionHash,\n    transactionIndex: hexToNumber(log.transactionIndex),\n    address: toLowerCase(log.address),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    data: log.data,\n  };\n};\n\ntype TransactionsTable = {\n  hash: Hash;\n  blockHash: Hash;\n  blockNumber: ColumnType<string, string | bigint, string | bigint>;\n  from: Address;\n  gas: ColumnType<string, string | bigint, string | bigint>;\n  input: Hex;\n  nonce: number;\n  r: Hex | null;\n  s: Hex | null;\n  to: Address | null;\n  transactionIndex: number;\n  v: ColumnType<string, string | bigint, string | bigint> | null;\n  value: ColumnType<string, string | bigint, string | bigint>;\n  type: Hex;\n  gasPrice: ColumnType<string, string | bigint, string | bigint> | null;\n  maxFeePerGas: ColumnType<string, string | bigint, string | bigint> | null;\n  maxPriorityFeePerGas: ColumnType<\n    string,\n    string | bigint,\n    string | bigint\n  > | null;\n  accessList: string | null;\n\n  chainId: number;\n};\n\nexport const encodeTransaction = ({\n  transaction,\n  chainId,\n}: {\n  transaction: SyncTransaction;\n  chainId: number;\n}): Insertable<TransactionsTable> => {\n  return {\n    hash: transaction.hash,\n    chainId,\n    blockHash: transaction.blockHash,\n    blockNumber: hexToBigInt(transaction.blockNumber),\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    from: toLowerCase(transaction.from),\n    gas: hexToBigInt(transaction.gas),\n    gasPrice: transaction.gasPrice ? hexToBigInt(transaction.gasPrice) : null,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? hexToBigInt(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? hexToBigInt(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r ?? null,\n    s: transaction.s ?? null,\n    to: transaction.to ? toLowerCase(transaction.to) : null,\n    transactionIndex: hexToNumber(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: hexToBigInt(transaction.value),\n    v: transaction.v ? hexToBigInt(transaction.v) : null,\n  };\n};\n\ntype TransactionReceiptsTable = {\n  transactionHash: Hash;\n  chainId: number;\n  blockHash: Hash;\n  blockNumber: ColumnType<string, string | bigint, string | bigint>;\n  contractAddress: Address | null;\n  cumulativeGasUsed: ColumnType<string, string | bigint, string | bigint>;\n  effectiveGasPrice: ColumnType<string, string | bigint, string | bigint>;\n  from: Address;\n  gasUsed: ColumnType<string, string | bigint, string | bigint>;\n  logs: string;\n  logsBloom: Hex;\n  status: Hex;\n  to: Address | null;\n  transactionIndex: number;\n  type: Hex;\n};\n\nexport const encodeTransactionReceipt = ({\n  transactionReceipt,\n  chainId,\n}: {\n  transactionReceipt: SyncTransactionReceipt;\n  chainId: number;\n}): Insertable<TransactionReceiptsTable> => {\n  return {\n    transactionHash: transactionReceipt.transactionHash,\n    chainId,\n    blockHash: transactionReceipt.blockHash,\n    blockNumber: hexToBigInt(transactionReceipt.blockNumber),\n    contractAddress: transactionReceipt.contractAddress\n      ? toLowerCase(transactionReceipt.contractAddress)\n      : null,\n    cumulativeGasUsed: hexToBigInt(transactionReceipt.cumulativeGasUsed),\n    effectiveGasPrice: hexToBigInt(transactionReceipt.effectiveGasPrice),\n    from: toLowerCase(transactionReceipt.from),\n    gasUsed: hexToBigInt(transactionReceipt.gasUsed),\n    logs: JSON.stringify(transactionReceipt.logs),\n    logsBloom: transactionReceipt.logsBloom,\n    status: transactionReceipt.status,\n    to: transactionReceipt.to ? toLowerCase(transactionReceipt.to) : null,\n    transactionIndex: hexToNumber(transactionReceipt.transactionIndex),\n    type: transactionReceipt.type as Hex,\n  };\n};\n\ntype CallTracesTable = {\n  id: string;\n  chainId: number;\n  checkpoint: string;\n  callType: string;\n  from: Address;\n  gas: ColumnType<string, string | bigint, string | bigint>;\n  input: Hex;\n  to: Address;\n  value: ColumnType<string, string | bigint, string | bigint>;\n  blockHash: Hex;\n  blockNumber: ColumnType<string, string | bigint, string | bigint>;\n  error: string | null;\n  gasUsed: ColumnType<string, string | bigint, string | bigint> | null;\n  output: Hex | null;\n  subtraces: number;\n  traceAddress: string;\n  transactionHash: Hex;\n  transactionPosition: number;\n  functionSelector: Hex;\n};\n\nexport function encodeCallTrace({\n  trace,\n  chainId,\n}: {\n  trace: SyncCallTrace;\n  chainId: number;\n}): Insertable<Omit<CallTracesTable, \"checkpoint\">> {\n  return {\n    id: `${trace.transactionHash}-${JSON.stringify(trace.traceAddress)}`,\n    chainId,\n    callType: trace.action.callType,\n    from: toLowerCase(trace.action.from),\n    gas: hexToBigInt(trace.action.gas),\n    input: trace.action.input,\n    to: toLowerCase(trace.action.to),\n    value: hexToBigInt(trace.action.value),\n    blockHash: trace.blockHash,\n    blockNumber: hexToBigInt(trace.blockNumber),\n    error: trace.error ?? null,\n    gasUsed: trace.result ? hexToBigInt(trace.result.gasUsed) : null,\n    output: trace.result ? trace.result.output : null,\n    subtraces: trace.subtraces,\n    traceAddress: JSON.stringify(trace.traceAddress),\n    transactionHash: trace.transactionHash,\n    transactionPosition: trace.transactionPosition,\n    functionSelector: trace.action.input.slice(0, 10).toLowerCase() as Hex,\n  };\n}\n\ntype RpcRequestResultsTable = {\n  request: string;\n  chainId: number;\n  blockNumber: ColumnType<string, string | bigint, string | bigint>;\n  result: string;\n};\n\ntype LogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex | null;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype LogFilterIntervalsTable = {\n  id: Generated<number>;\n  logFilterId: string;\n  startBlock: ColumnType<string, string | bigint, string | bigint>;\n  endBlock: ColumnType<string, string | bigint, string | bigint>;\n};\n\ntype FactoryLogFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  topic0: Hex | null;\n  topic1: Hex | null;\n  topic2: Hex | null;\n  topic3: Hex | null;\n  includeTransactionReceipts: 0 | 1;\n};\n\ntype FactoryLogFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: ColumnType<string, string | bigint, string | bigint>;\n  endBlock: ColumnType<string, string | bigint, string | bigint>;\n};\n\ntype TraceFiltersTable = {\n  id: string;\n  chainId: number;\n  fromAddress: Address | null;\n  toAddress: Address | null;\n};\n\ntype TraceFilterIntervalsTable = {\n  id: Generated<number>;\n  traceFilterId: string;\n  startBlock: ColumnType<string, string | bigint, string | bigint>;\n  endBlock: ColumnType<string, string | bigint, string | bigint>;\n};\n\ntype FactoryTraceFiltersTable = {\n  id: string;\n  chainId: number;\n  address: Hex;\n  eventSelector: Hex;\n  childAddressLocation: `topic${1 | 2 | 3}` | `offset${number}`;\n  fromAddress: Address | null;\n};\n\ntype FactoryTraceFilterIntervalsTable = {\n  id: Generated<number>;\n  factoryId: string;\n  startBlock: ColumnType<string, string | bigint, string | bigint>;\n  endBlock: ColumnType<string, string | bigint, string | bigint>;\n};\n\ntype BlockFiltersTable = {\n  id: string;\n  chainId: number;\n  interval: number;\n  offset: number;\n};\n\ntype BlockFilterIntervalsTable = {\n  id: Generated<number>;\n  blockFilterId: string;\n  startBlock: ColumnType<string, string | bigint, string | bigint>;\n  endBlock: ColumnType<string, string | bigint, string | bigint>;\n};\n\nexport type PonderSyncSchema = {\n  blocks: BlocksTable;\n  logs: LogsTable;\n  transactions: TransactionsTable;\n  transactionReceipts: TransactionReceiptsTable;\n  callTraces: CallTracesTable;\n\n  rpcRequestResults: RpcRequestResultsTable;\n\n  logFilters: LogFiltersTable;\n  logFilterIntervals: LogFilterIntervalsTable;\n  factoryLogFilters: FactoryLogFiltersTable;\n  factoryLogFilterIntervals: FactoryLogFilterIntervalsTable;\n  traceFilters: TraceFiltersTable;\n  traceFilterIntervals: TraceFilterIntervalsTable;\n  factoryTraceFilters: FactoryTraceFiltersTable;\n  factoryTraceFilterIntervals: FactoryTraceFilterIntervalsTable;\n  blockFilters: BlockFiltersTable;\n  blockFilterIntervals: BlockFilterIntervalsTable;\n};\n","import {\n  type TraceFilterFragment,\n  buildLogFilterFragments,\n  buildTraceFilterFragments,\n} from \"@/sync/fragments.js\";\nimport {\n  type BlockFilter,\n  type CallTraceFilter,\n  type LogFactory,\n  type LogFilter,\n  isAddressFactory,\n} from \"@/sync/source.js\";\nimport type { SyncBlock, SyncCallTrace, SyncLog } from \"@/types/sync.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport { hexToNumber } from \"viem\";\n\n/**\n * Returns `true` if `log` matches `filter`\n */\nexport const isLogFactoryMatched = ({\n  filter,\n  log,\n}: { filter: LogFactory; log: SyncLog }): boolean => {\n  const addresses = Array.isArray(filter.address)\n    ? filter.address\n    : [filter.address];\n\n  if (addresses.every((address) => address !== toLowerCase(log.address))) {\n    return false;\n  }\n  if (log.topics.length === 0) return false;\n  if (filter.eventSelector !== toLowerCase(log.topics[0]!)) return false;\n\n  return true;\n};\n\n/**\n * Returns `true` if `log` matches `filter`\n */\nexport const isLogFilterMatched = ({\n  filter,\n  block,\n  log,\n}: {\n  filter: LogFilter;\n  block: SyncBlock;\n  log: SyncLog;\n}): boolean => {\n  // Return `false` for out of range blocks\n  if (\n    hexToNumber(block.number) < filter.fromBlock ||\n    hexToNumber(block.number) > (filter.toBlock ?? Number.POSITIVE_INFINITY)\n  ) {\n    return false;\n  }\n\n  return buildLogFilterFragments(filter).some((fragment) => {\n    if (\n      fragment.topic0 !== null &&\n      fragment.topic0 !== log.topics[0]?.toLowerCase()\n    )\n      return false;\n    if (\n      fragment.topic1 !== null &&\n      fragment.topic1 !== log.topics[1]?.toLowerCase()\n    )\n      return false;\n    if (\n      fragment.topic2 !== null &&\n      fragment.topic2 !== log.topics[2]?.toLowerCase()\n    )\n      return false;\n    if (\n      fragment.topic3 !== null &&\n      fragment.topic3 !== log.topics[3]?.toLowerCase()\n    )\n      return false;\n\n    if (\n      isAddressFactory(filter.address) === false &&\n      fragment.address !== null &&\n      fragment.address !== log.address.toLowerCase()\n    )\n      return false;\n\n    return true;\n  });\n};\n\n/**\n * Returns `true` if `callTrace` matches `filter`\n */\nexport const isCallTraceFilterMatched = ({\n  filter,\n  block,\n  callTrace,\n}: {\n  filter: CallTraceFilter;\n  block: SyncBlock;\n  callTrace: SyncCallTrace;\n}): boolean => {\n  // Return `false` for out of range blocks\n  if (\n    hexToNumber(block.number) < filter.fromBlock ||\n    hexToNumber(block.number) > (filter.toBlock ?? Number.POSITIVE_INFINITY)\n  ) {\n    return false;\n  }\n\n  return buildTraceFilterFragments(filter).some((fragment) => {\n    if (\n      fragment.fromAddress !== null &&\n      fragment.fromAddress !== callTrace.action.from.toLowerCase()\n    ) {\n      return false;\n    }\n\n    if (\n      isAddressFactory(filter.toAddress) === false &&\n      (fragment as TraceFilterFragment<undefined>).toAddress !== null &&\n      (fragment as TraceFilterFragment<undefined>).toAddress !==\n        callTrace.action.to.toLowerCase()\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\n/**\n * Returns `true` if `block` matches `filter`\n */\nexport const isBlockFilterMatched = ({\n  filter,\n  block,\n}: {\n  filter: BlockFilter;\n  block: SyncBlock;\n}): boolean => {\n  // Return `false` for out of range blocks\n  if (\n    hexToNumber(block.number) < filter.fromBlock ||\n    hexToNumber(block.number) > (filter.toBlock ?? Number.POSITIVE_INFINITY)\n  ) {\n    return false;\n  }\n\n  return (hexToNumber(block.number) - filter.offset) % filter.interval === 0;\n};\n","import type { Common } from \"@/common/common.js\";\nimport {\n  isBlockFilterMatched,\n  isCallTraceFilterMatched,\n  isLogFilterMatched,\n} from \"@/sync-realtime/filter.js\";\nimport type { BlockWithEventData } from \"@/sync-realtime/index.js\";\nimport type {\n  Block,\n  CallTrace,\n  Log,\n  Transaction,\n  TransactionReceipt,\n} from \"@/types/eth.js\";\nimport type {\n  SyncBlock,\n  SyncCallTrace,\n  SyncLog,\n  SyncTransaction,\n  SyncTransactionReceipt,\n} from \"@/types/sync.js\";\nimport {\n  EVENT_TYPES,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport type { AbiEvent, AbiParameter } from \"abitype\";\nimport {\n  type Address,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n  type Hash,\n  type Hex,\n  checksumAddress,\n  decodeAbiParameters,\n  decodeFunctionData,\n  decodeFunctionResult,\n  hexToBigInt,\n  hexToNumber,\n} from \"viem\";\nimport { type Factory, type Source, isAddressFactory } from \"./source.js\";\n\nexport type RawEvent = {\n  chainId: number;\n  sourceIndex: number;\n  checkpoint: string;\n  log?: Log;\n  block: Block;\n  transaction?: Transaction;\n  transactionReceipt?: TransactionReceipt;\n  trace?: CallTrace;\n};\n\nexport type Event = LogEvent | BlockEvent | CallTraceEvent;\n\nexport type SetupEvent = {\n  type: \"setup\";\n  chainId: number;\n  checkpoint: string;\n\n  /** `${source.name}:setup` */\n  name: string;\n\n  block: bigint;\n};\n\nexport type LogEvent = {\n  type: \"log\";\n  chainId: number;\n  checkpoint: string;\n\n  /** `${source.name}:${safeName}` */\n  name: string;\n\n  event: {\n    name: string;\n    args: any;\n    log: Log;\n    block: Block;\n    transaction: Transaction;\n    transactionReceipt?: TransactionReceipt;\n  };\n};\n\nexport type BlockEvent = {\n  type: \"block\";\n  chainId: number;\n  checkpoint: string;\n\n  /** `${source.name}:block` */\n  name: string;\n\n  event: {\n    block: Block;\n  };\n};\n\nexport type CallTraceEvent = {\n  type: \"callTrace\";\n  chainId: number;\n  checkpoint: string;\n\n  /** `${source.name}.${safeName}()` */\n  name: string;\n\n  event: {\n    args: any;\n    result: any;\n    trace: CallTrace;\n    block: Block;\n    transaction: Transaction;\n    transactionReceipt?: TransactionReceipt;\n  };\n};\n\n/**\n * Create `RawEvent`s from raw data types\n */\nexport const buildEvents = ({\n  sources,\n  blockWithEventData: {\n    block,\n    logs,\n    transactions,\n    transactionReceipts,\n    callTraces,\n  },\n  finalizedChildAddresses,\n  unfinalizedChildAddresses,\n  chainId,\n}: {\n  sources: Source[];\n  blockWithEventData: Omit<BlockWithEventData, \"filters\" | \"factoryLogs\">;\n  finalizedChildAddresses: Map<Factory, Set<Address>>;\n  unfinalizedChildAddresses: Map<Factory, Set<Address>>;\n  chainId: number;\n}) => {\n  const events: RawEvent[] = [];\n\n  const transactionCache = new Map<Hash, SyncTransaction>();\n  const transactionReceiptCache = new Map<Hash, SyncTransactionReceipt>();\n  const traceByTransactionHash = new Map<Hash, SyncCallTrace[]>();\n  for (const transaction of transactions) {\n    transactionCache.set(transaction.hash, transaction);\n  }\n  for (const transactionReceipt of transactionReceipts) {\n    transactionReceiptCache.set(\n      transactionReceipt.transactionHash,\n      transactionReceipt,\n    );\n  }\n  for (const callTrace of callTraces) {\n    if (traceByTransactionHash.has(callTrace.transactionHash) === false) {\n      traceByTransactionHash.set(callTrace.transactionHash, []);\n    }\n    traceByTransactionHash.get(callTrace.transactionHash)!.push(callTrace);\n  }\n\n  for (let i = 0; i < sources.length; i++) {\n    const filter = sources[i]!.filter;\n    if (chainId !== filter.chainId) continue;\n    switch (filter.type) {\n      case \"log\": {\n        for (const log of logs) {\n          if (\n            isLogFilterMatched({ filter, block, log }) &&\n            (isAddressFactory(filter.address)\n              ? finalizedChildAddresses.get(filter.address)!.has(log.address) ||\n                unfinalizedChildAddresses.get(filter.address)!.has(log.address)\n              : true)\n          ) {\n            events.push({\n              chainId: filter.chainId,\n              sourceIndex: i,\n              checkpoint: encodeCheckpoint({\n                blockTimestamp: hexToNumber(block.timestamp),\n                chainId: BigInt(filter.chainId),\n                blockNumber: hexToBigInt(log.blockNumber),\n                transactionIndex: hexToBigInt(log.transactionIndex),\n                eventType: EVENT_TYPES.logs,\n                eventIndex: hexToBigInt(log.logIndex),\n              }),\n              log: convertLog(log),\n              block: convertBlock(block),\n              transaction: convertTransaction(\n                transactionCache.get(log.transactionHash)!,\n              ),\n              transactionReceipt: filter.includeTransactionReceipts\n                ? convertTransactionReceipt(\n                    transactionReceiptCache.get(log.transactionHash)!,\n                  )\n                : undefined,\n              trace: undefined,\n            });\n          }\n        }\n        break;\n      }\n\n      case \"block\": {\n        if (isBlockFilterMatched({ filter, block })) {\n          events.push({\n            chainId: filter.chainId,\n            sourceIndex: i,\n            checkpoint: encodeCheckpoint({\n              blockTimestamp: hexToNumber(block.timestamp),\n              chainId: BigInt(filter.chainId),\n              blockNumber: hexToBigInt(block.number),\n              transactionIndex: maxCheckpoint.transactionIndex,\n              eventType: EVENT_TYPES.blocks,\n              eventIndex: zeroCheckpoint.eventIndex,\n            }),\n            block: convertBlock(block),\n            log: undefined,\n            trace: undefined,\n            transaction: undefined,\n            transactionReceipt: undefined,\n          });\n        }\n        break;\n      }\n\n      case \"callTrace\": {\n        for (const callTraces of Array.from(traceByTransactionHash.values())) {\n          // Use lexographical sort of stringified `traceAddress`.\n          callTraces.sort((a, b) => {\n            return a.traceAddress < b.traceAddress ? -1 : 1;\n          });\n\n          let eventIndex = 0n;\n          for (const callTrace of callTraces) {\n            if (\n              isCallTraceFilterMatched({ filter, block, callTrace }) &&\n              (isAddressFactory(filter.toAddress)\n                ? finalizedChildAddresses\n                    .get(filter.toAddress)!\n                    .has(callTrace.action.to) ||\n                  unfinalizedChildAddresses\n                    .get(filter.toAddress)!\n                    .has(callTrace.action.to)\n                : true) &&\n              callTrace.result !== null &&\n              filter.functionSelectors.includes(\n                callTrace.action.input.slice(0, 10).toLowerCase() as Hex,\n              )\n            ) {\n              events.push({\n                chainId: filter.chainId,\n                sourceIndex: i,\n                checkpoint: encodeCheckpoint({\n                  blockTimestamp: hexToNumber(block.timestamp),\n                  chainId: BigInt(filter.chainId),\n                  blockNumber: hexToBigInt(callTrace.blockNumber),\n                  transactionIndex: BigInt(callTrace.transactionPosition),\n                  eventType: EVENT_TYPES.callTraces,\n                  eventIndex: eventIndex++,\n                }),\n                log: undefined,\n                trace: convertCallTrace(callTrace),\n                block: convertBlock(block),\n                transaction: convertTransaction(\n                  transactionCache.get(callTrace.transactionHash)!,\n                ),\n                transactionReceipt: filter.includeTransactionReceipts\n                  ? convertTransactionReceipt(\n                      transactionReceiptCache.get(callTrace.transactionHash)!,\n                    )\n                  : undefined,\n              });\n            }\n          }\n        }\n\n        break;\n      }\n      default:\n        never(filter);\n    }\n  }\n\n  return events.sort((a, b) => (a.checkpoint < b.checkpoint ? -1 : 1));\n};\n\nexport const decodeEvents = (\n  common: Common,\n  sources: Source[],\n  rawEvents: RawEvent[],\n): Event[] => {\n  const events: Event[] = [];\n\n  const endClock = startClock();\n\n  for (const event of rawEvents) {\n    const source = sources[event.sourceIndex]!;\n\n    switch (source.type) {\n      case \"block\": {\n        events.push({\n          type: \"block\",\n          chainId: event.chainId,\n          checkpoint: event.checkpoint,\n          name: `${source.name}:block`,\n          event: {\n            block: event.block,\n          },\n        });\n        break;\n      }\n      case \"contract\": {\n        switch (source.filter.type) {\n          case \"log\": {\n            try {\n              if (\n                event.log!.topics[0] === undefined ||\n                source.abiEvents.bySelector[event.log!.topics[0]] === undefined\n              ) {\n                throw new Error();\n              }\n\n              const { safeName, item } =\n                source.abiEvents.bySelector[event.log!.topics[0]]!;\n\n              const args = decodeEventLog({\n                abiItem: item,\n                data: event.log!.data,\n                topics: event.log!.topics,\n              });\n\n              events.push({\n                type: \"log\",\n                chainId: event.chainId,\n                checkpoint: event.checkpoint,\n\n                name: `${source.name}:${safeName}`,\n\n                event: {\n                  name: safeName,\n                  args,\n                  log: event.log!,\n                  block: event.block,\n                  transaction: event.transaction!,\n                  transactionReceipt: event.transactionReceipt,\n                },\n              });\n            } catch (err) {\n              if (source.filter.address === undefined) {\n                common.logger.debug({\n                  service: \"app\",\n                  msg: `Unable to decode log, skipping it. id: ${event.log?.id}, data: ${event.log?.data}, topics: ${event.log?.topics}`,\n                });\n              } else {\n                common.logger.warn({\n                  service: \"app\",\n                  msg: `Unable to decode log, skipping it. id: ${event.log?.id}, data: ${event.log?.data}, topics: ${event.log?.topics}`,\n                });\n              }\n            }\n            break;\n          }\n\n          case \"callTrace\": {\n            try {\n              const selector = event\n                .trace!.input.slice(0, 10)\n                .toLowerCase() as Hex;\n\n              if (source.abiFunctions.bySelector[selector] === undefined) {\n                throw new Error();\n              }\n\n              const { safeName, item } =\n                source.abiFunctions.bySelector[selector]!;\n\n              const { args, functionName } = decodeFunctionData({\n                abi: [item],\n                data: event.trace!.input,\n              });\n\n              const result = decodeFunctionResult({\n                abi: [item],\n                data: event.trace!.output,\n                functionName,\n              });\n\n              events.push({\n                type: \"callTrace\",\n                chainId: event.chainId,\n                checkpoint: event.checkpoint,\n\n                name: `${source.name}.${safeName}`,\n\n                event: {\n                  args,\n                  result,\n                  trace: event.trace!,\n                  block: event.block,\n                  transaction: event.transaction!,\n                  transactionReceipt: event.transactionReceipt,\n                },\n              });\n            } catch (err) {\n              if (source.filter.toAddress === undefined) {\n                common.logger.debug({\n                  service: \"app\",\n                  msg: `Unable to decode trace, skipping it. id: ${event.trace?.id}, input: ${event.trace?.input}, output: ${event.trace?.output}`,\n                });\n              } else {\n                common.logger.warn({\n                  service: \"app\",\n                  msg: `Unable to decode trace, skipping it. id: ${event.trace?.id}, input: ${event.trace?.input}, output: ${event.trace?.output}`,\n                });\n              }\n            }\n            break;\n          }\n\n          default:\n            never(source.filter);\n        }\n        break;\n      }\n\n      default:\n        never(source);\n    }\n  }\n\n  common.metrics.ponder_indexing_abi_decoding_duration.observe(endClock());\n\n  return events;\n};\n\n/** @see https://github.com/wevm/viem/blob/main/src/utils/abi/decodeEventLog.ts#L99 */\nfunction decodeEventLog({\n  abiItem,\n  topics,\n  data,\n}: {\n  abiItem: AbiEvent;\n  topics: [signature: Hex, ...args: Hex[]] | [];\n  data: Hex;\n}): any {\n  const { inputs } = abiItem;\n  const isUnnamed = inputs?.some((x) => !(\"name\" in x && x.name));\n\n  let args: any = isUnnamed ? [] : {};\n\n  const [, ...argTopics] = topics;\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => \"indexed\" in x && x.indexed);\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]!;\n    const topic = argTopics[i];\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      });\n    args[isUnnamed ? i : param.name || i] = decodeTopic({\n      param,\n      value: topic,\n    });\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !(\"indexed\" in x && x.indexed));\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== \"0x\") {\n      const decodedData = decodeAbiParameters(nonIndexedInputs, data);\n      if (decodedData) {\n        if (isUnnamed) args = [...args, ...decodedData];\n        else {\n          for (let i = 0; i < nonIndexedInputs.length; i++) {\n            args[nonIndexedInputs[i]!.name!] = decodedData[i];\n          }\n        }\n      }\n    } else {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: \"0x\",\n        params: nonIndexedInputs,\n        size: 0,\n      });\n    }\n  }\n\n  return Object.values(args).length > 0 ? args : undefined;\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === \"string\" ||\n    param.type === \"bytes\" ||\n    param.type === \"tuple\" ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value;\n  const decodedArg = decodeAbiParameters([param], value) || [];\n  return decodedArg[0];\n}\n\nconst convertBlock = (block: SyncBlock): Block => ({\n  baseFeePerGas: block.baseFeePerGas ? hexToBigInt(block.baseFeePerGas) : null,\n  difficulty: hexToBigInt(block.difficulty),\n  extraData: block.extraData,\n  gasLimit: hexToBigInt(block.gasLimit),\n  gasUsed: hexToBigInt(block.gasUsed),\n  hash: block.hash,\n  logsBloom: block.logsBloom,\n  miner: checksumAddress(block.miner),\n  mixHash: block.mixHash,\n  nonce: block.nonce,\n  number: hexToBigInt(block.number),\n  parentHash: block.parentHash,\n  receiptsRoot: block.receiptsRoot,\n  sha3Uncles: block.sha3Uncles,\n  size: hexToBigInt(block.size),\n  stateRoot: block.stateRoot,\n  timestamp: hexToBigInt(block.timestamp),\n  totalDifficulty: block.totalDifficulty\n    ? hexToBigInt(block.totalDifficulty)\n    : null,\n  transactionsRoot: block.transactionsRoot,\n});\n\nconst convertLog = (log: SyncLog): Log => ({\n  id: `${log.blockHash}-${log.logIndex}`,\n  address: checksumAddress(log.address!),\n  blockHash: log.blockHash,\n  blockNumber: hexToBigInt(log.blockNumber),\n  data: log.data,\n  logIndex: Number(log.logIndex),\n  removed: false,\n  topics: log.topics,\n  transactionHash: log.transactionHash,\n  transactionIndex: Number(log.transactionIndex),\n});\n\nconst convertTransaction = (transaction: SyncTransaction): Transaction => ({\n  blockHash: transaction.blockHash,\n  blockNumber: hexToBigInt(transaction.blockNumber),\n  from: checksumAddress(transaction.from),\n  gas: hexToBigInt(transaction.gas),\n  hash: transaction.hash,\n  input: transaction.input,\n  nonce: Number(transaction.nonce),\n  r: transaction.r,\n  s: transaction.s,\n  to: transaction.to ? checksumAddress(transaction.to) : transaction.to,\n  transactionIndex: Number(transaction.transactionIndex),\n  value: hexToBigInt(transaction.value),\n  v: transaction.v ? hexToBigInt(transaction.v) : null,\n  ...(transaction.type === \"0x0\"\n    ? {\n        type: \"legacy\",\n        gasPrice: hexToBigInt(transaction.gasPrice),\n      }\n    : transaction.type === \"0x1\"\n      ? {\n          type: \"eip2930\",\n          gasPrice: hexToBigInt(transaction.gasPrice),\n          accessList: transaction.accessList,\n        }\n      : transaction.type === \"0x2\"\n        ? {\n            type: \"eip1559\",\n            maxFeePerGas: hexToBigInt(transaction.maxFeePerGas),\n            maxPriorityFeePerGas: hexToBigInt(transaction.maxPriorityFeePerGas),\n          }\n        : // @ts-ignore\n          transaction.type === \"0x7e\"\n          ? {\n              type: \"deposit\",\n              // @ts-ignore\n              maxFeePerGas: transaction.maxFeePerGas\n                ? // @ts-ignore\n                  hexToBigInt(transaction.maxFeePerGas)\n                : undefined,\n              // @ts-ignore\n              maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n                ? // @ts-ignore\n                  hexToBigInt(transaction.maxPriorityFeePerGas)\n                : undefined,\n            }\n          : {\n              // @ts-ignore\n              type: transaction.type,\n            }),\n});\n\nconst convertTransactionReceipt = (\n  transactionReceipt: SyncTransactionReceipt,\n): TransactionReceipt => ({\n  blockHash: transactionReceipt.blockHash,\n  blockNumber: hexToBigInt(transactionReceipt.blockNumber),\n  contractAddress: transactionReceipt.contractAddress\n    ? checksumAddress(transactionReceipt.contractAddress)\n    : null,\n  cumulativeGasUsed: hexToBigInt(transactionReceipt.cumulativeGasUsed),\n  effectiveGasPrice: hexToBigInt(transactionReceipt.effectiveGasPrice),\n  from: checksumAddress(transactionReceipt.from),\n  gasUsed: hexToBigInt(transactionReceipt.gasUsed),\n  logs: transactionReceipt.logs.map((log) => ({\n    id: `${log.blockHash}-${log.logIndex}`,\n    address: checksumAddress(log.address),\n    blockHash: log.blockHash!,\n    blockNumber: hexToBigInt(log.blockNumber!),\n    data: log.data,\n    logIndex: hexToNumber(log.logIndex!),\n    removed: false,\n    topics: [\n      log.topics[0] ?? null,\n      log.topics[1] ?? null,\n      log.topics[2] ?? null,\n      log.topics[3] ?? null,\n    ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n    transactionHash: log.transactionHash!,\n    transactionIndex: hexToNumber(log.transactionIndex!),\n  })),\n  logsBloom: transactionReceipt.logsBloom,\n  status:\n    transactionReceipt.status === \"0x1\"\n      ? \"success\"\n      : transactionReceipt.status === \"0x0\"\n        ? \"reverted\"\n        : (transactionReceipt.status as TransactionReceipt[\"status\"]),\n  to: transactionReceipt.to ? checksumAddress(transactionReceipt.to) : null,\n  transactionHash: transactionReceipt.transactionHash,\n  transactionIndex: Number(transactionReceipt.transactionIndex),\n  type:\n    transactionReceipt.type === \"0x0\"\n      ? \"legacy\"\n      : transactionReceipt.type === \"0x1\"\n        ? \"eip2930\"\n        : transactionReceipt.type === \"0x2\"\n          ? \"eip1559\"\n          : transactionReceipt.type === \"0x7e\"\n            ? \"deposit\"\n            : transactionReceipt.type,\n});\n\nconst convertCallTrace = (callTrace: SyncCallTrace): CallTrace => ({\n  id: `${callTrace.transactionHash}-${JSON.stringify(callTrace.traceAddress)}`,\n  from: checksumAddress(callTrace.action.from),\n  to: checksumAddress(callTrace.action.to),\n  gas: hexToBigInt(callTrace.action.gas),\n  value: hexToBigInt(callTrace.action.value),\n  input: callTrace.action.input,\n  output: callTrace.result!.output,\n  gasUsed: hexToBigInt(callTrace.result!.gasUsed),\n  subtraces: callTrace.subtraces,\n  traceAddress: callTrace.traceAddress,\n  blockHash: callTrace.blockHash,\n  blockNumber: hexToBigInt(callTrace.blockNumber),\n  transactionHash: callTrace.transactionHash,\n  transactionIndex: callTrace.transactionPosition,\n  callType: callTrace.action.callType as CallTrace[\"callType\"],\n});\n","import type {\n  SyncBlock,\n  SyncLog,\n  SyncTrace,\n  SyncTransactionReceipt,\n} from \"@/types/sync.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  type Address,\n  BlockNotFoundError,\n  type Hash,\n  type Hex,\n  type LogTopic,\n  TransactionReceiptNotFoundError,\n  numberToHex,\n} from \"viem\";\n\n/**\n * Helper function for \"eth_getBlockByNumber\" request.\n */\nexport const _eth_getBlockByNumber = (\n  requestQueue: RequestQueue,\n  {\n    blockNumber,\n    blockTag,\n  }:\n    | { blockNumber: Hex | number; blockTag?: never }\n    | { blockNumber?: never; blockTag: \"latest\" },\n): Promise<SyncBlock> =>\n  requestQueue\n    .request({\n      method: \"eth_getBlockByNumber\",\n      params: [\n        typeof blockNumber === \"number\"\n          ? numberToHex(blockNumber)\n          : blockNumber ?? blockTag,\n        true,\n      ],\n    })\n    .then((_block) => {\n      if (!_block)\n        throw new BlockNotFoundError({\n          blockNumber: (blockNumber ?? blockTag) as any,\n        });\n      return _block as SyncBlock;\n    });\n\n/**\n * Helper function for \"eth_getBlockByNumber\" request.\n */\nexport const _eth_getBlockByHash = (\n  requestQueue: RequestQueue,\n  { hash }: { hash: Hex },\n): Promise<SyncBlock> =>\n  requestQueue\n    .request({\n      method: \"eth_getBlockByHash\",\n      params: [hash, true],\n    })\n    .then((_block) => {\n      if (!_block)\n        throw new BlockNotFoundError({\n          blockHash: hash,\n        });\n      return _block as SyncBlock;\n    });\n\n/**\n * Helper function for \"eth_getLogs\" rpc request.\n * Handles different error types and retries the request if applicable.\n */\nexport const _eth_getLogs = async (\n  requestQueue: RequestQueue,\n  params: {\n    address?: Address | Address[];\n    topics?: LogTopic[];\n  } & (\n    | { fromBlock: Hex | number; toBlock: Hex | number }\n    | { blockHash: Hash }\n  ),\n): Promise<SyncLog[]> => {\n  if (\"blockHash\" in params) {\n    return requestQueue\n      .request({\n        method: \"eth_getLogs\",\n        params: [\n          {\n            blockHash: params.blockHash,\n\n            topics: params.topics,\n            address: params.address\n              ? Array.isArray(params.address)\n                ? params.address.map((a) => toLowerCase(a))\n                : toLowerCase(params.address)\n              : undefined,\n          },\n        ],\n      })\n      .then((l) => l as SyncLog[]);\n  }\n\n  return requestQueue\n    .request({\n      method: \"eth_getLogs\",\n      params: [\n        {\n          fromBlock:\n            typeof params.fromBlock === \"number\"\n              ? numberToHex(params.fromBlock)\n              : params.fromBlock,\n          toBlock:\n            typeof params.toBlock === \"number\"\n              ? numberToHex(params.toBlock)\n              : params.toBlock,\n\n          topics: params.topics,\n          address: params.address\n            ? Array.isArray(params.address)\n              ? params.address.map((a) => toLowerCase(a))\n              : toLowerCase(params.address)\n            : undefined,\n        },\n      ],\n    })\n    .then((l) => l as SyncLog[]);\n};\n\n/**\n * Helper function for \"eth_getTransactionReceipt\" request.\n */\nexport const _eth_getTransactionReceipt = (\n  requestQueue: RequestQueue,\n  { hash }: { hash: Hex },\n): Promise<SyncTransactionReceipt> =>\n  requestQueue\n    .request({\n      method: \"eth_getTransactionReceipt\",\n      params: [hash],\n    })\n    .then((receipt) => {\n      if (!receipt)\n        throw new TransactionReceiptNotFoundError({\n          hash,\n        });\n      return receipt as SyncTransactionReceipt;\n    });\n\n/**\n * Helper function for \"trace_filter\" request.\n *\n * Note: No strict typing is available.\n */\nexport const _trace_filter = (\n  requestQueue: RequestQueue,\n  params: {\n    fromBlock: Hex | number;\n    toBlock: Hex | number;\n    fromAddress?: Address[];\n    toAddress?: Address[];\n  },\n): Promise<SyncTrace[]> =>\n  requestQueue\n    .request({\n      method: \"trace_filter\",\n      params: [\n        {\n          fromBlock:\n            typeof params.fromBlock === \"number\"\n              ? numberToHex(params.fromBlock)\n              : params.fromBlock,\n          toBlock:\n            typeof params.toBlock === \"number\"\n              ? numberToHex(params.toBlock)\n              : params.toBlock,\n          fromAddress: params.fromAddress\n            ? params.fromAddress.map((a) => toLowerCase(a))\n            : undefined,\n          toAddress: params.toAddress\n            ? params.toAddress.map((a) => toLowerCase(a))\n            : undefined,\n        },\n      ],\n    } as any)\n    .then((traces) => traces as unknown as SyncTrace[]);\n\n/**\n * Helper function for \"trace_block\" request.\n */\nexport const _trace_block = (\n  requestQueue: RequestQueue,\n  params: {\n    blockNumber: Hex | number;\n  },\n): Promise<SyncTrace[]> =>\n  requestQueue\n    .request({\n      method: \"trace_block\",\n      params: [\n        typeof params.blockNumber === \"number\"\n          ? numberToHex(params.blockNumber)\n          : params.blockNumber,\n      ],\n    } as any)\n    .then((traces) => traces as unknown as SyncTrace[]);\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport type { SyncStore } from \"@/sync-store/index.js\";\nimport {\n  type BlockFilter,\n  type CallTraceFilter,\n  type Factory,\n  type Filter,\n  type LogFactory,\n  type LogFilter,\n  isAddressFactory,\n} from \"@/sync/source.js\";\nimport type { Source } from \"@/sync/source.js\";\nimport type { SyncBlock, SyncCallTrace, SyncLog } from \"@/types/sync.js\";\nimport {\n  type Interval,\n  getChunks,\n  intervalDifference,\n} from \"@/utils/interval.js\";\nimport { never } from \"@/utils/never.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  _eth_getBlockByNumber,\n  _eth_getLogs,\n  _eth_getTransactionReceipt,\n  _trace_filter,\n} from \"@/utils/rpc.js\";\nimport { getLogsRetryHelper } from \"@ponder/utils\";\nimport {\n  type Address,\n  type Hash,\n  type RpcError,\n  hexToBigInt,\n  hexToNumber,\n  toHex,\n} from \"viem\";\n\nexport type HistoricalSync = {\n  intervalsCache: Map<Filter, Interval[]>;\n  /**\n   * Extract raw data for `interval` and return the closest-to-tip block\n   * that is synced.\n   */\n  sync(interval: Interval): Promise<SyncBlock | undefined>;\n  kill(): void;\n};\n\ntype CreateHistoricalSyncParameters = {\n  common: Common;\n  sources: Source[];\n  syncStore: SyncStore;\n  network: Network;\n  requestQueue: RequestQueue;\n  onFatalError: (error: Error) => void;\n};\n\nexport const createHistoricalSync = async (\n  args: CreateHistoricalSyncParameters,\n): Promise<HistoricalSync> => {\n  let isKilled = false;\n\n  /**\n   * Blocks that have already been extracted.\n   * Note: All entries are deleted at the end of each call to `sync()`.\n   */\n  const blockCache = new Map<bigint, Promise<SyncBlock>>();\n  /**\n   * Transactions that should be saved to the sync-store.\n   * Note: All entries are deleted at the end of each call to `sync()`.\n   */\n  const transactionsCache = new Set<Hash>();\n  /**\n   * Data about the range passed to \"eth_getLogs\" for all log\n   *  filters and log factories.\n   */\n  const getLogsRequestMetadata = new Map<\n    LogFilter | LogFactory,\n    {\n      /** Estimate optimal range to use for \"eth_getLogs\" requests */\n      estimatedRange: number;\n      /** Range suggested by an error message */\n      confirmedRange?: number;\n    }\n  >();\n  /**\n   * Intervals that have been completed for all filters in `args.sources`.\n   *\n   * Note: `intervalsCache` is not updated after a new interval is synced.\n   */\n  const intervalsCache: Map<Filter, Interval[]> = new Map();\n\n  // Populate `intervalsCache` by querying the sync-store.\n  for (const { filter } of args.sources) {\n    const intervals = await args.syncStore.getIntervals({ filter });\n    intervalsCache.set(filter, intervals);\n  }\n\n  // Closest-to-tip block that has been synced.\n  let latestBlock: SyncBlock | undefined;\n\n  ////////\n  // Helper functions for specific sync tasks\n  ////////\n\n  /**\n   * Split \"eth_getLogs\" requests into ranges inferred from errors.\n   */\n  const getLogsDynamic = async ({\n    filter,\n    address,\n    interval,\n  }: {\n    filter: LogFilter | LogFactory;\n    interval: Interval;\n    /** Explicitly set because of the complexity of factory contracts. */\n    address: Address | Address[] | undefined;\n  }): Promise<SyncLog[]> => {\n    //  Use the recommended range if available, else don't chunk the interval at all.\n\n    const metadata = getLogsRequestMetadata.get(filter);\n    const intervals = metadata\n      ? getChunks({\n          interval,\n          maxChunkSize: metadata.confirmedRange ?? metadata.estimatedRange,\n        })\n      : [interval];\n\n    const topics =\n      \"eventSelector\" in filter ? [filter.eventSelector] : filter.topics;\n\n    // Batch large arrays of addresses, handling arrays that are empty or over the threshold\n\n    let addressBatches: (Address | Address[] | undefined)[];\n    if (address === undefined || typeof address === \"string\") {\n      addressBatches = [address];\n    } else if (address.length === 0) {\n      return [];\n    } else if (\n      address.length >= args.common.options.factoryAddressCountThreshold\n    ) {\n      addressBatches = [undefined];\n    } else {\n      addressBatches = [];\n      for (let i = 0; i < address.length; i += 50) {\n        addressBatches.push(address.slice(i, i + 50));\n      }\n    }\n\n    const logs = await Promise.all(\n      intervals.flatMap((interval) =>\n        addressBatches.map((address) =>\n          _eth_getLogs(args.requestQueue, {\n            address,\n            topics,\n            fromBlock: interval[0],\n            toBlock: interval[1],\n          }).catch((error) => {\n            const getLogsErrorResponse = getLogsRetryHelper({\n              params: [\n                {\n                  address,\n                  topics,\n                  fromBlock: toHex(interval[0]),\n                  toBlock: toHex(interval[1]),\n                },\n              ],\n              error: error as RpcError,\n            });\n\n            if (getLogsErrorResponse.shouldRetry === false) throw error;\n\n            const range =\n              hexToNumber(getLogsErrorResponse.ranges[0]!.toBlock) -\n              hexToNumber(getLogsErrorResponse.ranges[0]!.fromBlock);\n\n            args.common.logger.debug({\n              service: \"sync\",\n              msg: `Caught eth_getLogs error on '${\n                args.network.name\n              }', updating recommended range to ${range}.`,\n            });\n\n            getLogsRequestMetadata.set(filter, {\n              estimatedRange: range,\n              confirmedRange: getLogsErrorResponse.isSuggestedRange\n                ? range\n                : undefined,\n            });\n\n            return getLogsDynamic({ address, interval, filter });\n          }),\n        ),\n      ),\n    ).then((logs) => logs.flat());\n\n    /**\n     * Dynamically increase the range used in \"eth_getLogs\" if an\n     * error has been received but the error didn't suggest a range.\n     */\n\n    if (\n      getLogsRequestMetadata.has(filter) &&\n      getLogsRequestMetadata.get(filter)!.confirmedRange === undefined\n    ) {\n      getLogsRequestMetadata.get(filter)!.estimatedRange = Math.round(\n        getLogsRequestMetadata.get(filter)!.estimatedRange * 1.05,\n      );\n    }\n\n    return logs;\n  };\n\n  const syncLogFilter = async (filter: LogFilter, interval: Interval) => {\n    // Resolve `filter.address`\n    const address = isAddressFactory(filter.address)\n      ? await syncAddress(filter.address, interval)\n      : filter.address;\n\n    if (isKilled) return;\n\n    const logs = await getLogsDynamic({ filter, interval, address });\n\n    if (isKilled) return;\n\n    const blocks = await Promise.all(\n      logs.map((log) => syncBlock(hexToBigInt(log.blockNumber))),\n    );\n\n    // Validate that logs point to the valid transaction hash in the block\n    for (let i = 0; i < logs.length; i++) {\n      const log = logs[i]!;\n      const block = blocks[i]!;\n\n      if (block.hash !== log.blockHash) {\n        throw new Error(\n          `Detected inconsistent RPC responses. 'log.blockHash' ${log.blockHash} does not match 'block.hash' ${block.hash}`,\n        );\n      }\n\n      if (\n        block.transactions.find((t) => t.hash === log.transactionHash) ===\n        undefined\n      ) {\n        throw new Error(\n          `Detected inconsistent RPC responses. 'log.transactionHash' ${log.transactionHash} not found in 'block.transactions' ${block.hash}`,\n        );\n      }\n    }\n\n    const transactionHashes = new Set(logs.map((l) => l.transactionHash));\n    for (const hash of transactionHashes) {\n      transactionsCache.add(hash);\n    }\n\n    if (isKilled) return;\n\n    await args.syncStore.insertLogs({\n      logs: logs.map((log, i) => ({ log, block: blocks[i]! })),\n      shouldUpdateCheckpoint: true,\n      chainId: args.network.chainId,\n    });\n\n    if (isKilled) return;\n\n    if (filter.includeTransactionReceipts) {\n      const transactionReceipts = await Promise.all(\n        Array.from(transactionHashes).map((hash) =>\n          _eth_getTransactionReceipt(args.requestQueue, { hash }),\n        ),\n      );\n\n      if (isKilled) return;\n\n      await args.syncStore.insertTransactionReceipts({\n        transactionReceipts,\n        chainId: args.network.chainId,\n      });\n    }\n  };\n\n  const syncBlockFilter = async (filter: BlockFilter, interval: Interval) => {\n    const baseOffset = (interval[0] - filter.offset) % filter.interval;\n    const offset = baseOffset === 0 ? 0 : filter.interval - baseOffset;\n\n    // Determine which blocks are matched by the block filter.\n    const requiredBlocks: number[] = [];\n    for (let b = interval[0] + offset; b <= interval[1]; b += filter.interval) {\n      requiredBlocks.push(b);\n    }\n\n    await Promise.all(requiredBlocks.map((b) => syncBlock(BigInt(b))));\n  };\n\n  const syncTraceFilter = async (\n    filter: CallTraceFilter,\n    interval: Interval,\n  ) => {\n    // Resolve `filter.toAddress`\n    let toAddress: Address[] | undefined;\n    if (isAddressFactory(filter.toAddress)) {\n      const childAddresses = await syncAddress(filter.toAddress, interval);\n      if (\n        childAddresses.length < args.common.options.factoryAddressCountThreshold\n      ) {\n        toAddress = childAddresses;\n      } else {\n        toAddress = undefined;\n      }\n    } else {\n      toAddress = filter.toAddress;\n    }\n\n    if (isKilled) return;\n\n    let callTraces = await _trace_filter(args.requestQueue, {\n      fromAddress: filter.fromAddress,\n      toAddress,\n      fromBlock: interval[0],\n      toBlock: interval[1],\n    }).then(\n      (traces) =>\n        traces.flat().filter((t) => t.type === \"call\") as SyncCallTrace[],\n    );\n\n    if (isKilled) return;\n\n    const blocks = await Promise.all(\n      callTraces.map((trace) => syncBlock(hexToBigInt(trace.blockNumber))),\n    );\n\n    const transactionHashes = new Set(callTraces.map((t) => t.transactionHash));\n\n    // Validate that traces point to the valid transaction hash in the block\n    for (let i = 0; i < callTraces.length; i++) {\n      const callTrace = callTraces[i]!;\n      const block = blocks[i]!;\n\n      if (block.hash !== callTrace.blockHash) {\n        throw new Error(\n          `Detected inconsistent RPC responses. 'trace.blockHash' ${callTrace.blockHash} does not match 'block.hash' ${block.hash}`,\n        );\n      }\n\n      if (\n        block.transactions.find((t) => t.hash === callTrace.transactionHash) ===\n        undefined\n      ) {\n        throw new Error(\n          `Detected inconsistent RPC responses. 'trace.transactionHash' ${callTrace.transactionHash} not found in 'block.transactions' ${block.hash}`,\n        );\n      }\n    }\n\n    // Request transactionReceipts to check for reverted transactions.\n    const transactionReceipts = await Promise.all(\n      Array.from(transactionHashes).map((hash) =>\n        _eth_getTransactionReceipt(args.requestQueue, {\n          hash,\n        }),\n      ),\n    );\n\n    const revertedTransactions = new Set<Hash>();\n    for (const receipt of transactionReceipts) {\n      if (receipt.status === \"0x0\") {\n        revertedTransactions.add(receipt.transactionHash);\n      }\n    }\n\n    callTraces = callTraces.filter(\n      (trace) => revertedTransactions.has(trace.transactionHash) === false,\n    );\n\n    if (isKilled) return;\n\n    for (const hash of transactionHashes) {\n      if (revertedTransactions.has(hash) === false) {\n        transactionsCache.add(hash);\n      }\n    }\n\n    if (isKilled) return;\n\n    await args.syncStore.insertCallTraces({\n      callTraces: callTraces.map((callTrace, i) => ({\n        callTrace,\n        block: blocks[i]!,\n      })),\n      chainId: args.network.chainId,\n    });\n  };\n\n  /** Extract and insert the log-based addresses that match `filter` + `interval`. */\n  const syncLogFactory = async (filter: LogFactory, interval: Interval) => {\n    const logs = await getLogsDynamic({\n      filter,\n      interval,\n      address: filter.address,\n    });\n\n    if (isKilled) return;\n\n    // Insert `logs` into the sync-store\n    await args.syncStore.insertLogs({\n      logs: logs.map((log) => ({ log })),\n      shouldUpdateCheckpoint: false,\n      chainId: args.network.chainId,\n    });\n  };\n\n  /**\n   * Extract block, using `blockCache` to avoid fetching\n   * the same block twice. Also, update `latestBlock`.\n   *\n   * @param number Block to be extracted\n   * @param transactionHashes Hashes to be inserted into the sync-store\n   *\n   * Note: This function could more accurately skip network requests by taking\n   * advantage of `syncStore.hasBlock` and `syncStore.hasTransaction`.\n   */\n  const syncBlock = async (number: bigint): Promise<SyncBlock> => {\n    let block: SyncBlock;\n\n    /**\n     * `blockCache` contains all blocks that have been extracted during the\n     * current call to `sync()`. If `number` is present in `blockCache` use it,\n     * otherwise, request the block and add it to `blockCache` and the sync-store.\n     */\n\n    if (blockCache.has(number)) {\n      block = await blockCache.get(number)!;\n    } else {\n      const _block = _eth_getBlockByNumber(args.requestQueue, {\n        blockNumber: toHex(number),\n      });\n      blockCache.set(number, _block);\n      block = await _block;\n\n      // Update `latestBlock` if `block` is closer to tip.\n      if (\n        hexToBigInt(block.number) >= hexToBigInt(latestBlock?.number ?? \"0x0\")\n      ) {\n        latestBlock = block;\n      }\n    }\n\n    return block;\n  };\n\n  /**\n   * Return all addresses that match `filter` after extracting addresses\n   * that match `filter` and `interval`.\n   */\n  const syncAddress = async (\n    filter: Factory,\n    interval: Interval,\n  ): Promise<Address[]> => {\n    await syncLogFactory(filter, interval);\n\n    // Query the sync-store for all addresses that match `filter`.\n    return await args.syncStore.getChildAddresses({\n      filter,\n      limit: args.common.options.factoryAddressCountThreshold,\n    });\n  };\n\n  return {\n    intervalsCache,\n    async sync(_interval) {\n      const syncedIntervals: { filter: Filter; interval: Interval }[] = [];\n\n      await Promise.all(\n        args.sources.map(async (source) => {\n          // Compute the required interval to sync, accounting for cached\n          // intervals and start + end block.\n\n          // Skip sync if the interval is after the `toBlock` or before\n          // the `fromBlock`.\n          if (\n            source.filter.fromBlock > _interval[1] ||\n            (source.filter.toBlock && source.filter.toBlock < _interval[0])\n          ) {\n            return;\n          }\n          const interval: Interval = [\n            Math.max(source.filter.fromBlock, _interval[0]),\n            Math.min(\n              source.filter.toBlock ?? Number.POSITIVE_INFINITY,\n              _interval[1],\n            ),\n          ];\n          const completedIntervals = intervalsCache.get(source.filter)!;\n          const requiredIntervals = intervalDifference(\n            [interval],\n            completedIntervals,\n          );\n\n          // Skip sync if the interval is already complete.\n          if (requiredIntervals.length === 0) return;\n\n          // Request last block of interval\n          const blockPromise = syncBlock(BigInt(interval[1]));\n\n          try {\n            // sync required intervals, account for chunk sizes\n            await Promise.all(\n              requiredIntervals.map(async (interval) => {\n                if (source.type === \"contract\") {\n                  const filter = source.filter;\n                  switch (filter.type) {\n                    case \"log\": {\n                      await syncLogFilter(filter, interval);\n                      break;\n                    }\n\n                    case \"callTrace\":\n                      await Promise.all(\n                        getChunks({ interval, maxChunkSize: 10 }).map(\n                          async (interval) => {\n                            await syncTraceFilter(filter, interval);\n                          },\n                        ),\n                      );\n                      break;\n\n                    default:\n                      never(filter);\n                  }\n                } else {\n                  await syncBlockFilter(source.filter, interval);\n                }\n              }),\n            );\n          } catch (_error) {\n            const error = _error as Error;\n\n            args.common.logger.error({\n              service: \"sync\",\n              msg: `Fatal error: Unable to sync '${args.network.name}' from ${interval[0]} to ${interval[1]}.`,\n              error,\n            });\n\n            args.onFatalError(error);\n\n            return;\n          }\n\n          if (isKilled) return;\n\n          await blockPromise;\n\n          syncedIntervals.push({ filter: source.filter, interval });\n        }),\n      );\n\n      const blocks = await Promise.all(blockCache.values());\n\n      await Promise.all([\n        args.syncStore.insertBlocks({ blocks, chainId: args.network.chainId }),\n        args.syncStore.insertTransactions({\n          transactions: blocks.flatMap(({ transactions }) =>\n            transactions.filter(({ hash }) => transactionsCache.has(hash)),\n          ),\n          chainId: args.network.chainId,\n        }),\n      ]);\n\n      // Add corresponding intervals to the sync-store\n      // Note: this should happen after so the database doesn't become corrupted\n      await Promise.all(\n        syncedIntervals.map(({ filter, interval }) =>\n          args.syncStore.insertInterval({\n            filter,\n            interval,\n          }),\n        ),\n      );\n\n      blockCache.clear();\n      transactionsCache.clear();\n\n      return latestBlock;\n    },\n    kill() {\n      isKilled = true;\n    },\n  };\n};\n","/**\n * Generates an array of integers between two bounds. Exclusive on the right.\n *\n * @param start Integer to start at.\n * @param stop Integer to stop at (exclusive).\n */\nexport const range = (start: number, stop: number) =>\n  Array.from({ length: stop - start }, (_, i) => start + i);\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport { type SyncProgress, syncBlockToLightBlock } from \"@/sync/index.js\";\nimport {\n  type BlockFilter,\n  type CallTraceFilter,\n  type Factory,\n  type Filter,\n  type LogFilter,\n  type Source,\n  getChildAddress,\n  isAddressFactory,\n} from \"@/sync/source.js\";\nimport type {\n  LightBlock,\n  SyncBlock,\n  SyncCallTrace,\n  SyncLog,\n  SyncTransaction,\n  SyncTransactionReceipt,\n} from \"@/types/sync.js\";\nimport { range } from \"@/utils/range.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport {\n  _eth_getBlockByHash,\n  _eth_getBlockByNumber,\n  _eth_getLogs,\n  _eth_getTransactionReceipt,\n  _trace_block,\n} from \"@/utils/rpc.js\";\nimport { wait } from \"@/utils/wait.js\";\nimport { type Queue, createQueue } from \"@ponder/common\";\nimport { type Address, type Hash, hexToNumber } from \"viem\";\nimport { isFilterInBloom, zeroLogsBloom } from \"./bloom.js\";\nimport {\n  isBlockFilterMatched,\n  isCallTraceFilterMatched,\n  isLogFactoryMatched,\n  isLogFilterMatched,\n} from \"./filter.js\";\n\nexport type RealtimeSync = {\n  start(args: {\n    syncProgress: Pick<SyncProgress, \"finalized\">;\n    initialChildAddresses: Map<Factory, Set<Address>>;\n  }): Promise<Queue<void, BlockWithEventData>>;\n  kill(): Promise<void>;\n  unfinalizedBlocks: LightBlock[];\n  finalizedChildAddresses: Map<Factory, Set<Address>>;\n  unfinalizedChildAddresses: Map<Factory, Set<Address>>;\n};\n\ntype CreateRealtimeSyncParameters = {\n  common: Common;\n  network: Network;\n  requestQueue: RequestQueue;\n  sources: Source[];\n  onEvent: (event: RealtimeSyncEvent) => Promise<void>;\n  onFatalError: (error: Error) => void;\n};\n\nexport type BlockWithEventData = {\n  block: SyncBlock;\n  filters: Set<Filter>;\n  logs: SyncLog[];\n  factoryLogs: SyncLog[];\n  callTraces: SyncCallTrace[];\n  transactions: SyncTransaction[];\n  transactionReceipts: SyncTransactionReceipt[];\n};\n\nexport type RealtimeSyncEvent =\n  | ({\n      type: \"block\";\n    } & BlockWithEventData)\n  | {\n      type: \"finalize\";\n      block: LightBlock;\n    }\n  | {\n      type: \"reorg\";\n      block: LightBlock;\n      reorgedBlocks: LightBlock[];\n    };\n\nconst ERROR_TIMEOUT = [\n  1, 2, 5, 10, 30, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n] as const;\nconst MAX_QUEUED_BLOCKS = 25;\n\nexport const createRealtimeSync = (\n  args: CreateRealtimeSyncParameters,\n): RealtimeSync => {\n  ////////\n  // state\n  ////////\n  let isKilled = false;\n  let finalizedBlock: LightBlock;\n  let finalizedChildAddresses: Map<Factory, Set<Address>>;\n  const unfinalizedChildAddresses = new Map<Factory, Set<Address>>();\n  const factoryLogsPerBlock = new Map<Hash, SyncLog[]>();\n  /**\n   * Blocks that have been ingested and are\n   * waiting to be finalized. It is an invariant that\n   * all blocks are linked to each other,\n   * `parentHash` => `hash`.\n   */\n  let unfinalizedBlocks: LightBlock[] = [];\n  let queue: Queue<void, Omit<BlockWithEventData, \"filters\">>;\n  let consecutiveErrors = 0;\n  let interval: NodeJS.Timeout | undefined;\n\n  const factories: Factory[] = [];\n  const logFilters: LogFilter[] = [];\n  const callTraceFilters: CallTraceFilter[] = [];\n  const blockFilters: BlockFilter[] = [];\n\n  for (const source of args.sources) {\n    if (source.type === \"contract\") {\n      if (source.filter.type === \"log\") {\n        logFilters.push(source.filter);\n      } else if (source.filter.type === \"callTrace\") {\n        callTraceFilters.push(source.filter);\n      }\n\n      const _address =\n        source.filter.type === \"log\"\n          ? source.filter.address\n          : source.filter.toAddress;\n      if (isAddressFactory(_address)) {\n        factories.push(_address);\n      }\n    } else if (source.type === \"block\") {\n      blockFilters.push(source.filter);\n    }\n  }\n\n  for (const factory of factories) {\n    unfinalizedChildAddresses.set(factory, new Set());\n  }\n\n  /**\n   * 1) Determine if a reorg occurred.\n   * 2) Insert new event data into the store.\n   * 3) Determine if a new range of events has become finalized,\n   *    if so insert interval to store and remove the finalized data.\n   *\n   * @param block Block to be injested. Must be exactly\n   * 1 block ahead of the local chain.\n   * @returns true if a reorg occurred\n   */\n  const handleBlock = async ({\n    block,\n    logs,\n    factoryLogs,\n    callTraces,\n    transactions,\n    transactionReceipts,\n  }: Omit<BlockWithEventData, \"filters\">) => {\n    args.common.logger.debug({\n      service: \"realtime\",\n      msg: `Started syncing '${args.network.name}' block ${hexToNumber(block.number)}`,\n    });\n\n    // Update `unfinalizedChildAddresses`\n    for (const log of factoryLogs) {\n      for (const filter of factories) {\n        if (isLogFactoryMatched({ filter, log })) {\n          unfinalizedChildAddresses\n            .get(filter)!\n            .add(getChildAddress({ log, factory: filter }));\n        }\n      }\n    }\n\n    /**\n     * `logs` and `callTraces` must be filtered again (already filtered in `extract`)\n     *  because `extract` doesn't have factory address information.\n     */\n\n    const matchedFilters = new Set<Filter>();\n\n    // Remove logs that don't match a filter, accounting for factory addresses\n    logs = logs.filter((log) => {\n      let isMatched = false;\n\n      for (const filter of logFilters) {\n        if (\n          isLogFilterMatched({ filter, block, log }) &&\n          (isAddressFactory(filter.address)\n            ? finalizedChildAddresses\n                .get(filter.address)!\n                .has(log.address.toLowerCase() as Address) ||\n              unfinalizedChildAddresses\n                .get(filter.address)!\n                .has(log.address.toLowerCase() as Address)\n            : true)\n        ) {\n          matchedFilters.add(filter);\n          isMatched = true;\n        }\n      }\n\n      return isMatched;\n    });\n\n    // Remove call traces that don't match a filter, accounting for factory addresses\n    callTraces = callTraces.filter((callTrace) => {\n      let isMatched = false;\n\n      for (const filter of callTraceFilters) {\n        if (\n          isCallTraceFilterMatched({ filter, block, callTrace }) &&\n          (isAddressFactory(filter.toAddress)\n            ? finalizedChildAddresses\n                .get(filter.toAddress)!\n                .has(callTrace.action.to.toLowerCase() as Address) ||\n              unfinalizedChildAddresses\n                .get(filter.toAddress)!\n                .has(callTrace.action.to.toLowerCase() as Address)\n            : true)\n        ) {\n          matchedFilters.add(filter);\n          isMatched = true;\n        }\n      }\n\n      return isMatched;\n    });\n\n    // Remove transactions and transaction receipts that may have been filtered out\n    const transactionHashes = new Set<Hash>();\n    for (const log of logs) {\n      transactionHashes.add(log.transactionHash);\n    }\n    for (const trace of callTraces) {\n      transactionHashes.add(trace.transactionHash);\n    }\n\n    transactions = transactions.filter((t) => transactionHashes.has(t.hash));\n    transactionReceipts = transactionReceipts.filter((t) =>\n      transactionHashes.has(t.transactionHash),\n    );\n\n    // Record matched block filters\n    for (const filter of blockFilters) {\n      if (isBlockFilterMatched({ filter, block })) {\n        matchedFilters.add(filter);\n      }\n    }\n\n    if (logs.length > 0 || callTraces.length > 0) {\n      const _text: string[] = [];\n\n      if (logs.length === 1) {\n        _text.push(\"1 log\");\n      } else if (logs.length > 1) {\n        _text.push(`${logs.length} logs`);\n      }\n\n      if (callTraces.length === 1) {\n        _text.push(\"1 call trace\");\n      } else if (callTraces.length > 1) {\n        _text.push(`${callTraces.length} call traces`);\n      }\n\n      const text = _text.filter((t) => t !== undefined).join(\" and \");\n      args.common.logger.info({\n        service: \"realtime\",\n        msg: `Synced ${text} from '${args.network.name}' block ${hexToNumber(block.number)}`,\n      });\n    } else {\n      args.common.logger.info({\n        service: \"realtime\",\n        msg: `Synced block ${hexToNumber(block.number)} from '${args.network.name}' `,\n      });\n    }\n\n    unfinalizedBlocks.push(syncBlockToLightBlock(block));\n\n    // Make sure `transactions` can be garbage collected\n    // @ts-ignore\n    block.transactions = undefined;\n\n    await args.onEvent({\n      type: \"block\",\n      filters: matchedFilters,\n      block,\n      factoryLogs,\n      logs,\n      callTraces,\n      transactions,\n      transactionReceipts,\n    });\n\n    // Determine if a new range has become finalized by evaluating if the\n    // latest block number is 2 * finalityBlockCount >= finalized block number.\n    // Essentially, there is a range the width of finalityBlockCount that is entirely\n    // finalized.\n    const blockMovesFinality =\n      hexToNumber(block.number) >=\n      hexToNumber(finalizedBlock.number) + 2 * args.network.finalityBlockCount;\n    if (blockMovesFinality) {\n      const pendingFinalizedBlock = unfinalizedBlocks.find(\n        (lb) =>\n          hexToNumber(lb.number) ===\n          hexToNumber(block.number) - args.network.finalityBlockCount,\n      )!;\n\n      args.common.logger.debug({\n        service: \"realtime\",\n        msg: `Finalized ${hexToNumber(pendingFinalizedBlock.number) - hexToNumber(finalizedBlock.number) + 1} '${\n          args.network.name\n        }' blocks from ${hexToNumber(finalizedBlock.number) + 1} to ${hexToNumber(pendingFinalizedBlock.number)}`,\n      });\n\n      const finalizedBlocks = unfinalizedBlocks.filter(\n        (lb) =>\n          hexToNumber(lb.number) <= hexToNumber(pendingFinalizedBlock.number),\n      );\n\n      unfinalizedBlocks = unfinalizedBlocks.filter(\n        (lb) =>\n          hexToNumber(lb.number) > hexToNumber(pendingFinalizedBlock.number),\n      );\n\n      // add child address from newly finalized blocks to `finalizedChildAddresses`\n      for (const filter of factories) {\n        for (const { hash } of finalizedBlocks) {\n          const factoryLogs = factoryLogsPerBlock.get(hash);\n          if (factoryLogs !== undefined) {\n            for (const log of factoryLogs) {\n              if (isLogFactoryMatched({ filter, log })) {\n                finalizedChildAddresses\n                  .get(filter)!\n                  .add(getChildAddress({ log, factory: filter }));\n              }\n            }\n          }\n        }\n      }\n\n      // recompute `unfinalizedChildAddresses`\n      unfinalizedChildAddresses.clear();\n\n      for (const filter of factories) {\n        unfinalizedChildAddresses.set(filter, new Set());\n        for (const { hash } of unfinalizedBlocks) {\n          const factoryLogs = factoryLogsPerBlock.get(hash);\n          if (factoryLogs !== undefined) {\n            for (const log of factoryLogs) {\n              if (isLogFactoryMatched({ filter, log })) {\n                unfinalizedChildAddresses\n                  .get(filter)!\n                  .add(getChildAddress({ log, factory: filter }));\n              }\n            }\n          }\n        }\n      }\n\n      // delete finalized blocks from `factoryLogsPerBlock`\n      for (const { hash } of finalizedBlocks) {\n        factoryLogsPerBlock.delete(hash);\n      }\n\n      finalizedBlock = pendingFinalizedBlock;\n\n      await args.onEvent({ type: \"finalize\", block: pendingFinalizedBlock });\n    }\n\n    args.common.logger.debug({\n      service: \"realtime\",\n      msg: `Finished syncing '${args.network.name}' block ${hexToNumber(block.number)}`,\n    });\n  };\n\n  /**\n   * Traverse the remote chain until we find a block that is\n   * compatible with out local chain.\n   *\n   * @param block Block that caused reorg to be detected.\n   * Must be at most 1 block ahead of the local chain.\n   */\n  const handleReorg = async (block: SyncBlock) => {\n    args.common.logger.warn({\n      service: \"realtime\",\n      msg: `Detected forked '${args.network.name}' block at height ${hexToNumber(block.number)}`,\n    });\n\n    // Record blocks that have been removed from the local chain.\n    const reorgedBlocks = unfinalizedBlocks.filter(\n      (lb) => hexToNumber(lb.number) >= hexToNumber(block.number),\n    );\n\n    // Prune the local chain of blocks that have been reorged out\n    unfinalizedBlocks = unfinalizedBlocks.filter(\n      (lb) => hexToNumber(lb.number) < hexToNumber(block.number),\n    );\n\n    // Block we are attempting to fit into the local chain.\n    let remoteBlock = block;\n\n    while (true) {\n      const parentBlock = getLatestUnfinalizedBlock();\n\n      if (parentBlock.hash === remoteBlock.parentHash) break;\n\n      if (unfinalizedBlocks.length === 0) {\n        // No compatible block was found in the local chain, must be a deep reorg.\n\n        const msg = `Encountered unrecoverable '${args.network.name}' reorg beyond finalized block ${hexToNumber(finalizedBlock.number)}`;\n\n        args.common.logger.warn({ service: \"realtime\", msg });\n\n        throw new Error(msg);\n      } else {\n        remoteBlock = await _eth_getBlockByHash(args.requestQueue, {\n          hash: remoteBlock.parentHash,\n        });\n        // Add tip to `reorgedBlocks`\n        reorgedBlocks.push(unfinalizedBlocks.pop()!);\n      }\n    }\n\n    const commonAncestor = getLatestUnfinalizedBlock();\n\n    await args.onEvent({ type: \"reorg\", block: commonAncestor, reorgedBlocks });\n\n    args.common.logger.warn({\n      service: \"realtime\",\n      msg: `Reconciled ${reorgedBlocks.length}-block reorg on '${\n        args.network.name\n      }' with common ancestor block ${hexToNumber(commonAncestor.number)}`,\n    });\n\n    // recompute `unfinalizedChildAddresses`\n    unfinalizedChildAddresses.clear();\n\n    for (const filter of factories) {\n      unfinalizedChildAddresses.set(filter, new Set());\n      for (const { hash } of unfinalizedBlocks) {\n        const factoryLogs = factoryLogsPerBlock.get(hash);\n        if (factoryLogs !== undefined) {\n          for (const log of factoryLogs) {\n            if (isLogFactoryMatched({ filter, log })) {\n              unfinalizedChildAddresses\n                .get(filter)!\n                .add(getChildAddress({ log, factory: filter }));\n            }\n          }\n        }\n      }\n    }\n\n    // delete reorged blocks from `factoryLogsPerBlock`\n    for (const { hash } of reorgedBlocks) {\n      factoryLogsPerBlock.delete(hash);\n    }\n  };\n\n  /**\n   * Fetch all data (logs, traces, receipts) for the specified block required by `args.sources`\n   *\n   * Note: The data returned by this function may include false positives. This\n   * is due to the fact that factory addresses are unknown and are always\n   * treated as \"matched\".\n   */\n  const fetchBlockEventData = async (\n    block: SyncBlock,\n  ): Promise<Omit<BlockWithEventData, \"filters\">> => {\n    ////////\n    // Logs\n    ////////\n\n    // \"eth_getLogs\" calls can be skipped if no filters match `newHeadBlock.logsBloom`.\n    const shouldRequestLogs =\n      block.logsBloom === zeroLogsBloom ||\n      logFilters.some((filter) => isFilterInBloom({ block, filter }));\n\n    let logs: SyncLog[] = [];\n    if (shouldRequestLogs) {\n      logs = await _eth_getLogs(args.requestQueue, { blockHash: block.hash });\n\n      // Protect against RPCs returning empty logs. Known to happen near chain tip.\n      if (block.logsBloom !== zeroLogsBloom && logs.length === 0) {\n        throw new Error(\n          \"Detected invalid eth_getLogs response. `block.logsBloom` is not empty but zero logs were returned.\",\n        );\n      }\n\n      // Check that logs refer to the correct block\n      for (const log of logs) {\n        if (log.blockHash !== block.hash) {\n          throw new Error(\n            `Detected invalid eth_getLogs response. 'log.blockHash' ${log.blockHash} does not match requested block hash ${block.hash}`,\n          );\n        }\n      }\n    }\n\n    if (\n      shouldRequestLogs === false &&\n      args.sources.some((s) => s.filter.type === \"log\")\n    ) {\n      args.common.logger.debug({\n        service: \"realtime\",\n        msg: `Skipped fetching logs for '${args.network.name}' block ${hexToNumber(block.number)} due to bloom filter result`,\n      });\n    }\n\n    ////////\n    // Traces\n    ////////\n\n    const shouldRequestTraces = callTraceFilters.length > 0;\n\n    let callTraces: SyncCallTrace[] = [];\n    if (shouldRequestTraces) {\n      const traces = await _trace_block(args.requestQueue, {\n        blockNumber: hexToNumber(block.number),\n      });\n\n      // Protect against RPCs returning empty traces. Known to happen near chain tip.\n      // Use the fact that any transaction produces a trace.\n      if (block.transactions.length !== 0 && traces.length === 0) {\n        throw new Error(\n          \"Detected invalid trace_block response. `block.transactions` is not empty but zero traces were returned.\",\n        );\n      }\n\n      callTraces = traces.filter(\n        (trace) => trace.type === \"call\",\n      ) as SyncCallTrace[];\n    }\n\n    // Check that traces refer to the correct block\n    for (const trace of callTraces) {\n      if (trace.blockHash !== block.hash) {\n        throw new Error(\n          `Detected inconsistent RPC responses. 'trace.blockHash' ${trace.blockHash} does not match 'block.hash' ${block.hash}`,\n        );\n      }\n    }\n\n    ////////\n    // Get Matched\n    ////////\n\n    // Record `logs` that contain factory child addresses\n    const factoryLogs = logs.filter((log) => {\n      let isMatched = false;\n\n      for (const filter of factories) {\n        if (isLogFactoryMatched({ filter, log })) {\n          if (factoryLogsPerBlock.has(block.hash) === false) {\n            factoryLogsPerBlock.set(block.hash, []);\n          }\n\n          factoryLogsPerBlock.get(block.hash)!.push(log);\n\n          isMatched = true;\n        }\n      }\n\n      return isMatched;\n    });\n\n    const requiredTransactions = new Set<Hash>();\n    const requiredTransactionReceipts = new Set<Hash>();\n\n    // Remove logs that don't match a filter, recording required transactions\n    logs = logs.filter((log) => {\n      let isLogMatched = false;\n\n      for (const filter of logFilters) {\n        if (isLogFilterMatched({ filter, block, log })) {\n          isLogMatched = true;\n          requiredTransactions.add(log.transactionHash);\n          if (filter.includeTransactionReceipts) {\n            requiredTransactionReceipts.add(log.transactionHash);\n          }\n        }\n      }\n\n      return isLogMatched;\n    });\n\n    // Remove call traces that don't match a filter, recording required transactions\n    callTraces = callTraces.filter((callTrace) => {\n      let isCallTraceMatched = false;\n      for (const filter of callTraceFilters) {\n        if (isCallTraceFilterMatched({ filter, block, callTrace })) {\n          isCallTraceMatched = true;\n          requiredTransactions.add(callTrace.transactionHash);\n          if (filter.includeTransactionReceipts) {\n            requiredTransactionReceipts.add(callTrace.transactionHash);\n          }\n        }\n      }\n\n      return isCallTraceMatched;\n    });\n\n    ////////\n    // Transactions\n    ////////\n\n    const transactions = block.transactions.filter(({ hash }) =>\n      requiredTransactions.has(hash),\n    );\n\n    // Validate that filtered logs/callTraces point to valid transaction in the block\n    const blockTransactionsHashes = new Set(\n      block.transactions.map((t) => t.hash),\n    );\n    for (const hash of Array.from(requiredTransactions)) {\n      if (blockTransactionsHashes.has(hash) === false) {\n        throw new Error(\n          `Detected inconsistent RPC responses. Transaction with hash ${hash} is missing in \\`block.transactions\\`.`,\n        );\n      }\n    }\n\n    ////////\n    // Transaction Receipts\n    ////////\n\n    const transactionReceipts = await Promise.all(\n      block.transactions\n        .filter(({ hash }) => requiredTransactionReceipts.has(hash))\n        .map(({ hash }) =>\n          _eth_getTransactionReceipt(args.requestQueue, { hash }),\n        ),\n    );\n\n    // Filter out call traces from reverted transactions\n\n    const revertedTransactions = new Set<Hash>();\n    for (const receipt of transactionReceipts) {\n      if (receipt.status === \"0x0\") {\n        revertedTransactions.add(receipt.transactionHash);\n      }\n    }\n\n    callTraces = callTraces.filter(\n      (trace) => revertedTransactions.has(trace.transactionHash) === false,\n    );\n\n    return {\n      block,\n      logs,\n      factoryLogs,\n      callTraces,\n      transactions,\n      transactionReceipts,\n    };\n  };\n\n  const getLatestUnfinalizedBlock = () => {\n    if (unfinalizedBlocks.length === 0) {\n      return finalizedBlock;\n    } else return unfinalizedBlocks[unfinalizedBlocks.length - 1]!;\n  };\n\n  return {\n    start(startArgs) {\n      finalizedBlock = startArgs.syncProgress.finalized;\n      finalizedChildAddresses = startArgs.initialChildAddresses;\n      /**\n       * The queue reacts to a new block. The four states are:\n       * 1) Block is the same as the one just processed, no-op.\n       * 2) Block is exactly one block ahead of the last processed,\n       *    handle this new block (happy path).\n       * 3) Block is more than one ahead of the last processed,\n       *    fetch all intermediate blocks and enqueue them again.\n       * 4) Block is behind the last processed. This is a sign that\n       *    a reorg has occurred.\n       */\n      queue = createQueue({\n        browser: false,\n        concurrency: 1,\n        initialStart: true,\n        worker: async ({ block, ...rest }) => {\n          const latestBlock = getLatestUnfinalizedBlock();\n\n          // We already saw and handled this block. No-op.\n          if (latestBlock.hash === block.hash) {\n            args.common.logger.trace({\n              service: \"realtime\",\n              msg: `Skipped processing '${args.network.name}' block ${hexToNumber(block.number)}, already synced`,\n            });\n\n            return;\n          }\n\n          try {\n            // Quickly check for a reorg by comparing block numbers. If the block\n            // number has not increased, a reorg must have occurred.\n            if (hexToNumber(latestBlock.number) >= hexToNumber(block.number)) {\n              await handleReorg(block);\n\n              queue.clear();\n              return;\n            }\n\n            // Blocks are missing. They should be fetched and enqueued.\n            if (\n              hexToNumber(latestBlock.number) + 1 <\n              hexToNumber(block.number)\n            ) {\n              // Retrieve missing blocks, but only fetch a certain amount.\n              const missingBlockRange = range(\n                hexToNumber(latestBlock.number) + 1,\n                Math.min(\n                  hexToNumber(block.number),\n                  hexToNumber(latestBlock.number) + MAX_QUEUED_BLOCKS,\n                ),\n              );\n              const pendingBlocks = await Promise.all(\n                missingBlockRange.map((blockNumber) =>\n                  _eth_getBlockByNumber(args.requestQueue, {\n                    blockNumber,\n                  }).then((block) => fetchBlockEventData(block)),\n                ),\n              );\n\n              args.common.logger.debug({\n                service: \"realtime\",\n                msg: `Fetched ${missingBlockRange.length} missing '${\n                  args.network.name\n                }' blocks from ${hexToNumber(latestBlock.number) + 1} to ${Math.min(\n                  hexToNumber(block.number),\n                  hexToNumber(latestBlock.number) + MAX_QUEUED_BLOCKS,\n                )}`,\n              });\n\n              // This is needed to ensure proper `kill()` behavior. When the service\n              // is killed, nothing should be added to the queue, or else `onIdle()`\n              // will never resolve.\n              if (isKilled) return;\n\n              queue.clear();\n\n              for (const pendingBlock of pendingBlocks) {\n                queue.add(pendingBlock);\n              }\n\n              queue.add({ block, ...rest });\n\n              return;\n            }\n\n            // Check if a reorg occurred by validating the chain of block hashes.\n            if (block.parentHash !== latestBlock.hash) {\n              await handleReorg(block);\n              queue.clear();\n              return;\n            }\n\n            // New block is exactly one block ahead of the local chain.\n            // Attempt to ingest it.\n            await handleBlock({ block, ...rest });\n\n            // Reset the error state after successfully completing the happy path.\n            consecutiveErrors = 0;\n\n            return;\n          } catch (_error) {\n            if (isKilled) return;\n\n            const error = _error as Error;\n            error.stack = undefined;\n\n            args.common.logger.warn({\n              service: \"realtime\",\n              msg: `Failed to process '${args.network.name}' block ${hexToNumber(block.number)}`,\n              error,\n            });\n\n            const duration = ERROR_TIMEOUT[consecutiveErrors]!;\n\n            args.common.logger.warn({\n              service: \"realtime\",\n              msg: `Retrying '${args.network.name}' sync after ${duration} ${\n                duration === 1 ? \"second\" : \"seconds\"\n              }.`,\n            });\n\n            await wait(duration * 1_000);\n\n            // Remove all blocks from the queue. This protects against an\n            // erroneous block causing a fatal error.\n            queue.clear();\n\n            // After a certain number of attempts, emit a fatal error.\n            if (++consecutiveErrors === ERROR_TIMEOUT.length) {\n              args.common.logger.error({\n                service: \"realtime\",\n                msg: `Fatal error: Unable to process '${args.network.name}' block ${hexToNumber(block.number)} after ${ERROR_TIMEOUT.length} attempts.`,\n                error,\n              });\n\n              args.onFatalError(error);\n            }\n          }\n        },\n      });\n\n      const enqueue = async () => {\n        try {\n          const block = await _eth_getBlockByNumber(args.requestQueue, {\n            blockTag: \"latest\",\n          });\n\n          const latestBlock = getLatestUnfinalizedBlock();\n\n          // We already saw and handled this block. No-op.\n          if (latestBlock.hash === block.hash) {\n            args.common.logger.trace({\n              service: \"realtime\",\n              msg: `Skipped processing '${args.network.name}' block ${hexToNumber(block.number)}, already synced`,\n            });\n\n            return;\n          }\n\n          const blockWithEventData = await fetchBlockEventData(block);\n\n          consecutiveErrors = 0;\n\n          return queue.add(blockWithEventData);\n        } catch (_error) {\n          if (isKilled) return;\n\n          const error = _error as Error;\n\n          args.common.logger.warn({\n            service: \"realtime\",\n            msg: `Failed to fetch latest '${args.network.name}' block`,\n            error,\n          });\n\n          // After a certain number of attempts, emit a fatal error.\n          if (++consecutiveErrors === ERROR_TIMEOUT.length) {\n            args.common.logger.error({\n              service: \"realtime\",\n              msg: `Fatal error: Unable to fetch latest '${args.network.name}' block after ${ERROR_TIMEOUT.length} attempts.`,\n              error,\n            });\n\n            args.onFatalError(error);\n          }\n        }\n      };\n\n      interval = setInterval(enqueue, args.network.pollingInterval);\n\n      // Note: this is done just for testing.\n      return enqueue().then(() => queue);\n    },\n    async kill() {\n      clearInterval(interval);\n      isKilled = true;\n      queue?.pause();\n      queue?.clear();\n      await queue?.onIdle();\n    },\n    get unfinalizedBlocks() {\n      return unfinalizedBlocks;\n    },\n    get finalizedChildAddresses() {\n      return finalizedChildAddresses;\n    },\n    get unfinalizedChildAddresses() {\n      return unfinalizedChildAddresses;\n    },\n  };\n};\n","import { type LogFilter, isAddressFactory } from \"@/sync/source.js\";\nimport type { SyncBlock } from \"@/types/sync.js\";\nimport { type Hex, hexToBytes, hexToNumber, keccak256 } from \"viem\";\n\nexport const zeroLogsBloom =\n  \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n\nconst BLOOM_SIZE_BYTES = 256;\n\nexport const isInBloom = (_bloom: Hex, input: Hex): boolean => {\n  const bloom = hexToBytes(_bloom);\n  const hash = hexToBytes(keccak256(input));\n\n  for (const i of [0, 2, 4]) {\n    const bit = (hash[i + 1]! + (hash[i]! << 8)) & 0x7ff;\n    if (\n      (bloom[BLOOM_SIZE_BYTES - 1 - Math.floor(bit / 8)]! &\n        (1 << (bit % 8))) ===\n      0\n    )\n      return false;\n  }\n\n  return true;\n};\n\n/**\n * Return true if `filter` is in `bloom`.\n *\n * A filter with an address of type `LogFactory` is matched\n * if the address filter is matched (new child contract) or the log\n * filter is matched (log on child contract).\n *\n * Note: False positives are possible.\n */\nexport function isFilterInBloom({\n  block,\n  filter,\n}: {\n  block: Pick<SyncBlock, \"number\" | \"logsBloom\">;\n  filter: LogFilter;\n}): boolean {\n  // Return `false` for out of range blocks\n  if (\n    hexToNumber(block.number) < filter.fromBlock ||\n    hexToNumber(block.number) > (filter.toBlock ?? Number.POSITIVE_INFINITY)\n  ) {\n    return false;\n  }\n\n  let isTopicsInBloom: boolean;\n  let isAddressInBloom: boolean;\n\n  if (filter.topics === undefined || filter.topics.length === 0) {\n    isTopicsInBloom = true;\n  } else {\n    isTopicsInBloom = filter.topics.some((topic) => {\n      if (topic === null || topic === undefined) {\n        return true;\n      } else if (Array.isArray(topic)) {\n        return topic.some((t) => isInBloom(block.logsBloom, t));\n      } else {\n        return isInBloom(block.logsBloom, topic);\n      }\n    });\n  }\n\n  if (filter.address === undefined) isAddressInBloom = true;\n  else if (isAddressFactory(filter.address)) {\n    // Return true if the `Factory` is matched.\n    if (\n      (Array.isArray(filter.address.address)\n        ? filter.address.address.some((address) =>\n            isInBloom(block.logsBloom, address),\n          )\n        : isInBloom(block.logsBloom, filter.address.address)) &&\n      isInBloom(block.logsBloom, filter.address.eventSelector)\n    ) {\n      return true;\n    }\n\n    isAddressInBloom = true;\n  } else if (Array.isArray(filter.address)) {\n    if (filter.address.length === 0) {\n      isAddressInBloom = true;\n    } else {\n      isAddressInBloom = filter.address.some((address) =>\n        isInBloom(block.logsBloom, address),\n      );\n    }\n  } else {\n    // single address case\n    isAddressInBloom = isInBloom(block.logsBloom, filter.address);\n  }\n\n  return isAddressInBloom && isTopicsInBloom;\n}\n","export const estimate = ({\n  from,\n  to,\n  target,\n  result,\n  min,\n  max,\n  prev,\n  maxIncrease,\n}: {\n  from: number;\n  to: number;\n  target: number;\n  result: number;\n  min: number;\n  max: number;\n  prev: number;\n  maxIncrease: number;\n}) => {\n  const density = (to - from) / (result || 1);\n  // min <= estimate <= prev * maxIncrease or max\n  return Math.min(\n    Math.max(min, Math.round(target * density)),\n    Math.round(prev * maxIncrease),\n    max,\n  );\n};\n","import { promiseWithResolvers } from \"@ponder/common\";\n\nexport async function* mergeAsyncGenerators<T>(\n  generators: AsyncGenerator<T>[],\n): AsyncGenerator<T> {\n  const results: T[] = [];\n  let count = generators.length;\n  let pwr = promiseWithResolvers<void>();\n\n  generators.map(async (generator) => {\n    for await (const result of generator) {\n      results.push(result);\n      pwr.resolve();\n    }\n    count--;\n    pwr.resolve();\n  });\n\n  while (count > 0 || results.length > 0) {\n    if (results.length > 0) {\n      yield results.shift()!;\n    } else {\n      await pwr.promise;\n      pwr = promiseWithResolvers<void>();\n    }\n  }\n}\n","import type { Common } from \"@/common/common.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport { type Queue, createQueue } from \"@ponder/common\";\nimport {\n  type GetLogsRetryHelperParameters,\n  getLogsRetryHelper,\n} from \"@ponder/utils\";\nimport {\n  BlockNotFoundError,\n  type EIP1193Parameters,\n  HttpRequestError,\n  InternalRpcError,\n  InvalidInputRpcError,\n  LimitExceededRpcError,\n  type PublicRpcSchema,\n  type RpcError,\n  isHex,\n} from \"viem\";\nimport { startClock } from \"./timer.js\";\nimport { wait } from \"./wait.js\";\n\ntype RequestReturnType<\n  method extends EIP1193Parameters<PublicRpcSchema>[\"method\"],\n> = Extract<PublicRpcSchema[number], { Method: method }>[\"ReturnType\"];\n\nexport type RequestQueue = Omit<\n  Queue<\n    RequestReturnType<EIP1193Parameters<PublicRpcSchema>[\"method\"]>,\n    EIP1193Parameters<PublicRpcSchema>\n  >,\n  \"add\"\n> & {\n  request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n    parameters: TParameters,\n  ) => Promise<RequestReturnType<TParameters[\"method\"]>>;\n};\n\nconst RETRY_COUNT = 9;\nconst BASE_DURATION = 125;\n\n/**\n * Creates a queue built to manage rpc requests.\n */\nexport const createRequestQueue = ({\n  network,\n  common,\n}: {\n  network: Network;\n  common: Common;\n}): RequestQueue => {\n  // @ts-ignore\n  const fetchRequest = async (request: EIP1193Parameters<PublicRpcSchema>) => {\n    for (let i = 0; i <= RETRY_COUNT; i++) {\n      try {\n        const stopClock = startClock();\n        const response = await network.transport.request(request);\n        common.metrics.ponder_rpc_request_duration.observe(\n          { method: request.method, network: network.name },\n          stopClock(),\n        );\n\n        return response;\n      } catch (_error) {\n        const error = _error as Error;\n\n        if (\n          request.method === \"eth_getLogs\" &&\n          isHex(request.params[0].fromBlock) &&\n          isHex(request.params[0].toBlock)\n        ) {\n          const getLogsErrorResponse = getLogsRetryHelper({\n            params: request.params as GetLogsRetryHelperParameters[\"params\"],\n            error: error as RpcError,\n          });\n\n          if (getLogsErrorResponse.shouldRetry === true) throw error;\n        }\n\n        if (shouldRetry(error) === false) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Failed '${request.method}' RPC request`,\n          });\n          throw error;\n        }\n\n        if (i === RETRY_COUNT) {\n          common.logger.warn({\n            service: \"sync\",\n            msg: `Failed '${request.method}' RPC request after ${i + 1} attempts`,\n            error,\n          });\n          throw error;\n        }\n\n        const duration = BASE_DURATION * 2 ** i;\n        common.logger.debug({\n          service: \"sync\",\n          msg: `Failed '${request.method}' RPC request, retrying after ${duration} milliseconds`,\n          error,\n        });\n        await wait(duration);\n      }\n    }\n  };\n\n  const requestQueue: Queue<\n    unknown,\n    {\n      request: EIP1193Parameters<PublicRpcSchema>;\n      stopClockLag: () => number;\n    }\n  > = createQueue({\n    frequency: network.maxRequestsPerSecond,\n    concurrency: Math.ceil(network.maxRequestsPerSecond / 4),\n    initialStart: true,\n    browser: false,\n    worker: async (task: {\n      request: EIP1193Parameters<PublicRpcSchema>;\n      stopClockLag: () => number;\n    }) => {\n      common.metrics.ponder_rpc_request_lag.observe(\n        { method: task.request.method, network: network.name },\n        task.stopClockLag(),\n      );\n\n      return await fetchRequest(task.request);\n    },\n  });\n\n  return {\n    ...requestQueue,\n    request: <TParameters extends EIP1193Parameters<PublicRpcSchema>>(\n      params: TParameters,\n    ) => {\n      const stopClockLag = startClock();\n\n      return requestQueue.add({ request: params, stopClockLag });\n    },\n  } as RequestQueue;\n};\n\n/**\n * @link https://github.com/wevm/viem/blob/main/src/utils/buildRequest.ts#L192\n */\nfunction shouldRetry(error: Error) {\n  if (\"code\" in error && typeof error.code === \"number\") {\n    if (error.code === -1) return true; // Unknown error\n    if (error.code === InvalidInputRpcError.code) return true;\n    if (error.code === LimitExceededRpcError.code) return true;\n    if (error.code === InternalRpcError.code) return true;\n    return false;\n  }\n  if (error instanceof BlockNotFoundError) return true;\n  if (error instanceof HttpRequestError && error.status) {\n    // Forbidden\n    if (error.status === 403) return true;\n    // Request Timeout\n    if (error.status === 408) return true;\n    // Request Entity Too Large\n    if (error.status === 413) return true;\n    // Too Many Requests\n    if (error.status === 429) return true;\n    // Internal Server Error\n    if (error.status === 500) return true;\n    // Bad Gateway\n    if (error.status === 502) return true;\n    // Service Unavailable\n    if (error.status === 503) return true;\n    // Gateway Timeout\n    if (error.status === 504) return true;\n    return false;\n  }\n  return true;\n}\n","import type { Common } from \"@/common/common.js\";\nimport { getAppProgress } from \"@/common/metrics.js\";\nimport type { Network } from \"@/config/networks.js\";\nimport {\n  type HistoricalSync,\n  createHistoricalSync,\n} from \"@/sync-historical/index.js\";\nimport {\n  type BlockWithEventData,\n  type RealtimeSync,\n  type RealtimeSyncEvent,\n  createRealtimeSync,\n} from \"@/sync-realtime/index.js\";\nimport type { SyncStore } from \"@/sync-store/index.js\";\nimport type { LightBlock, SyncBlock } from \"@/types/sync.js\";\nimport {\n  type Checkpoint,\n  decodeCheckpoint,\n  encodeCheckpoint,\n  maxCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { estimate } from \"@/utils/estimate.js\";\nimport { formatEta, formatPercentage } from \"@/utils/format.js\";\nimport { mergeAsyncGenerators } from \"@/utils/generators.js\";\nimport {\n  type Interval,\n  intervalDifference,\n  intervalIntersection,\n  intervalSum,\n  sortIntervals,\n} from \"@/utils/interval.js\";\nimport { intervalUnion } from \"@/utils/interval.js\";\nimport { never } from \"@/utils/never.js\";\nimport { type RequestQueue, createRequestQueue } from \"@/utils/requestQueue.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport {\n  type Address,\n  type Hash,\n  type Transport,\n  hexToBigInt,\n  hexToNumber,\n} from \"viem\";\nimport { _eth_getBlockByNumber } from \"../utils/rpc.js\";\nimport { type RawEvent, buildEvents } from \"./events.js\";\nimport { type Factory, type Source, isAddressFactory } from \"./source.js\";\nimport { cachedTransport } from \"./transport.js\";\n\nexport type Sync = {\n  getEvents(): AsyncGenerator<{ events: RawEvent[]; checkpoint: string }>;\n  startRealtime(): Promise<void>;\n  getStatus(): Status;\n  getStartCheckpoint(): string;\n  getFinalizedCheckpoint(): string;\n  getCachedTransport(network: Network): Transport;\n  kill(): Promise<void>;\n};\n\nexport type RealtimeEvent =\n  | {\n      type: \"block\";\n      checkpoint: string;\n      status: Status;\n      events: RawEvent[];\n    }\n  | {\n      type: \"reorg\";\n      checkpoint: string;\n    }\n  | {\n      type: \"finalize\";\n      checkpoint: string;\n    };\n\nexport type Status = {\n  [networkName: string]: {\n    block: { number: number; timestamp: number } | null;\n    ready: boolean;\n  };\n};\n\nexport type SyncProgress = {\n  start: SyncBlock | LightBlock;\n  end: SyncBlock | LightBlock | undefined;\n  cached: SyncBlock | LightBlock | undefined;\n  current: SyncBlock | LightBlock | undefined;\n  finalized: SyncBlock | LightBlock;\n};\n\nexport const syncBlockToLightBlock = ({\n  hash,\n  parentHash,\n  number,\n  timestamp,\n}: SyncBlock): LightBlock => ({\n  hash,\n  parentHash,\n  number,\n  timestamp,\n});\n\n/** Convert `block` to a `Checkpoint`. */\nexport const blockToCheckpoint = (\n  block: LightBlock | SyncBlock,\n  chainId: number,\n  rounding: \"up\" | \"down\",\n): Checkpoint => {\n  return {\n    ...(rounding === \"up\" ? maxCheckpoint : zeroCheckpoint),\n    blockTimestamp: hexToNumber(block.timestamp),\n    chainId: BigInt(chainId),\n    blockNumber: hexToBigInt(block.number),\n  };\n};\n\n/**\n * Returns true if all filters have a defined end block and the current\n * sync progress has reached the final end block.\n */\nconst isSyncEnd = (syncProgress: SyncProgress) => {\n  if (syncProgress.end === undefined || syncProgress.current === undefined) {\n    return false;\n  }\n\n  return (\n    hexToNumber(syncProgress.current.number) >=\n    hexToNumber(syncProgress.end.number)\n  );\n};\n\n/** Returns true if sync progress has reached the finalized block. */\nconst isSyncFinalized = (syncProgress: SyncProgress) => {\n  if (syncProgress.current === undefined) {\n    return false;\n  }\n\n  return (\n    hexToNumber(syncProgress.current.number) >=\n    hexToNumber(syncProgress.finalized.number)\n  );\n};\n\n/** Returns the closest-to-tip block that is part of the historical sync. */\nconst getHistoricalLast = (\n  syncProgress: Pick<SyncProgress, \"finalized\" | \"end\">,\n) => {\n  return syncProgress.end === undefined\n    ? syncProgress.finalized\n    : hexToNumber(syncProgress.end.number) >\n        hexToNumber(syncProgress.finalized.number)\n      ? syncProgress.finalized\n      : syncProgress.end;\n};\n\n/** Compute the minimum checkpoint, filtering out undefined */\nconst min = (...checkpoints: (string | undefined)[]) => {\n  return checkpoints.reduce((acc, cur) => {\n    if (cur === undefined) return acc;\n    if (acc === undefined) return cur;\n    if (acc < cur) return acc;\n    return cur;\n  })!;\n};\n\nexport const splitEvents = (events: RawEvent[]): RawEvent[][] => {\n  let prevHash: Hash | undefined;\n  const result: RawEvent[][] = [];\n\n  for (const event of events) {\n    if (prevHash === undefined || prevHash !== event.block.hash) {\n      result.push([]);\n      prevHash = event.block.hash;\n    }\n\n    result[result.length - 1]!.push(event);\n  }\n\n  return result;\n};\n\n/** Returns the checkpoint for a given block tag. */\nexport const getChainCheckpoint = ({\n  syncProgress,\n  network,\n  tag,\n}: {\n  syncProgress: SyncProgress;\n  network: Network;\n  tag: \"start\" | \"current\" | \"finalized\" | \"end\";\n}): string | undefined => {\n  if (tag === \"end\" && syncProgress.end === undefined) {\n    return undefined;\n  }\n\n  if (tag === \"current\" && isSyncEnd(syncProgress)) {\n    return undefined;\n  }\n\n  const block = syncProgress[tag]!;\n  return encodeCheckpoint(\n    blockToCheckpoint(\n      block,\n      network.chainId,\n      // The checkpoint returned by this function is meant to be used in\n      // a closed interval (includes endpoints), so \"start\" should be inclusive.\n      tag === \"start\" ? \"down\" : \"up\",\n    ),\n  );\n};\n\ntype CreateSyncParameters = {\n  common: Common;\n  syncStore: SyncStore;\n  sources: Source[];\n  networks: Network[];\n  onRealtimeEvent(event: RealtimeEvent): Promise<void>;\n  onFatalError(error: Error): void;\n  initialCheckpoint: string;\n};\n\nexport const createSync = async (args: CreateSyncParameters): Promise<Sync> => {\n  const localSyncContext = new Map<\n    Network,\n    {\n      requestQueue: RequestQueue;\n      syncProgress: SyncProgress;\n      historicalSync: HistoricalSync;\n      realtimeSync: RealtimeSync;\n      unfinalizedEventData: BlockWithEventData[];\n    }\n  >();\n  const status: Status = {};\n  let isKilled = false;\n  // Realtime events across all chains that can't be passed to the parent function\n  // because the overall checkpoint hasn't caught up to the events yet.\n  let pendingEvents: RawEvent[] = [];\n\n  // Instantiate `localSyncData` and `status`\n  await Promise.all(\n    args.networks.map(async (network) => {\n      const requestQueue = createRequestQueue({\n        network,\n        common: args.common,\n      });\n      const sources = args.sources.filter(\n        ({ filter }) => filter.chainId === network.chainId,\n      );\n\n      const { start, end, finalized } = await syncDiagnostic({\n        common: args.common,\n        sources,\n        requestQueue,\n        network,\n      });\n\n      // Invalidate sync cache for devnet sources\n      if (network.disableCache) {\n        args.common.logger.warn({\n          service: \"sync\",\n          msg: `Deleting cache records for '${network.name}' from block ${hexToNumber(start.number)}`,\n        });\n\n        await args.syncStore.pruneByChain({\n          fromBlock: hexToNumber(start.number),\n          chainId: network.chainId,\n        });\n      }\n\n      const historicalSync = await createHistoricalSync({\n        common: args.common,\n        sources,\n        syncStore: args.syncStore,\n        requestQueue,\n        network,\n        onFatalError: args.onFatalError,\n      });\n      const realtimeSync = createRealtimeSync({\n        common: args.common,\n        sources,\n        requestQueue,\n        network,\n        onEvent: (event) =>\n          onRealtimeSyncEvent({ event, network }).catch((error) => {\n            args.common.logger.error({\n              service: \"sync\",\n              msg: `Fatal error: Unable to process ${event.type} event`,\n              error,\n            });\n            args.onFatalError(error);\n          }),\n        onFatalError: args.onFatalError,\n      });\n\n      const cached = await getCachedBlock({\n        sources,\n        requestQueue,\n        historicalSync,\n      });\n\n      // Update \"ponder_sync_block\" metric\n      if (cached !== undefined) {\n        args.common.metrics.ponder_sync_block.set(\n          { network: network.name },\n          hexToNumber(cached.number),\n        );\n      }\n\n      const syncProgress: SyncProgress = {\n        start,\n        end,\n        finalized,\n        cached,\n        current: cached,\n      };\n\n      args.common.metrics.ponder_sync_is_realtime.set(\n        { network: network.name },\n        0,\n      );\n      args.common.metrics.ponder_sync_is_complete.set(\n        { network: network.name },\n        0,\n      );\n\n      localSyncContext.set(network, {\n        requestQueue,\n        syncProgress,\n        historicalSync,\n        realtimeSync,\n        unfinalizedEventData: [],\n      });\n      status[network.name] = { block: null, ready: false };\n    }),\n  );\n\n  /**\n   * Returns the minimum checkpoint across all chains.\n   */\n  const getOmnichainCheckpoint = (\n    tag: \"start\" | \"end\" | \"current\" | \"finalized\",\n  ): string | undefined => {\n    const checkpoints = Array.from(localSyncContext.entries()).map(\n      ([network, { syncProgress }]) =>\n        getChainCheckpoint({ syncProgress, network, tag }),\n    );\n\n    if (tag === \"end\" && checkpoints.some((c) => c === undefined)) {\n      return undefined;\n    }\n\n    if (tag === \"current\" && checkpoints.every((c) => c === undefined)) {\n      return undefined;\n    }\n\n    return min(...checkpoints);\n  };\n\n  const updateHistoricalStatus = ({\n    events,\n    checkpoint,\n    network,\n  }: { events: RawEvent[]; checkpoint: string; network: Network }) => {\n    if (Number(decodeCheckpoint(checkpoint).chainId) === network.chainId) {\n      status[network.name]!.block = {\n        timestamp: decodeCheckpoint(checkpoint).blockTimestamp,\n        number: Number(decodeCheckpoint(checkpoint).blockNumber),\n      };\n    } else {\n      let i = events.length - 1;\n      while (i >= 0) {\n        const event = events[i]!;\n\n        if (network.chainId === event.chainId) {\n          status[network.name]!.block = {\n            timestamp: decodeCheckpoint(event.checkpoint).blockTimestamp,\n            number: Number(decodeCheckpoint(event.checkpoint).blockNumber),\n          };\n        }\n\n        i--;\n      }\n    }\n  };\n\n  const updateRealtimeStatus = ({\n    checkpoint,\n    network,\n  }: {\n    checkpoint: string;\n    network: Network;\n  }) => {\n    const localBlock = localSyncContext\n      .get(network)!\n      .realtimeSync.unfinalizedBlocks.findLast(\n        (block) =>\n          encodeCheckpoint(blockToCheckpoint(block, network.chainId, \"up\")) <=\n          checkpoint,\n      );\n    if (localBlock !== undefined) {\n      status[network.name]!.block = {\n        timestamp: hexToNumber(localBlock.timestamp),\n        number: hexToNumber(localBlock.number),\n      };\n    }\n  };\n\n  /**\n   * Estimate optimal range (seconds) to query at a time, eventually\n   * used to determine `to` passed to `getEvents`\n   */\n  let estimateSeconds = 1_000;\n  /**\n   * Omnichain `getEvents`\n   *\n   * Extract all events across `args.networks` ordered by checkpoint.\n   * The generator is \"completed\" when all event have been extracted\n   * before the minimum finalized checkpoint (supremum).\n   *\n   * Note: `syncStore.getEvents` is used to order between multiple\n   * networks. This approach is not future proof.\n   */\n  async function* getEvents() {\n    let latestFinalizedFetch = Date.now();\n\n    /**\n     * Calculate start checkpoint, if `initialCheckpoint` is non-zero,\n     * use that. Otherwise, use `startBlock`\n     */\n    const start =\n      args.initialCheckpoint !== encodeCheckpoint(zeroCheckpoint)\n        ? args.initialCheckpoint\n        : getOmnichainCheckpoint(\"start\")!;\n\n    // Cursor used to track progress.\n    let from = start;\n\n    let showLogs = true;\n    while (true) {\n      const syncGenerator = mergeAsyncGenerators(\n        Array.from(localSyncContext.entries()).map(\n          ([network, { syncProgress, historicalSync }]) =>\n            localHistoricalSyncGenerator({\n              common: args.common,\n              network,\n              syncProgress,\n              historicalSync,\n              showLogs,\n            }),\n        ),\n      );\n\n      // Only show logs on the first iteration\n      showLogs = false;\n\n      for await (const _ of syncGenerator) {\n        /**\n         * `current` is used to calculate the `to` checkpoint, if any\n         * network hasn't yet ingested a block, run another iteration of this loop.\n         * It is an invariant that `latestBlock` will eventually be defined.\n         */\n        if (\n          Array.from(localSyncContext.values()).some(\n            ({ syncProgress }) => syncProgress.current === undefined,\n          )\n        ) {\n          continue;\n        }\n\n        // Calculate the mininum \"current\" checkpoint, limited by \"finalized\" and \"end\"\n        const to = min(\n          getOmnichainCheckpoint(\"end\"),\n          getOmnichainCheckpoint(\"finalized\"),\n          getOmnichainCheckpoint(\"current\"),\n        );\n\n        /*\n         * Extract events with `syncStore.getEvents()`, paginating to\n         * avoid loading too many events into memory.\n         */\n        while (true) {\n          if (isKilled) return;\n          if (from >= to) break;\n          const getEventsMaxBatchSize = args.common.options.syncEventsQuerySize;\n          let consecutiveErrors = 0;\n\n          // convert `estimateSeconds` to checkpoint\n          const estimatedTo = encodeCheckpoint({\n            ...zeroCheckpoint,\n            blockTimestamp: Math.min(\n              decodeCheckpoint(from).blockTimestamp + estimateSeconds,\n              maxCheckpoint.blockTimestamp,\n            ),\n          });\n\n          try {\n            const { events, cursor } = await args.syncStore.getEvents({\n              filters: args.sources.map(({ filter }) => filter),\n              from,\n              to: to < estimatedTo ? to : estimatedTo,\n              limit: getEventsMaxBatchSize,\n            });\n            consecutiveErrors = 0;\n\n            for (const network of args.networks) {\n              updateHistoricalStatus({ events, checkpoint: cursor, network });\n            }\n\n            estimateSeconds = estimate({\n              from: decodeCheckpoint(from).blockTimestamp,\n              to: decodeCheckpoint(cursor).blockTimestamp,\n              target: getEventsMaxBatchSize,\n              result: events.length,\n              min: 10,\n              max: 86_400,\n              prev: estimateSeconds,\n              maxIncrease: 1.08,\n            });\n\n            yield { events, checkpoint: to };\n            from = cursor;\n\n            // underlying metrics collection is actually synchronous\n            // https://github.com/siimon/prom-client/blob/master/lib/histogram.js#L102-L125\n            const { eta, progress } = await getAppProgress(args.common.metrics);\n\n            if (events.length > 0) {\n              if (eta === undefined || progress === undefined) {\n                args.common.logger.info({\n                  service: \"app\",\n                  msg: `Indexed ${events.length} events`,\n                });\n              } else {\n                args.common.logger.info({\n                  service: \"app\",\n                  msg: `Indexed ${events.length} events with ${formatPercentage(progress)} complete and ${formatEta(eta)} remaining`,\n                });\n              }\n            }\n          } catch (error) {\n            // Handle errors by reducing the requested range by 10x\n            estimateSeconds = Math.max(10, Math.round(estimateSeconds / 10));\n            if (++consecutiveErrors > 4) throw error;\n          }\n        }\n      }\n\n      /** `true` if all networks have synced all known finalized blocks.  */\n      const allHistoricalSyncExhaustive = Array.from(\n        localSyncContext.values(),\n      ).every(({ syncProgress }) => {\n        if (isSyncEnd(syncProgress)) return true;\n\n        // Determine if `finalized` block is considered \"stale\"\n        const staleSeconds = (Date.now() - latestFinalizedFetch) / 1_000;\n        if (staleSeconds <= args.common.options.syncHandoffStaleSeconds) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (allHistoricalSyncExhaustive) break;\n\n      /** At least one network has a `finalized` block that is considered \"stale\". */\n\n      latestFinalizedFetch = Date.now();\n\n      await Promise.all(\n        Array.from(localSyncContext.entries()).map(\n          async ([network, { requestQueue, syncProgress }]) => {\n            args.common.logger.debug({\n              service: \"sync\",\n              msg: `Refetching '${network.name}' finalized block`,\n            });\n\n            const latestBlock = await _eth_getBlockByNumber(requestQueue, {\n              blockTag: \"latest\",\n            });\n\n            const finalizedBlockNumber = Math.max(\n              0,\n              hexToNumber(latestBlock.number) - network.finalityBlockCount,\n            );\n\n            syncProgress.finalized = await _eth_getBlockByNumber(requestQueue, {\n              blockNumber: finalizedBlockNumber,\n            });\n\n            const historicalLast = getHistoricalLast(syncProgress);\n\n            // Set metric \"ponder_historical_total_blocks\"\n            args.common.metrics.ponder_historical_total_blocks.set(\n              { network: network.name },\n              hexToNumber(historicalLast.number) -\n                hexToNumber(syncProgress.start.number) +\n                1,\n            );\n          },\n        ),\n      );\n    }\n  }\n\n  /**\n   * Omnichain `onRealtimeSyncEvent`\n   *\n   * Handle callback events across all `args.networks`, and raising these\n   * events to `args.onRealtimeEvent` while maintaining checkpoint ordering.\n   */\n  const onRealtimeSyncEvent = async ({\n    network,\n    event,\n  }: { network: Network; event: RealtimeSyncEvent }) => {\n    const { syncProgress, realtimeSync, unfinalizedEventData } =\n      localSyncContext.get(network)!;\n\n    switch (event.type) {\n      /**\n       * Handle a new block being ingested.\n       */\n      case \"block\": {\n        // Update local sync, record checkpoint before and after\n        const from = getOmnichainCheckpoint(\"current\")!;\n        syncProgress.current = event.block;\n        const to = getOmnichainCheckpoint(\"current\")!;\n\n        // Update \"ponder_sync_block\" metric\n        args.common.metrics.ponder_sync_block.set(\n          { network: network.name },\n          hexToNumber(syncProgress.current.number),\n        );\n\n        const blockWithEventData = {\n          block: event.block,\n          filters: event.filters,\n          logs: event.logs,\n          factoryLogs: event.factoryLogs,\n          callTraces: event.callTraces,\n          transactions: event.transactions,\n          transactionReceipts: event.transactionReceipts,\n        };\n\n        unfinalizedEventData.push(blockWithEventData);\n\n        const events = buildEvents({\n          sources: args.sources,\n          chainId: network.chainId,\n          blockWithEventData,\n          finalizedChildAddresses: realtimeSync.finalizedChildAddresses,\n          unfinalizedChildAddresses: realtimeSync.unfinalizedChildAddresses,\n        });\n\n        pendingEvents.push(...events);\n\n        if (to > from) {\n          for (const network of args.networks) {\n            updateRealtimeStatus({ checkpoint: to, network });\n          }\n\n          const events = pendingEvents\n            .filter(({ checkpoint }) => checkpoint <= to)\n            .sort((a, b) => (a.checkpoint < b.checkpoint ? -1 : 1));\n\n          pendingEvents = pendingEvents.filter(\n            ({ checkpoint }) => checkpoint > to,\n          );\n\n          args\n            .onRealtimeEvent({\n              type: \"block\",\n              checkpoint: to,\n              status: structuredClone(status),\n              events,\n            })\n            .then(() => {\n              if (events.length > 0 && isKilled === false) {\n                args.common.logger.info({\n                  service: \"app\",\n                  msg: `Indexed ${events.length} events`,\n                });\n              }\n            });\n        }\n\n        break;\n      }\n      /**\n       * Handle a new block being finalized.\n       */\n      case \"finalize\": {\n        // Newly finalized range\n        const interval = [\n          hexToNumber(syncProgress.finalized.number),\n          hexToNumber(event.block.number),\n        ] satisfies Interval;\n\n        // Update local sync, record checkpoint before and after\n        const prev = getOmnichainCheckpoint(\"finalized\")!;\n        syncProgress.finalized = event.block;\n        const checkpoint = getOmnichainCheckpoint(\"finalized\")!;\n\n        // Raise event to parent function (runtime)\n        if (checkpoint > prev) {\n          args.onRealtimeEvent({ type: \"finalize\", checkpoint });\n        }\n\n        const finalizedEventData = unfinalizedEventData.filter(\n          (ued) =>\n            hexToNumber(ued.block.number) <= hexToNumber(event.block.number),\n        );\n\n        localSyncContext.get(network)!.unfinalizedEventData =\n          unfinalizedEventData.filter(\n            (ued) =>\n              hexToNumber(ued.block.number) > hexToNumber(event.block.number),\n          );\n\n        if (\n          getChainCheckpoint({ syncProgress, network, tag: \"finalized\" })! >\n          getOmnichainCheckpoint(\"current\")!\n        ) {\n          args.common.logger.warn({\n            service: \"sync\",\n            msg: `Finalized block for '${network.name}' has surpassed overall indexing checkpoint`,\n          });\n        }\n\n        // Add finalized blocks, logs, transactions, receipts, and traces to the sync-store.\n\n        await Promise.all([\n          args.syncStore.insertBlocks({\n            blocks: finalizedEventData\n              .filter(({ filters }) => filters.size > 0)\n              .map(({ block }) => block),\n            chainId: network.chainId,\n          }),\n          args.syncStore.insertLogs({\n            logs: finalizedEventData.flatMap(({ logs, block }) =>\n              logs.map((log) => ({ log, block })),\n            ),\n            shouldUpdateCheckpoint: true,\n            chainId: network.chainId,\n          }),\n          args.syncStore.insertLogs({\n            logs: finalizedEventData.flatMap(({ factoryLogs }) =>\n              factoryLogs.map((log) => ({ log })),\n            ),\n            shouldUpdateCheckpoint: false,\n            chainId: network.chainId,\n          }),\n          args.syncStore.insertTransactions({\n            transactions: finalizedEventData.flatMap(\n              ({ transactions }) => transactions,\n            ),\n            chainId: network.chainId,\n          }),\n          args.syncStore.insertTransactionReceipts({\n            transactionReceipts: finalizedEventData.flatMap(\n              ({ transactionReceipts }) => transactionReceipts,\n            ),\n            chainId: network.chainId,\n          }),\n          args.syncStore.insertCallTraces({\n            callTraces: finalizedEventData.flatMap(({ callTraces, block }) =>\n              callTraces.map((callTrace) => ({ callTrace, block })),\n            ),\n            chainId: network.chainId,\n          }),\n        ]);\n\n        // Add corresponding intervals to the sync-store\n        // Note: this should happen after so the database doesn't become corrupted\n        await Promise.all(\n          args.sources\n            .filter(({ filter }) => filter.chainId === network.chainId)\n            .map(({ filter }) =>\n              args.syncStore.insertInterval({ filter, interval }),\n            ),\n        );\n\n        /**\n         * The realtime service can be killed if `endBlock` is\n         * defined has become finalized.\n         */\n        if (isSyncEnd(syncProgress)) {\n          args.common.metrics.ponder_sync_is_realtime.set(\n            { network: network.name },\n            0,\n          );\n          args.common.metrics.ponder_sync_is_complete.set(\n            { network: network.name },\n            1,\n          );\n          args.common.logger.info({\n            service: \"sync\",\n            msg: `Synced final end block for '${network.name}' (${hexToNumber(syncProgress.end!.number)}), killing realtime sync service`,\n          });\n          realtimeSync.kill();\n        }\n        break;\n      }\n      /**\n       * Handle a reorg with a new common ancestor block being found.\n       */\n      case \"reorg\": {\n        syncProgress.current = event.block;\n        const checkpoint = getOmnichainCheckpoint(\"current\")!;\n\n        // Update \"ponder_sync_block\" metric\n        args.common.metrics.ponder_sync_block.set(\n          { network: network.name },\n          hexToNumber(syncProgress.current.number),\n        );\n\n        localSyncContext.get(network)!.unfinalizedEventData =\n          unfinalizedEventData.filter(\n            (led) =>\n              hexToNumber(led.block.number) <= hexToNumber(event.block.number),\n          );\n\n        const reorgedHashes = new Set<Hash>();\n        for (const b of event.reorgedBlocks) {\n          reorgedHashes.add(b.hash);\n        }\n\n        pendingEvents = pendingEvents.filter(\n          (e) => reorgedHashes.has(e.block.hash) === false,\n        );\n\n        await args.syncStore.pruneRpcRequestResult({\n          blocks: event.reorgedBlocks,\n          chainId: network.chainId,\n        });\n\n        // Raise event to parent function (runtime)\n        args.onRealtimeEvent({ type: \"reorg\", checkpoint });\n\n        break;\n      }\n\n      default:\n        never(event);\n    }\n  };\n  return {\n    getEvents,\n    async startRealtime() {\n      for (const network of args.networks) {\n        const { syncProgress, realtimeSync } = localSyncContext.get(network)!;\n\n        status[network.name]!.block = {\n          number: hexToNumber(syncProgress.current!.number),\n          timestamp: hexToNumber(syncProgress.current!.timestamp),\n        };\n        status[network.name]!.ready = true;\n\n        if (isSyncEnd(syncProgress)) {\n          args.common.metrics.ponder_sync_is_complete.set(\n            { network: network.name },\n            1,\n          );\n        } else {\n          args.common.metrics.ponder_sync_is_realtime.set(\n            { network: network.name },\n            1,\n          );\n\n          const initialChildAddresses = new Map<Factory, Set<Address>>();\n\n          for (const { filter } of args.sources) {\n            if (\n              filter.chainId === network.chainId &&\n              \"address\" in filter &&\n              isAddressFactory(filter.address)\n            ) {\n              const addresses = await args.syncStore.getChildAddresses({\n                filter: filter.address,\n              });\n\n              initialChildAddresses.set(filter.address, new Set(addresses));\n            }\n          }\n\n          realtimeSync.start({ syncProgress, initialChildAddresses });\n        }\n      }\n    },\n    getStartCheckpoint() {\n      return getOmnichainCheckpoint(\"start\")!;\n    },\n    getFinalizedCheckpoint() {\n      return getOmnichainCheckpoint(\"finalized\")!;\n    },\n    getStatus() {\n      return status;\n    },\n    getCachedTransport(network) {\n      const { requestQueue } = localSyncContext.get(network)!;\n      return cachedTransport({ requestQueue, syncStore: args.syncStore });\n    },\n    async kill() {\n      isKilled = true;\n      const promises: Promise<void>[] = [];\n      for (const network of args.networks) {\n        const { historicalSync, realtimeSync } = localSyncContext.get(network)!;\n        historicalSync.kill();\n        promises.push(realtimeSync.kill());\n      }\n      await Promise.all(promises);\n    },\n  };\n};\n\n/** ... */\nexport const syncDiagnostic = async ({\n  common,\n  sources,\n  network,\n  requestQueue,\n}: {\n  common: Common;\n  sources: Source[];\n  network: Network;\n  requestQueue: RequestQueue;\n}) => {\n  /** Earliest `startBlock` among all `filters` */\n  const start = Math.min(...sources.map(({ filter }) => filter.fromBlock ?? 0));\n  /**\n   * Latest `endBlock` among all filters. `undefined` if at least one\n   * of the filters doesn't have an `endBlock`.\n   */\n  const end = sources.some(({ filter }) => filter.toBlock === undefined)\n    ? undefined\n    : Math.max(...sources.map(({ filter }) => filter.toBlock!));\n\n  const [remoteChainId, startBlock, endBlock, latestBlock] = await Promise.all([\n    requestQueue.request({ method: \"eth_chainId\" }),\n    _eth_getBlockByNumber(requestQueue, { blockNumber: start }),\n    end === undefined\n      ? undefined\n      : _eth_getBlockByNumber(requestQueue, { blockNumber: end }),\n    _eth_getBlockByNumber(requestQueue, { blockTag: \"latest\" }),\n  ]);\n\n  // Warn if the config has a different chainId than the remote.\n  if (hexToNumber(remoteChainId) !== network.chainId) {\n    common.logger.warn({\n      service: \"sync\",\n      msg: `Remote chain ID (${remoteChainId}) does not match configured chain ID (${network.chainId}) for network \"${network.name}\"`,\n    });\n  }\n\n  const finalizedBlockNumber = Math.max(\n    0,\n    hexToNumber(latestBlock.number) - network.finalityBlockCount,\n  );\n\n  const finalizedBlock = await _eth_getBlockByNumber(requestQueue, {\n    blockNumber: finalizedBlockNumber,\n  });\n\n  return {\n    start: startBlock,\n    end: endBlock,\n    finalized: finalizedBlock,\n  };\n};\n\n/** Returns the closest-to-tip block that has been synced for all `sources`. */\nexport const getCachedBlock = ({\n  sources,\n  requestQueue,\n  historicalSync,\n}: {\n  sources: Source[];\n  requestQueue: RequestQueue;\n  historicalSync: HistoricalSync;\n}): Promise<SyncBlock | LightBlock> | undefined => {\n  const latestCompletedBlocks = sources.map(({ filter }) => {\n    const requiredInterval = [\n      filter.fromBlock,\n      filter.toBlock ?? Number.POSITIVE_INFINITY,\n    ] satisfies Interval;\n    const cachedIntervals = historicalSync.intervalsCache.get(filter)!;\n\n    const completedIntervals = sortIntervals(\n      intervalIntersection([requiredInterval], cachedIntervals),\n    );\n\n    if (completedIntervals.length === 0) return undefined;\n\n    const earliestCompletedInterval = completedIntervals[0]!;\n    if (earliestCompletedInterval[0] !== filter.fromBlock) return undefined;\n    return earliestCompletedInterval[1];\n  });\n\n  const minCompletedBlock = Math.min(\n    ...(latestCompletedBlocks.filter(\n      (block) => block !== undefined,\n    ) as number[]),\n  );\n\n  /**  Filter i has known progress if a completed interval is found or if\n   * `_latestCompletedBlocks[i]` is undefined but `sources[i].filter.fromBlock`\n   * is > `_minCompletedBlock`.\n   */\n  if (\n    latestCompletedBlocks.every(\n      (block, i) =>\n        block !== undefined || sources[i]!.filter.fromBlock > minCompletedBlock,\n    )\n  ) {\n    return _eth_getBlockByNumber(requestQueue, {\n      blockNumber: minCompletedBlock,\n    });\n  }\n\n  return undefined;\n};\n\n/** Predictive pagination and metrics for `historicalSync.sync()` */\nexport async function* localHistoricalSyncGenerator({\n  common,\n  network,\n  syncProgress,\n  historicalSync,\n  showLogs,\n}: {\n  common: Common;\n  network: Network;\n  syncProgress: SyncProgress;\n  historicalSync: HistoricalSync;\n  showLogs: boolean;\n}): AsyncGenerator {\n  // Return immediately if the `syncProgress.start` is unfinalized\n  if (\n    hexToNumber(syncProgress.start.number) >\n    hexToNumber(syncProgress.finalized.number)\n  ) {\n    syncProgress.current = syncProgress.finalized;\n\n    // Update \"ponder_sync_block\" metric\n    common.metrics.ponder_sync_block.set(\n      { network: network.name },\n      hexToNumber(syncProgress.current.number),\n    );\n\n    if (showLogs) {\n      common.logger.warn({\n        service: \"historical\",\n        msg: `Skipped historical sync for '${network.name}' because the start block is not finalized`,\n      });\n    }\n\n    const label = { network: network.name };\n    // Set \"ponder_historical_total_blocks\"\n    common.metrics.ponder_historical_total_blocks.set(label, 0);\n    // Set \"ponder_historical_sync_cached_blocks\"\n    common.metrics.ponder_historical_cached_blocks.set(label, 0);\n\n    return;\n  }\n\n  const historicalLast = getHistoricalLast(syncProgress);\n\n  // Intialize metrics\n\n  const totalInterval = [\n    hexToNumber(syncProgress.start.number),\n    hexToNumber(historicalLast.number),\n  ] satisfies Interval;\n\n  const requiredIntervals = Array.from(\n    historicalSync.intervalsCache.entries(),\n  ).flatMap(([filter, interval]) =>\n    intervalDifference(\n      [\n        [\n          filter.fromBlock,\n          Math.min(\n            filter.toBlock ?? Number.POSITIVE_INFINITY,\n            totalInterval[1],\n          ),\n        ],\n      ],\n      interval,\n    ),\n  );\n\n  const required = intervalSum(intervalUnion(requiredIntervals));\n\n  const total = totalInterval[1] - totalInterval[0] + 1;\n\n  const label = { network: network.name };\n  // Set \"ponder_historical_total_blocks\"\n  common.metrics.ponder_historical_total_blocks.set(label, total);\n  // Set \"ponder_historical_sync_cached_blocks\"\n  common.metrics.ponder_historical_cached_blocks.set(label, total - required);\n\n  if (showLogs) {\n    common.logger.info({\n      service: \"historical\",\n      msg: `Started syncing '${network.name}' with ${formatPercentage(\n        (total - required) / total,\n      )} cached`,\n    });\n  }\n\n  /**\n   * Estimate optimal range (blocks) to sync at a time, eventually to be used to\n   * determine `interval` passed to `historicalSync.sync()`.\n   */\n  let estimateRange = 25;\n  // Cursor to track progress.\n  let fromBlock = hexToNumber(syncProgress.start.number);\n\n  /**\n   * Handle a cache hit by fast forwarding and potentially exiting.\n   * A cache hit can either be: (listed by priority)\n   *   1) recovering progress from earlier invocations with different `finalized` blocks\n   *   2) recovering progress from the interval cache\n   */\n  if (\n    syncProgress.current !== undefined &&\n    (syncProgress.cached === undefined ||\n      hexToNumber(syncProgress.current.number) >\n        hexToNumber(syncProgress.cached.number))\n  ) {\n    fromBlock = hexToNumber(syncProgress.current.number) + 1;\n  } else if (syncProgress.cached !== undefined) {\n    // `getEvents` can make progress without calling `sync`, so immediately \"yield\"\n    yield;\n\n    if (\n      hexToNumber(syncProgress.cached.number) ===\n      hexToNumber(historicalLast.number)\n    ) {\n      if (showLogs) {\n        common.logger.info({\n          service: \"historical\",\n          msg: `Skipped historical sync for '${network.name}' because all blocks are cached.`,\n        });\n      }\n      return;\n    }\n\n    fromBlock = hexToNumber(syncProgress.cached.number) + 1;\n  }\n\n  while (true) {\n    /**\n     * Select a range of blocks to sync bounded by `finalizedBlock`.\n     *\n     * It is important for devEx that the interval is not too large, because\n     * time spent syncing ≈ time before indexing function feedback.\n     */\n    const interval: Interval = [\n      Math.min(fromBlock, hexToNumber(historicalLast.number)),\n      Math.min(fromBlock + estimateRange, hexToNumber(historicalLast.number)),\n    ];\n\n    const endClock = startClock();\n\n    const syncBlock = await historicalSync.sync(interval);\n\n    // Update cursor to record progress\n    fromBlock = interval[1] + 1;\n\n    if (syncBlock === undefined) {\n      /**\n       * `syncBlock` will be undefined if a cache hit occur in `historicalSync.sync()`.\n       * If the all known blocks are synced, then update `syncProgress.current`, else\n       * progress to the next iteration.\n       */\n      if (interval[1] === hexToNumber(historicalLast.number)) {\n        syncProgress.current = historicalLast;\n      } else {\n        continue;\n      }\n    } else {\n      if (interval[1] === hexToNumber(historicalLast.number)) {\n        syncProgress.current = historicalLast;\n      } else {\n        syncProgress.current = syncBlock;\n      }\n\n      const duration = endClock();\n\n      // Update \"ponder_sync_block\" metric\n      common.metrics.ponder_sync_block.set(\n        { network: network.name },\n        hexToNumber(syncProgress.current.number),\n      );\n\n      common.metrics.ponder_historical_duration.observe(label, duration);\n      common.metrics.ponder_historical_completed_blocks.inc(\n        label,\n        interval[1] - interval[0] + 1,\n      );\n\n      // Use the duration and interval of the last call to `sync` to update estimate\n      // 25 <= estimate(new) <= estimate(prev) * 2 <= 100_000\n      estimateRange = Math.min(\n        Math.max(\n          25,\n          Math.round((1_000 * (interval[1] - interval[0])) / duration),\n        ),\n        estimateRange * 2,\n        100_000,\n      );\n    }\n\n    yield;\n\n    if (isSyncEnd(syncProgress) || isSyncFinalized(syncProgress)) {\n      return;\n    }\n  }\n}\n","import type { SyncStore } from \"@/sync-store/index.js\";\nimport { toLowerCase } from \"@/utils/lowercase.js\";\nimport type { RequestQueue } from \"@/utils/requestQueue.js\";\nimport type { Address, Hex, Transport } from \"viem\";\nimport { custom, hexToBigInt, maxUint256 } from \"viem\";\n\nconst cachedMethods = [\n  \"eth_call\",\n  \"eth_getBalance\",\n  \"eth_getCode\",\n  \"eth_getStorageAt\",\n] as const;\n\nexport const cachedTransport = ({\n  requestQueue,\n  syncStore,\n}: {\n  requestQueue: RequestQueue;\n  syncStore: SyncStore;\n}): Transport => {\n  return ({ chain }) => {\n    const c = custom({\n      async request({ method, params }) {\n        const body = { method, params };\n\n        if (cachedMethods.includes(method)) {\n          let request: string = undefined!;\n          let blockNumber: Hex | \"latest\" = undefined!;\n\n          if (method === \"eth_call\") {\n            const [{ data, to }, _blockNumber] = params as [\n              { data: Hex; to: Hex },\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(to)}_${toLowerCase(data)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getBalance\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getCode\") {\n            const [address, _blockNumber] = params as [Address, Hex | \"latest\"];\n\n            request = `${method as string}_${toLowerCase(address)}`;\n            blockNumber = _blockNumber;\n          } else if (method === \"eth_getStorageAt\") {\n            const [address, slot, _blockNumber] = params as [\n              Address,\n              Hex,\n              Hex | \"latest\",\n            ];\n\n            request = `${method as string}_${toLowerCase(address)}_${toLowerCase(slot)}`;\n            blockNumber = _blockNumber;\n          }\n\n          const blockNumberBigInt =\n            blockNumber === \"latest\" ? maxUint256 : hexToBigInt(blockNumber);\n\n          const cachedResult = await syncStore.getRpcRequestResult({\n            blockNumber: blockNumberBigInt,\n            chainId: chain!.id,\n            request,\n          });\n\n          if (cachedResult !== null) return cachedResult;\n          else {\n            const response = await requestQueue.request(body);\n            await syncStore.insertRpcRequestResult({\n              blockNumber: blockNumberBigInt,\n              chainId: chain!.id,\n              request,\n              result: response as string,\n            });\n            return response;\n          }\n        } else {\n          return requestQueue.request(body);\n        }\n      },\n    });\n    return c({ chain, retryCount: 0 });\n  };\n};\n","import type { IndexingBuild } from \"@/build/index.js\";\nimport { runCodegen } from \"@/common/codegen.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Database } from \"@/database/index.js\";\nimport { createHistoricalIndexingStore } from \"@/indexing-store/historical.js\";\nimport { getMetadataStore } from \"@/indexing-store/metadata.js\";\nimport { createRealtimeIndexingStore } from \"@/indexing-store/realtime.js\";\nimport { createIndexingService } from \"@/indexing/index.js\";\nimport { createSyncStore } from \"@/sync-store/index.js\";\nimport type { Event } from \"@/sync/events.js\";\nimport { decodeEvents } from \"@/sync/events.js\";\nimport { type RealtimeEvent, createSync, splitEvents } from \"@/sync/index.js\";\nimport {\n  decodeCheckpoint,\n  encodeCheckpoint,\n  zeroCheckpoint,\n} from \"@/utils/checkpoint.js\";\nimport { never } from \"@/utils/never.js\";\nimport { createQueue } from \"@ponder/common\";\n\n/** Starts the sync and indexing services for the specified build. */\nexport async function run({\n  common,\n  build,\n  database,\n  onFatalError,\n  onReloadableError,\n}: {\n  common: Common;\n  build: IndexingBuild;\n  database: Database;\n  onFatalError: (error: Error) => void;\n  onReloadableError: (error: Error) => void;\n}) {\n  const {\n    instanceId,\n    networks,\n    sources,\n    schema,\n    indexingFunctions,\n    graphqlSchema,\n  } = build;\n\n  let isKilled = false;\n\n  const { checkpoint: initialCheckpoint } = await database.setup();\n\n  const syncStore = createSyncStore({\n    common,\n    db: database.qb.sync,\n  });\n\n  const metadataStore = getMetadataStore({\n    db: database.qb.user,\n    instanceId,\n  });\n\n  // This can be a long-running operation, so it's best to do it after\n  // starting the server so the app can become responsive more quickly.\n  await database.migrateSync();\n\n  runCodegen({ common, graphqlSchema });\n\n  // Note: can throw\n  const sync = await createSync({\n    common,\n    syncStore,\n    networks,\n    sources,\n    // Note: this is not great because it references the\n    // `realtimeQueue` which isn't defined yet\n    onRealtimeEvent: (realtimeEvent) => {\n      return realtimeQueue.add(realtimeEvent);\n    },\n    onFatalError,\n    initialCheckpoint,\n  });\n\n  const handleEvents = async (events: Event[], checkpoint: string) => {\n    if (events.length === 0) return { status: \"success\" } as const;\n\n    indexingService.updateTotalSeconds(decodeCheckpoint(checkpoint));\n\n    return await indexingService.processEvents({ events });\n  };\n\n  const realtimeQueue = createQueue({\n    initialStart: true,\n    browser: false,\n    concurrency: 1,\n    worker: async (event: RealtimeEvent) => {\n      switch (event.type) {\n        case \"block\": {\n          // Events must be run block-by-block, so that `database.complete` can accurately\n          // update the temporary `checkpoint` value set in the trigger.\n          for (const events of splitEvents(event.events)) {\n            const result = await handleEvents(\n              decodeEvents(common, sources, events),\n              event.checkpoint,\n            );\n\n            if (result.status === \"error\") onReloadableError(result.error);\n\n            // Set reorg table `checkpoint` column for newly inserted rows.\n            await database.complete({ checkpoint: event.checkpoint });\n          }\n\n          await metadataStore.setStatus(event.status);\n\n          break;\n        }\n        case \"reorg\":\n          await database.removeTriggers();\n          await database.revert({ checkpoint: event.checkpoint });\n          await database.createTriggers();\n\n          break;\n\n        case \"finalize\":\n          await database.finalize({ checkpoint: event.checkpoint });\n          break;\n\n        default:\n          never(event);\n      }\n    },\n  });\n\n  const indexingService = createIndexingService({\n    indexingFunctions,\n    common,\n    sources,\n    networks,\n    sync,\n  });\n\n  const historicalIndexingStore = createHistoricalIndexingStore({\n    common,\n    database,\n    schema,\n    initialCheckpoint,\n  });\n\n  indexingService.setIndexingStore(historicalIndexingStore);\n\n  await metadataStore.setStatus(sync.getStatus());\n\n  const start = async () => {\n    // If the initial checkpoint is zero, we need to run setup events.\n    if (encodeCheckpoint(zeroCheckpoint) === initialCheckpoint) {\n      const result = await indexingService.processSetupEvents({\n        sources,\n        networks,\n      });\n      if (result.status === \"killed\") {\n        return;\n      } else if (result.status === \"error\") {\n        onReloadableError(result.error);\n        return;\n      }\n    }\n\n    // Track the last processed checkpoint, used to set metrics\n    let end: string | undefined;\n    let lastFlush = Date.now();\n\n    // Run historical indexing until complete.\n    for await (const { events, checkpoint } of sync.getEvents()) {\n      end = checkpoint;\n\n      const result = await handleEvents(\n        decodeEvents(common, sources, events),\n        checkpoint,\n      );\n\n      // Persist the indexing store to the db if it is too full. The `finalized`\n      // checkpoint is used as a mutex. Any rows in the reorg table that may\n      // have been written because of raw sql access are deleted. Also must truncate\n      // the reorg tables that may have been written because of raw sql access.\n      if (\n        (historicalIndexingStore.isCacheFull() && events.length > 0) ||\n        (common.options.command === \"dev\" &&\n          lastFlush + 5_000 < Date.now() &&\n          events.length > 0)\n      ) {\n        await database.finalize({\n          checkpoint: encodeCheckpoint(zeroCheckpoint),\n        });\n        await historicalIndexingStore.flush();\n        await database.complete({\n          checkpoint: encodeCheckpoint(zeroCheckpoint),\n        });\n        await database.finalize({\n          checkpoint: events[events.length - 1]!.checkpoint,\n        });\n        lastFlush = Date.now();\n      }\n\n      await metadataStore.setStatus(sync.getStatus());\n      if (result.status === \"killed\") {\n        return;\n      } else if (result.status === \"error\") {\n        onReloadableError(result.error);\n        return;\n      }\n    }\n\n    if (isKilled) return;\n\n    // Persist the indexing store to the db. The `finalized`\n    // checkpoint is used as a mutex. Any rows in the reorg table that may\n    // have been written because of raw sql access are deleted. Also must truncate\n    // the reorg tables that may have been written because of raw sql access.\n\n    await database.finalize({ checkpoint: encodeCheckpoint(zeroCheckpoint) });\n    await historicalIndexingStore.flush();\n    await database.complete({ checkpoint: encodeCheckpoint(zeroCheckpoint) });\n    await database.finalize({ checkpoint: sync.getFinalizedCheckpoint() });\n\n    // Manually update metrics to fix a UI bug that occurs when the end\n    // checkpoint is between the last processed event and the finalized\n    // checkpoint.\n    const start = sync.getStartCheckpoint();\n    common.metrics.ponder_indexing_completed_seconds.set(\n      decodeCheckpoint(end ?? start).blockTimestamp -\n        decodeCheckpoint(start).blockTimestamp,\n    );\n    common.metrics.ponder_indexing_total_seconds.set(\n      decodeCheckpoint(end ?? start).blockTimestamp -\n        decodeCheckpoint(start).blockTimestamp,\n    );\n    common.metrics.ponder_indexing_completed_timestamp.set(\n      decodeCheckpoint(end ?? start).blockTimestamp,\n    );\n\n    // Become healthy\n    common.logger.info({\n      service: \"indexing\",\n      msg: \"Completed historical indexing\",\n    });\n\n    await database.createIndexes();\n    await database.createLiveViews();\n    await database.createTriggers();\n\n    indexingService.setIndexingStore(\n      createRealtimeIndexingStore({\n        database,\n        schema,\n        common,\n      }),\n    );\n\n    await sync.startRealtime();\n\n    await metadataStore.setStatus(sync.getStatus());\n\n    common.logger.info({\n      service: \"server\",\n      msg: \"Started responding as healthy\",\n    });\n  };\n\n  const startPromise = start();\n\n  return async () => {\n    isKilled = true;\n    indexingService.kill();\n    await sync.kill();\n    realtimeQueue.pause();\n    realtimeQueue.clear();\n    await realtimeQueue.onIdle();\n    await startPromise;\n    await database.unlock();\n  };\n}\n","import http from \"node:http\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Database } from \"@/database/index.js\";\nimport { graphql } from \"@/graphql/middleware.js\";\nimport { type PonderRoutes, applyHonoRoutes } from \"@/hono/index.js\";\nimport {\n  getLiveMetadataStore,\n  getMetadataStore,\n} from \"@/indexing-store/metadata.js\";\nimport { startClock } from \"@/utils/timer.js\";\nimport { serve } from \"@hono/node-server\";\nimport type { GraphQLSchema } from \"graphql\";\nimport { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { createMiddleware } from \"hono/factory\";\nimport { createHttpTerminator } from \"http-terminator\";\nimport { onError } from \"./error.js\";\n\ntype Server = {\n  hono: Hono;\n  port: number;\n  kill: () => Promise<void>;\n};\n\nexport async function createServer({\n  app: userApp,\n  routes: userRoutes,\n  common,\n  graphqlSchema,\n  database,\n  instanceId,\n}: {\n  app: Hono;\n  routes: PonderRoutes;\n  common: Common;\n  graphqlSchema: GraphQLSchema;\n  database: Database;\n  instanceId?: string;\n}): Promise<Server> {\n  // Create hono app\n\n  const metadataStore =\n    instanceId === undefined\n      ? getLiveMetadataStore({ db: database.qb.readonly })\n      : getMetadataStore({\n          db: database.qb.readonly,\n          instanceId,\n        });\n\n  const metricsMiddleware = createMiddleware(async (c, next) => {\n    const matchedPathLabels = c.req.matchedRoutes\n      // Filter out global middlewares\n      .filter((r) => r.path !== \"/*\")\n      .map((r) => ({ method: c.req.method, path: r.path }));\n\n    for (const labels of matchedPathLabels) {\n      common.metrics.ponder_http_server_active_requests.inc(labels);\n    }\n    const endClock = startClock();\n\n    try {\n      await next();\n    } finally {\n      const requestSize = Number(c.req.header(\"Content-Length\") ?? 0);\n      const responseSize = Number(c.res.headers.get(\"Content-Length\") ?? 0);\n      const responseDuration = endClock();\n      const status =\n        c.res.status >= 200 && c.res.status < 300\n          ? \"2XX\"\n          : c.res.status >= 300 && c.res.status < 400\n            ? \"3XX\"\n            : c.res.status >= 400 && c.res.status < 500\n              ? \"4XX\"\n              : \"5XX\";\n\n      for (const labels of matchedPathLabels) {\n        common.metrics.ponder_http_server_active_requests.dec(labels);\n        common.metrics.ponder_http_server_request_size_bytes.observe(\n          { ...labels, status },\n          requestSize,\n        );\n        common.metrics.ponder_http_server_response_size_bytes.observe(\n          { ...labels, status },\n          responseSize,\n        );\n        common.metrics.ponder_http_server_request_duration_ms.observe(\n          { ...labels, status },\n          responseDuration,\n        );\n      }\n    }\n  });\n\n  // context required for graphql middleware and hono middleware\n  const contextMiddleware = createMiddleware(async (c, next) => {\n    c.set(\"db\", database.drizzle);\n    c.set(\"metadataStore\", metadataStore);\n    c.set(\"graphqlSchema\", graphqlSchema);\n    await next();\n  });\n\n  const hono = new Hono()\n    .use(metricsMiddleware)\n    .use(cors({ origin: \"*\", maxAge: 86400 }))\n    .get(\"/metrics\", async (c) => {\n      try {\n        const metrics = await common.metrics.getMetrics();\n        return c.text(metrics);\n      } catch (error) {\n        return c.json(error as Error, 500);\n      }\n    })\n    .get(\"/health\", (c) => {\n      return c.text(\"\", 200);\n    })\n    .get(\"/ready\", async (c) => {\n      const status = await metadataStore.getStatus();\n\n      if (\n        status !== null &&\n        Object.values(status).every(({ ready }) => ready === true)\n      ) {\n        return c.text(\"\", 200);\n      }\n\n      return c.text(\"Historical indexing is not complete.\", 503);\n    })\n    .get(\"/status\", async (c) => {\n      const status = await metadataStore.getStatus();\n\n      return c.json(status);\n    })\n    .use(contextMiddleware);\n\n  if (userRoutes.length === 0 && userApp.routes.length === 0) {\n    // apply graphql middleware if no custom api exists\n    hono.use(\"/graphql\", graphql());\n    hono.use(\"/\", graphql());\n  } else {\n    // apply user routes to hono instance, registering a custom error handler\n    applyHonoRoutes(hono, userRoutes, { db: database.drizzle }).onError(\n      (error, c) => onError(error, c, common),\n    );\n\n    common.logger.debug({\n      service: \"server\",\n      msg: `Detected a custom server with routes: [${userRoutes\n        .map(({ pathOrHandlers: [maybePathOrHandler] }) => maybePathOrHandler)\n        .filter((maybePathOrHandler) => typeof maybePathOrHandler === \"string\")\n        .join(\", \")}]`,\n    });\n\n    hono.route(\"/\", userApp);\n  }\n\n  // Create nodejs server\n\n  let port = common.options.port;\n\n  const createServerWithNextAvailablePort: typeof http.createServer = (\n    ...args: any\n  ) => {\n    const httpServer = http.createServer(...args);\n\n    const errorHandler = (error: Error & { code: string }) => {\n      if (error.code === \"EADDRINUSE\") {\n        common.logger.warn({\n          service: \"server\",\n          msg: `Port ${port} was in use, trying port ${port + 1}`,\n        });\n        port += 1;\n        setTimeout(() => {\n          httpServer.close();\n          httpServer.listen(port, common.options.hostname);\n        }, 5);\n      }\n    };\n\n    const listenerHandler = () => {\n      common.metrics.ponder_http_server_port.set(port);\n      common.logger.info({\n        service: \"server\",\n        msg: `Started listening on port ${port}`,\n      });\n      httpServer.off(\"error\", errorHandler);\n    };\n\n    httpServer.on(\"error\", errorHandler);\n    httpServer.on(\"listening\", listenerHandler);\n\n    return httpServer;\n  };\n\n  const httpServer = await new Promise<http.Server>((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(new Error(\"HTTP server failed to start within 5 seconds.\"));\n    }, 5_000);\n\n    const httpServer = serve(\n      {\n        fetch: hono.fetch,\n        createServer: createServerWithNextAvailablePort,\n        port,\n        // Note that common.options.hostname can be undefined if the user did not specify one.\n        // In this case, Node.js uses `::` if IPv6 is available and `0.0.0.0` otherwise.\n        // https://nodejs.org/api/net.html#serverlistenport-host-backlog-callback\n        hostname: common.options.hostname,\n      },\n      () => {\n        clearTimeout(timeout);\n        resolve(httpServer as http.Server);\n      },\n    );\n  });\n\n  const terminator = createHttpTerminator({\n    server: httpServer,\n    gracefulTerminationTimeout: 1000,\n  });\n\n  return {\n    hono,\n    port,\n    kill: () => terminator.terminate(),\n  };\n}\n","import type { Hono } from \"hono\";\nimport type { Handler, MiddlewareHandler } from \"./handler.js\";\n\nexport type PonderRoutes = {\n  method: \"GET\" | \"POST\" | \"USE\";\n  pathOrHandlers: [\n    maybePathOrHandler: string | Handler | MiddlewareHandler,\n    ...handlers: (Handler | MiddlewareHandler)[],\n  ];\n}[];\n\nexport const applyHonoRoutes = (\n  hono: Hono,\n  routes: PonderRoutes,\n  customContext?: object,\n) => {\n  // add custom properties to hono context\n  const customContextWrapper =\n    (handler: Handler | MiddlewareHandler) => (c: any, next: any) => {\n      for (const key of Object.keys(customContext ?? {})) {\n        // @ts-ignore\n        c[key] = customContext![key];\n      }\n\n      return handler(c, next);\n    };\n\n  for (const {\n    method,\n    pathOrHandlers: [maybePathOrHandler, ...handlers],\n  } of routes) {\n    let path = \"/\";\n    if (method === \"GET\" || method === \"POST\") {\n      // register collected \"GET\" or \"POST\" path + handlers to the underlying hono instance\n      // from https://github.com/honojs/hono/blob/main/src/hono-base.ts#L125-L142\n      if (typeof maybePathOrHandler === \"string\") {\n        path = maybePathOrHandler;\n      } else {\n        hono[method === \"GET\" ? \"get\" : \"put\"](\n          path,\n          customContextWrapper(maybePathOrHandler),\n        );\n      }\n\n      for (const handler of handlers) {\n        if (typeof handler !== \"string\") {\n          hono[method === \"GET\" ? \"get\" : \"put\"](\n            path,\n            customContextWrapper(handler),\n          );\n        }\n      }\n    } else {\n      // register collected middleware to the underlying hono instance\n      // from: https://github.com/honojs/hono/blob/main/src/hono-base.ts#L158-L169\n      if (typeof maybePathOrHandler === \"string\") {\n        path = maybePathOrHandler;\n      } else {\n        path = \"*\";\n        handlers.unshift(maybePathOrHandler);\n      }\n      for (const handler of handlers) {\n        hono.use(path, customContextWrapper(handler));\n      }\n    }\n  }\n\n  return hono;\n};\n","import type { Common } from \"@/common/common.js\";\nimport type { BaseError } from \"@/common/errors.js\";\nimport { addStackTrace } from \"@/indexing/addStackTrace.js\";\nimport { prettyPrint } from \"@/utils/print.js\";\nimport type { Context, HonoRequest } from \"hono\";\nimport { html } from \"hono/html\";\n\nexport const onError = async (_error: Error, c: Context, common: Common) => {\n  const error = _error as BaseError;\n\n  // Find the filename where the error occurred\n  const regex = /(\\S+\\.(?:js|ts|mjs|cjs)):\\d+:\\d+/;\n  const matches = error.stack?.match(regex);\n  const errorFile = (() => {\n    if (!matches?.[0]) return undefined;\n    const path = matches[0].trim();\n    if (path.startsWith(\"(\")) {\n      return path.slice(1);\n    } else if (path.startsWith(\"file://\")) {\n      return path.slice(7);\n    }\n    return path;\n  })();\n\n  addStackTrace(error, common.options);\n\n  error.meta = Array.isArray(error.meta) ? error.meta : [];\n  error.meta.push(\n    `Request:\\n${prettyPrint({\n      path: c.req.path,\n      method: c.req.method,\n      body: await tryExtractRequestBody(c.req),\n    })}`,\n  );\n\n  common.logger.warn({\n    service: \"server\",\n    msg: `An error occurred while handling a '${c.req.method}' request to the route '${c.req.path}'`,\n    error,\n  });\n\n  // 500: Internal Server Error\n  return c.text(\n    `${error.name}: ${error.message} occurred in '${errorFile}' while handling a '${c.req.method}' request to the route '${c.req.path}'`,\n    500,\n  );\n};\n\nexport const onNotFound = (c: Context) => {\n  return c.html(\n    html`<!doctype html>\n      <h1>Bad news!</h1>\n      <p>The route \"<code>${c.req.path}</code>\" does not exist</p>`,\n  );\n};\n\nconst tryExtractRequestBody = async (request: HonoRequest) => {\n  try {\n    return await request.json();\n  } catch {\n    try {\n      const text = await request.text();\n      if (text !== \"\") return text;\n    } catch {}\n  }\n  return undefined;\n};\n","import type { ApiBuild } from \"@/build/index.js\";\nimport type { Common } from \"@/common/common.js\";\nimport type { Database } from \"@/database/index.js\";\nimport { createServer } from \"@/server/index.js\";\n\n/**\n * Starts the server for the specified build.\n */\nexport async function runServer({\n  common,\n  build,\n  database,\n}: {\n  common: Common;\n  build: ApiBuild;\n  database: Database;\n}) {\n  const { instanceId, graphqlSchema } = build;\n\n  const server = await createServer({\n    app: build.app,\n    routes: build.routes,\n    common,\n    graphqlSchema,\n    database,\n    instanceId,\n  });\n\n  return async () => {\n    await server.kill();\n  };\n}\n","import path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { createDatabase } from \"@/database/index.js\";\nimport { createServer } from \"@/server/index.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function serve({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const buildResult = await buildService.start({ watch: false });\n  // Once we have the initial build, we can kill the build service.\n  await buildService.kill();\n\n  if (buildResult.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: {\n      cli_command: \"serve\",\n      ...buildPayload(buildResult.indexingBuild),\n    },\n  });\n\n  const { databaseConfig, schema, instanceId, buildId, statements, namespace } =\n    buildResult.apiBuild;\n\n  if (databaseConfig.kind === \"pglite\") {\n    await shutdown({\n      reason: \"The 'ponder serve' command does not support PGlite\",\n      code: 1,\n    });\n    return cleanup;\n  }\n\n  const database = createDatabase({\n    common,\n    schema,\n    databaseConfig,\n    instanceId,\n    buildId,\n    statements,\n    namespace,\n  });\n\n  const server = await createServer({\n    common,\n    app: buildResult.apiBuild.app,\n    routes: buildResult.apiBuild.routes,\n    graphqlSchema: buildResult.indexingBuild.graphqlSchema,\n    database,\n    instanceId:\n      process.env.PONDER_EXPERIMENTAL_INSTANCE_ID === undefined\n        ? undefined\n        : instanceId,\n  });\n\n  cleanupReloadable = async () => {\n    await server.kill();\n    await database.kill();\n  };\n\n  return cleanup;\n}\n","import path from \"node:path\";\nimport { createBuildService } from \"@/build/index.js\";\nimport { createLogger } from \"@/common/logger.js\";\nimport { MetricsService } from \"@/common/metrics.js\";\nimport { buildOptions } from \"@/common/options.js\";\nimport { buildPayload, createTelemetry } from \"@/common/telemetry.js\";\nimport { createDatabase } from \"@/database/index.js\";\nimport type { CliOptions } from \"../ponder.js\";\nimport { run } from \"../utils/run.js\";\nimport { runServer } from \"../utils/runServer.js\";\nimport { setupShutdown } from \"../utils/shutdown.js\";\n\nexport async function start({ cliOptions }: { cliOptions: CliOptions }) {\n  const options = buildOptions({ cliOptions });\n\n  const logger = createLogger({\n    level: options.logLevel,\n    mode: options.logFormat,\n  });\n\n  const [major, minor, _patch] = process.versions.node\n    .split(\".\")\n    .map(Number) as [number, number, number];\n  if (major < 18 || (major === 18 && minor < 14)) {\n    logger.fatal({\n      service: \"process\",\n      msg: `Invalid Node.js version. Expected >=18.14, detected ${major}.${minor}.`,\n    });\n    await logger.kill();\n    process.exit(1);\n  }\n\n  const configRelPath = path.relative(options.rootDir, options.configFile);\n  logger.debug({\n    service: \"app\",\n    msg: `Started using config file: ${configRelPath}`,\n  });\n\n  const metrics = new MetricsService();\n  const telemetry = createTelemetry({ options, logger });\n  const common = { options, logger, metrics, telemetry };\n\n  const buildService = await createBuildService({ common });\n\n  let cleanupReloadable = () => Promise.resolve();\n  let cleanupReloadableServer = () => Promise.resolve();\n\n  const cleanup = async () => {\n    await cleanupReloadable();\n    await cleanupReloadableServer();\n    if (database) {\n      await database.kill();\n    }\n    await telemetry.kill();\n  };\n\n  const shutdown = setupShutdown({ common, cleanup });\n\n  const buildResult = await buildService.start({ watch: false });\n  // Once we have the initial build, we can kill the build service.\n  await buildService.kill();\n\n  if (buildResult.status === \"error\") {\n    await shutdown({ reason: \"Failed intial build\", code: 1 });\n    return cleanup;\n  }\n\n  telemetry.record({\n    name: \"lifecycle:session_start\",\n    properties: {\n      cli_command: \"start\",\n      ...buildPayload(buildResult.indexingBuild),\n    },\n  });\n\n  const database = createDatabase({\n    common,\n    schema: buildResult.indexingBuild.schema,\n    databaseConfig: buildResult.indexingBuild.databaseConfig,\n    buildId: buildResult.indexingBuild.buildId,\n    instanceId: buildResult.indexingBuild.instanceId,\n    namespace: buildResult.indexingBuild.namespace,\n    statements: buildResult.indexingBuild.statements,\n  });\n\n  cleanupReloadable = await run({\n    common,\n    build: buildResult.indexingBuild!,\n    database,\n    onFatalError: () => {\n      shutdown({ reason: \"Received fatal error\", code: 1 });\n    },\n    onReloadableError: () => {\n      shutdown({ reason: \"Encountered indexing error\", code: 1 });\n    },\n  });\n\n  cleanupReloadableServer = await runServer({\n    common,\n    build: buildResult.apiBuild,\n    database,\n  });\n\n  return cleanup;\n}\n"],"mappings":"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","names":["readFileSync","create","methods","params","path","transport","symbol","resolve","resolve","_parameters","getEventSelector","startBlockMaybeNan","startBlock","endBlockMaybeNan","endBlock","logSource","file","path","path","file","configResult","schemaResult","indexingResult","path","metrics","path","createHash","readFileSync","path","start","createHash","packageJson","kill","path","packageJsonPath","readFileSync","os","os","existsSync","path","crypto","mkdirSync","getTableColumns","sql","prometheus","prometheus","drizzle","qb","sql","crypto","getTableColumns","Box","Text","React","Text","React","React","Box","Text","kill","getTableColumns","sql","getTableConfig","getTableConfig","getTableColumns","query","sql","sql","and","eq","getTableConfig","drizzle","checkOnchainTable","getTableConfig","eq","and","drizzle","query","start","readFileSync","codeFrameColumns","parseStackTrace","path","create","kill","methods","create","kill","chainId","includeTransactionReceipts","fromAddress","toAddress","start","start2","checksumAddress","hexToBigInt","hexToNumber","start","qb","db","hexToNumber","hexToBigInt","fs","query","checksumAddress","hexToNumber","checksumAddress","hexToBigInt","hexToNumber","hexToNumber","hexToBigInt","callTraces","checksumAddress","hexToBigInt","hexToNumber","interval","address","range","logs","start","hexToNumber","hexToNumber","hexToNumber","factoryLogs","block","min","getLogsRetryHelper","BlockNotFoundError","RETRY_COUNT","BASE_DURATION","getLogsRetryHelper","BlockNotFoundError","hexToBigInt","hexToNumber","hexToBigInt","hexToNumber","hexToBigInt","start","network","events","label","start","path","path","createServer","httpServer","resolve","createServer","existsSync","path","buildResult","path","serve","path","createServer","path","start","path","readFileSync","start","serve"]}
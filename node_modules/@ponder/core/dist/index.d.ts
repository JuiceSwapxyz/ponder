import { P as Prettify, a as PonderTypeError } from './utils-ceNucOJb.js';
import { AbiEvent, Abi, AbiFunction, AbiParametersToPrimitiveTypes, FormatAbiItem } from 'abitype';
import { GetEventArgs, ParseAbiItem, Abi as Abi$1, Narrow, Transport, Hex, Hash, Address, AccessList, TransactionType, Chain, Client, PublicRpcSchema, GetBalanceParameters, GetBalanceReturnType, GetCodeParameters, GetCodeReturnType, GetStorageAtParameters, GetStorageAtReturnType, MulticallParameters, MulticallReturnType, ContractFunctionName, ContractFunctionArgs, ReadContractParameters, ReadContractReturnType, GetEnsNameParameters, GetEnsNameReturnType } from 'viem';
import * as drizzle_orm from 'drizzle-orm';
import { ColumnBuilderBaseConfig, entityKind, MakeColumnConfig, ColumnBaseConfig, ColumnBuilderBase, Writable, Table, InferSelectModel, InferInsertModel, GetColumnData, Column } from 'drizzle-orm';
export { and, asc, avg, avgDistinct, between, count, countDistinct, desc, eq, exists, gt, gte, inArray, isNotNull, isNull, like, lt, lte, max, min, ne, not, notBetween, notExists, notIlike, notInArray, or, relations, sql, sum, sumDistinct } from 'drizzle-orm';
import { NodePgDatabase } from 'drizzle-orm/node-postgres';
import { PgColumnBuilder, AnyPgTable, PgColumn, AnyPgColumn, PgColumnBuilderBase, PgTableExtraConfig, PrimaryKeyBuilder as PrimaryKeyBuilder$1, TableConfig, PgTable, ExtraConfigColumn, PgSchema, PgEnumColumnBuilderInitial } from 'drizzle-orm/pg-core';
export { alias, boolean, char, cidr, date, doublePrecision, except, exceptAll, foreignKey, index, inet, bigint as int8, integer, intersect, intersectAll, interval, json, jsonb, line, macaddr, macaddr8, numeric, point, real, smallint, text, time, timestamp, union, unionAll, uniqueIndex, uuid, varchar } from 'drizzle-orm/pg-core';
import { PgColumnsBuilders as PgColumnsBuilders$1 } from 'drizzle-orm/pg-core/columns/all';
import { PgliteDatabase } from 'drizzle-orm/pglite';
import { Input as Input$1, BlankInput, HandlerResponse, Next } from 'hono/types';
import * as hono from 'hono';
import { Hono, Input, Context as Context$1, Env } from 'hono';
export { MergeAbis, ReplaceBigInts, loadBalance, mergeAbis, rateLimit, replaceBigInts } from '@ponder/utils';

type GetAddress<contract> = contract extends {
    factory: unknown;
} ? contract extends {
    factory: {
        event: infer event extends AbiEvent;
    };
} ? {
    address?: never;
    factory?: {
        /** Address of the factory contract that creates this contract. */
        address: `0x${string}` | readonly `0x${string}`[];
        /** ABI event that announces the creation of a new instance of this contract. */
        event: AbiEvent;
        /** Name of the factory event parameter that contains the new child contract address. */
        parameter: Exclude<event["inputs"][number]["name"], undefined>;
    };
} : {
    address?: never;
    factory?: {
        /** Address of the factory contract that creates this contract. */
        address: `0x${string}` | readonly `0x${string}`[];
        /** ABI event that announces the creation of a new instance of this contract. */
        event: AbiEvent;
        /** Name of the factory event parameter that contains the new child contract address. */
        parameter: string;
    };
} : contract extends {
    address: `0x${string}` | readonly `0x${string}`[];
} ? {
    address?: `0x${string}` | readonly `0x${string}`[];
    factory?: never;
} : {
    address?: `0x${string}` | readonly `0x${string}`[];
    factory?: {
        /** Address of the factory contract that creates this contract. */
        address: `0x${string}` | readonly `0x${string}`[];
        /** ABI event that announces the creation of a new instance of this contract. */
        event: AbiEvent;
        /** Name of the factory event parameter that contains the new child contract address. */
        parameter: string;
    };
};

type NonStrictPick<T, K> = {
    [P in Extract<keyof T, K>]: T[P];
};
type ExtractAbiEvents<abi extends Abi, events = Extract<abi[number], {
    type: "event";
}>> = [events] extends [never] ? AbiEvent : events;
type ExtractAbiFunctions<abi extends Abi, functions = Extract<abi[number], {
    type: "function";
}>> = [functions] extends [never] ? AbiFunction : functions;
/** Return the abi event given the abi and compact signature. */
type ParseAbiEvent<abi extends Abi, signature extends string, abiEvents extends AbiEvent = ExtractAbiEvents<abi>, noOverloadEvent = Extract<abiEvents, {
    name: signature;
}>, overloadEvent = Extract<abiEvents, ParseAbiItem<`event ${signature}`>>> = [noOverloadEvent] extends [never] ? [overloadEvent] extends [never] ? AbiEvent : overloadEvent : noOverloadEvent;
/** Return the abi function given the abi and compact signature. */
type ParseAbiFunction<abi extends Abi, signature extends string, abiFunctions extends AbiFunction = ExtractAbiFunctions<abi>, noOverloadFunction = Extract<abiFunctions, {
    name: signature extends `${infer _signature}()` ? _signature : never;
}>, overloadFunction = Extract<abiFunctions, ParseAbiItem<`function ${signature}`>>> = [overloadFunction] extends [never] ? [noOverloadFunction] extends [never] ? AbiFunction : noOverloadFunction : overloadFunction;
/** Return the compact signature given the abi and abi event. */
type FormatAbiEvent<abi extends Abi, event extends AbiEvent, abiEvents extends AbiEvent = ExtractAbiEvents<abi>, matchingNameEvents extends AbiEvent = Extract<abiEvents, {
    name: event["name"];
}>> = [matchingNameEvents] extends [never] ? Abi extends abi ? event["name"] : never : [Exclude<matchingNameEvents, event>] extends [never] ? event["name"] : FormatAbiItem<event> extends `event ${infer signature}` ? signature : never;
/** Return the compact signature given the abi and abi function. */
type FormatAbiFunction<abi extends Abi, _function extends AbiFunction, abiFunctions extends AbiFunction = ExtractAbiFunctions<abi>, matchingNameFunctions extends AbiFunction = Extract<abiFunctions, {
    name: _function["name"];
}>> = [matchingNameFunctions] extends [never] ? Abi extends abi ? `${_function["name"]}()` : never : [Exclude<matchingNameFunctions, _function>] extends [never] ? `${_function["name"]}()` : FormatAbiItem<_function> extends `function ${infer signature}` ? signature : never;
/**
 * Return an union of safe event names that handle event overridding.
 */
type SafeEventNames<abi extends Abi, abiEvents extends AbiEvent = ExtractAbiEvents<abi>> = abiEvents extends abiEvents ? FormatAbiEvent<abi, abiEvents> : never;
/**
 * Return an union of safe function names that handle function overridding.
 */
type SafeFunctionNames<abi extends Abi, abiFunctions extends AbiFunction = ExtractAbiFunctions<abi>> = abiFunctions extends abiFunctions ? FormatAbiFunction<abi, abiFunctions> : never;
type FormatEventArgs<abi extends Abi, signature extends string> = GetEventArgs<Abi, string, {
    EnableUnion: false;
    IndexedOnly: false;
    Required: true;
}, ParseAbiEvent<abi, signature>>;
type FormatFunctionArgs<abi extends Abi, signature extends string, args = AbiParametersToPrimitiveTypes<ParseAbiFunction<abi, signature>["inputs"]>> = readonly [] extends args ? never : args;
type FormatFunctionResult<abi extends Abi, signature extends string, result = AbiParametersToPrimitiveTypes<ParseAbiFunction<abi, signature>["outputs"]>> = readonly [] extends result ? never : result extends readonly [unknown] ? result[0] : result;

type GetEventFilter<abi extends Abi$1, contract, safeEventNames extends string = SafeEventNames<abi>> = contract extends {
    filter: {
        event: infer event extends readonly string[] | string;
    };
} ? event extends readonly string[] ? {
    filter?: {
        event: readonly safeEventNames[];
    };
} : event extends safeEventNames ? {
    filter?: {
        event: safeEventNames | event;
        args?: GetEventArgs<abi, string, {
            EnableUnion: true;
            IndexedOnly: true;
            Required: false;
        }, ParseAbiEvent<abi, event>>;
    };
} : {
    filter?: {
        event: safeEventNames;
        args?: GetEventArgs<Abi$1 | readonly unknown[], string>;
    };
} : {
    filter?: {
        event: safeEventNames | readonly safeEventNames[];
        args?: GetEventArgs<Abi$1 | readonly unknown[], string>;
    };
};

type BlockConfig$1 = {
    /** Block number at which to start indexing events (inclusive). If `undefined`, events will be processed from block 0. Default: `undefined`. */
    startBlock?: number;
    /** Block number at which to stop indexing events (inclusive). If `undefined`, events will be processed in real-time. Default: `undefined`. */
    endBlock?: number;
};
type DatabaseConfig$1 = {
    kind: "pglite";
    /** Directory path to use for PGlite database files. Default: `".ponder/pglite"`. */
    directory?: string;
} | {
    kind: "postgres";
    /** Postgres database connection string. Default: `DATABASE_PRIVATE_URL` > `DATABASE_URL` environment variable. */
    connectionString?: string;
    /** Postgres pool configuration passed to `node-postgres`. */
    poolConfig?: {
        /** Maximum number of clients in the pool. Default: `30`. */
        max?: number;
    };
};
type NetworkConfig$1<network> = {
    /** Chain ID of the network. */
    chainId: network extends {
        chainId: infer chainId extends number;
    } ? chainId | number : number;
    /** A viem `http`, `webSocket`, or `fallback` [Transport](https://viem.sh/docs/clients/transports/http.html).
     *
     * __To avoid rate limiting, include a custom RPC URL.__ Usage:
     *
     * ```ts
     * import { http } from "viem";
     *
     * const network = {
     *    name: "mainnet",
     *    chainId: 1,
     *    transport: http("https://eth-mainnet.g.alchemy.com/v2/..."),
     * }
     * ```
     */
    transport: Transport;
    /** Polling interval (in ms). Default: `1_000`. */
    pollingInterval?: number;
    /** Maximum number of RPC requests per second. Default: `50`. */
    maxRequestsPerSecond?: number;
    /** Disable RPC request caching. Default: `false`. */
    disableCache?: boolean;
};
type BlockFilterConfig = {
    /** Block number at which to start indexing events (inclusive). If `undefined`, events will be processed from block 0. Default: `undefined`. */
    startBlock?: number;
    /** Block number at which to stop indexing events (inclusive). If `undefined`, events will be processed in real-time. Default: `undefined`. */
    endBlock?: number;
    interval?: number;
};
type GetBlockFilter<networks, allNetworkNames extends string = [keyof networks] extends [never] ? string : keyof networks & string> = BlockFilterConfig & {
    network: allNetworkNames | {
        [name in allNetworkNames]?: BlockFilterConfig;
    };
};
type AbiConfig<abi extends Abi | readonly unknown[]> = {
    /** Contract application byte interface. */
    abi: abi;
};
type TransactionReceiptConfig = {
    includeTransactionReceipts?: boolean;
};
type FunctionCallConfig = {
    includeCallTraces?: boolean;
};
type GetNetwork<networks, contract, abi extends Abi, allNetworkNames extends string = [keyof networks] extends [never] ? string : keyof networks & string> = contract extends {
    network: infer network;
} ? {
    /**
     * Network that this contract is deployed to. Must match a network name in `networks`.
     * Any filter information overrides the values in the higher level "contracts" property.
     * Factories cannot override an address and vice versa.
     */
    network: allNetworkNames | {
        [name in allNetworkNames]?: Prettify<GetAddress<NonStrictPick<network, "factory" | "address">> & GetEventFilter<abi, NonStrictPick<contract, "filter">> & TransactionReceiptConfig & FunctionCallConfig & BlockConfig$1>;
    };
} : {
    /**
     * Network that this contract is deployed to. Must match a network name in `networks`.
     * Any filter information overrides the values in the higher level "contracts" property.
     * Factories cannot override an address and vice versa.
     */
    network: allNetworkNames | {
        [name in allNetworkNames]?: Prettify<GetAddress<unknown> & GetEventFilter<abi, unknown> & TransactionReceiptConfig & FunctionCallConfig & BlockConfig$1>;
    };
};
type ContractConfig$1<networks, contract, abi extends Abi> = Prettify<AbiConfig<abi> & GetNetwork<networks, NonStrictPick<contract, "network">, abi> & GetAddress<NonStrictPick<contract, "factory" | "address">> & GetEventFilter<abi, NonStrictPick<contract, "filter">> & TransactionReceiptConfig & FunctionCallConfig & BlockConfig$1>;
type GetContract<networks = unknown, contract = unknown> = contract extends {
    abi: infer abi extends Abi;
} ? ContractConfig$1<networks, contract, abi> : ContractConfig$1<networks, contract, Abi>;
type ContractsConfig<networks, contracts> = {} extends contracts ? {} : {
    [name in keyof contracts]: GetContract<networks, contracts[name]>;
};
type NetworksConfig<networks> = {} extends networks ? {} : {
    [networkName in keyof networks]: NetworkConfig$1<networks[networkName]>;
};
type BlockFiltersConfig<networks = unknown, blocks = unknown> = {} extends blocks ? {} : {
    [name in keyof blocks]: GetBlockFilter<networks>;
};
declare const createConfig: <const networks, const contracts = {}, const blocks = {}>(config: {
    networks: NetworksConfig<Narrow<networks>>;
    contracts?: ContractsConfig<networks, Narrow<contracts>> | undefined;
    database?: DatabaseConfig$1 | undefined;
    blocks?: BlockFiltersConfig<networks, blocks> | undefined;
}) => CreateConfigReturnType<networks, contracts, blocks>;
type Config = {
    networks: {
        [networkName: string]: NetworkConfig$1<unknown>;
    };
    contracts: {
        [contractName: string]: GetContract;
    };
    database?: DatabaseConfig$1;
    blocks: {
        [sourceName: string]: GetBlockFilter<unknown>;
    };
};
type CreateConfigReturnType<networks, contracts, blocks> = {
    networks: networks;
    contracts: contracts;
    database?: DatabaseConfig$1;
    blocks: blocks;
};

/**
 * A confirmed Ethereum block.
 *
 * @link https://docs.soliditylang.org/en/v0.8.20/introduction-to-smart-contracts.html#blocks
 */
type Block = {
    /** Base fee per gas */
    baseFeePerGas: bigint | null;
    /** Difficulty for this block */
    difficulty: bigint;
    /** "Extra data" field of this block */
    extraData: Hex;
    /** Maximum gas allowed in this block */
    gasLimit: bigint;
    /** Total used gas by all transactions in this block */
    gasUsed: bigint;
    /** Block hash */
    hash: Hash;
    /** Logs bloom filter */
    logsBloom: Hex;
    /** Address that received this block’s mining rewards */
    miner: Address;
    /** Unique identifier for the block. */
    mixHash: Hash | null;
    /** Proof-of-work hash */
    nonce: Hex | null;
    /** Block number */
    number: bigint;
    /** Parent block hash */
    parentHash: Hash;
    /** Root of the this block’s receipts trie */
    receiptsRoot: Hex;
    /** SHA3 of the uncles data in this block */
    sha3Uncles: Hash | null;
    /** Size of this block in bytes */
    size: bigint;
    /** Root of this block’s final state trie */
    stateRoot: Hash;
    /** Unix timestamp of when this block was collated */
    timestamp: bigint;
    /** Total difficulty of the chain until this block */
    totalDifficulty: bigint | null;
    /** Root of this block’s transaction trie */
    transactionsRoot: Hash;
};
/**
 * A confirmed Ethereum transaction. Contains `legacy`, `EIP-1559`, or `EIP-2930` fee values depending on the transaction `type`.
 *
 * @link https://docs.soliditylang.org/en/v0.8.20/introduction-to-smart-contracts.html#transactions
 */
type Transaction = Prettify<{
    /** Hash of block containing this transaction */
    blockHash: Hash;
    /** Number of block containing this transaction */
    blockNumber: bigint;
    /** Transaction sender */
    from: Address;
    /** Gas provided for transaction execution */
    gas: bigint;
    /** Hash of this transaction */
    hash: Hash;
    /** Contract code or a hashed method call */
    input: Hex;
    /** Unique number identifying this transaction */
    nonce: number;
    /** ECDSA signature r */
    r: Hex | null;
    /** ECDSA signature s */
    s: Hex | null;
    /** Transaction recipient or `null` if deploying a contract */
    to: Address | null;
    /** Index of this transaction in the block */
    transactionIndex: number;
    /** ECDSA recovery ID */
    v: bigint | null;
    /** Value in wei sent with this transaction */
    value: bigint;
} & ({
    /** Transaction type. */
    type: "legacy";
    accessList?: never;
    /** Base fee per gas. Only present in legacy and EIP-2930 transactions. */
    gasPrice: bigint;
    maxFeePerGas?: never;
    maxPriorityFeePerGas?: never;
} | {
    /** Transaction type. */
    type: "eip2930";
    /** List of addresses and storage keys the transaction will access. */
    accessList: AccessList;
    /** Base fee per gas. Only present in legacy and EIP-2930 transactions. */
    gasPrice: bigint;
    maxFeePerGas?: never;
    maxPriorityFeePerGas?: never;
} | {
    /** Transaction type. */
    type: "eip1559";
    accessList?: never;
    gasPrice?: never;
    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). Only present in EIP-1559 transactions. */
    maxFeePerGas: bigint;
    /** Max priority fee per gas (in wei). Only present in EIP-1559 transactions. */
    maxPriorityFeePerGas: bigint;
} | {
    /** Transaction type. */
    type: "deposit";
    accessList?: never;
    gasPrice?: never;
    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). Only present in EIP-1559 transactions. */
    maxFeePerGas?: bigint;
    /** Max priority fee per gas (in wei). Only present in EIP-1559 transactions. */
    maxPriorityFeePerGas?: bigint;
} | {
    /** Transaction type. */
    type: Hex;
    gasPrice?: never;
    accessList?: never;
    maxFeePerGas?: never;
    maxPriorityFeePerGas?: never;
})>;
/**
 * A confirmed Ethereum log.
 *
 * @link https://docs.soliditylang.org/en/v0.8.20/abi-spec.html#events
 */
type Log = {
    /** Globally unique identifier for this log (`${blockHash}-${logIndex}`) */
    id: string;
    /** The address from which this log originated */
    address: Address;
    /** Hash of block containing this log */
    blockHash: Hash;
    /** Number of block containing this log */
    blockNumber: bigint;
    /** Contains the non-indexed arguments of the log */
    data: Hex;
    /** Index of this log within its block */
    logIndex: number;
    /** `true` if this log has been removed in a chain reorganization */
    removed: boolean;
    /** List of order-dependent topics */
    topics: [Hex, ...Hex[]] | [];
    /** Hash of the transaction that created this log */
    transactionHash: Hash;
    /** Index of the transaction that created this log */
    transactionIndex: number;
};
/**
 * A confirmed Ethereum transaction receipt.
 */
type TransactionReceipt = {
    /** Hash of block containing this transaction */
    blockHash: Hash;
    /** Number of block containing this transaction */
    blockNumber: bigint;
    /** Address of new contract or `null` if no contract was created */
    contractAddress: Address | null;
    /** Gas used by this and all preceding transactions in this block */
    cumulativeGasUsed: bigint;
    /** Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. */
    effectiveGasPrice: bigint;
    /** Transaction sender */
    from: Address;
    /** Gas used by this transaction */
    gasUsed: bigint;
    /** List of log objects generated by this transaction */
    logs: Log[];
    /** Logs bloom filter */
    logsBloom: Hex;
    /** `success` if this transaction was successful or `reverted` if it failed */
    status: "success" | "reverted";
    /** Transaction recipient or `null` if deploying a contract */
    to: Address | null;
    /** Hash of this transaction */
    transactionHash: Hash;
    /** Index of this transaction in the block */
    transactionIndex: number;
    /** Transaction type */
    type: TransactionType;
};
type _TraceAddress = number | _TraceAddress[];
type TraceAddress = _TraceAddress[];
/**
 * An Ethereum call trace.
 */
type CallTrace = {
    /** Globally unique identifier for this trace (`${transactionHash}-${traceAddress}`) */
    id: string;
    /** Message sender */
    from: Address;
    /** Message receipient  */
    to: Address;
    /** Amount of gas allocated to this call */
    gas: bigint;
    /** Value in wei sent with this call */
    value: bigint;
    /** Calldata sent with this call */
    input: Hex;
    /** Contains return data */
    output: Hex;
    /** Total used gas by this trace */
    gasUsed: bigint;
    /** Number of traces created by this trace */
    subtraces: number;
    /** Description of this traces position within all traces in the transaction */
    traceAddress: TraceAddress;
    /** Hash of block containing this trace */
    blockHash: Hash;
    /** Number of block containing this trace */
    blockNumber: bigint;
    /** Hash of the transaction that created this trace */
    transactionHash: Hash;
    /** Index of the transaction that created this trace */
    transactionIndex: number;
    /** EVM opcode used to make this call */
    callType: "call" | "staticcall" | "delegatecall" | "callcode";
};

type PgBigintBuilderInitial<TName extends string> = PgBigintBuilder<{
    name: TName;
    dataType: "bigint";
    columnType: "PgEvmBigint";
    data: bigint;
    driverParam: string;
    enumValues: undefined;
    generated: undefined;
}>;
declare class PgBigintBuilder<T extends ColumnBuilderBaseConfig<"bigint", "PgEvmBigint">> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T["name"]);
    /** @internal */
    build<TTableName extends string>(table: AnyPgTable<{
        name: TTableName;
    }>): PgBigint<MakeColumnConfig<T, TTableName>>;
}
declare class PgBigint<T extends ColumnBaseConfig<"bigint", "PgEvmBigint">> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: string): bigint;
}

type PgHexBuilderInitial<TName extends string> = PgHexBuilder<{
    name: TName;
    dataType: "string";
    columnType: "PgHex";
    data: `0x${string}`;
    driverParam: string;
    enumValues: undefined;
    generated: undefined;
}>;
declare class PgHexBuilder<T extends ColumnBuilderBaseConfig<"string", "PgHex">> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T["name"]);
    /** @internal */
    build<TTableName extends string>(table: AnyPgTable<{
        name: TTableName;
    }>): PgHex<MakeColumnConfig<T, TTableName>>;
}
declare class PgHex<T extends ColumnBaseConfig<"string", "PgHex">> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapToDriverValue(value: `0x${string}`): `0x${string}`;
}

declare function hex(): PgHexBuilderInitial<"">;
declare function hex<name extends string>(columnName: name): PgHexBuilderInitial<name>;
declare function bigint(): PgBigintBuilderInitial<"">;
declare function bigint<name extends string>(columnName: name): PgBigintBuilderInitial<name>;
declare const onchain: unique symbol;
type Drizzle<TSchema extends Schema = {
    [name: string]: never;
}> = NodePgDatabase<TSchema> | PgliteDatabase<TSchema>;
type Schema = {
    [name: string]: unknown;
};
type PrimaryKeyBuilder<columnNames extends string = string> = PrimaryKeyBuilder$1 & {
    columnNames: columnNames;
};
declare const primaryKey: <tableName extends string, column extends AnyPgColumn<{
    tableName: tableName;
}> & {
    " name": string;
}, columns extends (AnyPgColumn<{
    tableName: tableName;
}> & {
    " name": string;
})[]>({ name, columns, }: {
    name?: string | undefined;
    columns: [column, ...columns];
}) => PrimaryKeyBuilder<column[" name"] | columns[number][" name"]>;
type OnchainTable<T extends TableConfig & {
    extra: PgTableExtraConfig | undefined;
} = TableConfig & {
    extra: PgTableExtraConfig | undefined;
}> = PgTable<T> & {
    [Key in keyof T["columns"]]: T["columns"][Key];
} & {
    [onchain]: true;
} & {
    enableRLS: () => Omit<OnchainTable<T>, "enableRLS">;
};
type BuildExtraConfigColumns<columns extends Record<string, ColumnBuilderBase>> = {
    [key in keyof columns]: ExtraConfigColumn & {
        " name": key;
    };
};
type PgColumnsBuilders = Omit<PgColumnsBuilders$1, "bigint" | "serial" | "smallserial" | "bigserial"> & {
    /**
     * Create an 8 byte number column.
     */
    int8: PgColumnsBuilders$1["bigint"];
    /**
     * Create a column for hex strings.
     *
     * - Docs: https://ponder.sh/docs/api-reference/schema#onchaintable
     *
     * @example
     * import { hex, onchainTable } from "@ponder/core";
     *
     * export const account = onchainTable("account", (p) => ({
     *   address: p.hex(),
     * }));
     */
    hex: typeof hex;
    /**
     * Create a column for hex strings
     *
     * - Docs: https://ponder.sh/docs/api-reference/schema#onchaintable
     *
     * @example
     * import { hex, onchainTable } from "@ponder/core";
     *
     * export const account = onchainTable("account", (p) => ({
     *   balance: p.bigint(),
     * }));
     */
    bigint: typeof bigint;
};
/**
 * Create an onchain table.
 *
 * - Docs: https://ponder.sh/docs/api-reference/schema#onchaintable
 *
 * @example
 * import { onchainTable } from "@ponder/core";
 *
 * export const account = onchainTable("account", (p) => ({
 *   address: p.hex().primaryKey(),
 *   balance: p.bigint().notNull(),
 * }));
 *
 * @param name - The table name in the database.
 * @param columns - The table columns.
 * @param extra - Config such as indexes or composite primary keys.
 * @returns The onchain table.
 */
declare const onchainTable: <name extends string, columns extends Record<string, PgColumnBuilderBase<drizzle_orm.ColumnBuilderBaseConfig<drizzle_orm.ColumnDataType, string>, object>>, extra extends PgTableExtraConfig | undefined = undefined>(name: name, columns: columns | ((columnTypes: PgColumnsBuilders) => columns), extraConfig?: ((self: BuildExtraConfigColumns<columns>) => extra) | undefined) => OnchainTable<{
    name: name;
    schema: undefined;
    columns: { [Key in keyof columns]: PgColumn<{
        name: (Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        })["name"];
        tableName: name;
        dataType: (Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        })["dataType"];
        columnType: (Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        })["columnType"];
        data: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T ? T extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T extends {
            $type: infer U;
        } ? U : T["data"] : never : never;
        driverParam: (Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        })["driverParam"];
        notNull: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_1 ? T_1 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_1 extends {
            notNull: true;
        } ? true : false : never : never;
        hasDefault: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_2 ? T_2 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_2 extends {
            hasDefault: true;
        } ? true : false : never : never;
        isPrimaryKey: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_3 ? T_3 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_3 extends {
            isPrimaryKey: true;
        } ? true : false : never : never;
        isAutoincrement: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_4 ? T_4 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_4 extends {
            isAutoincrement: true;
        } ? true : false : never : never;
        hasRuntimeDefault: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_5 ? T_5 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_5 extends {
            hasRuntimeDefault: true;
        } ? true : false : never : never;
        enumValues: (Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        })["enumValues"];
        baseColumn: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_6 ? T_6 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_6 extends {
            baseBuilder: infer U_1 extends ColumnBuilderBase<drizzle_orm.ColumnBuilderBaseConfig<drizzle_orm.ColumnDataType, string>, object>;
        } ? drizzle_orm.Column<{
            name: U_1["_"]["name"];
            tableName: name;
            dataType: U_1["_"]["dataType"];
            columnType: U_1["_"]["columnType"];
            data: U_1["_"] extends infer T_7 ? T_7 extends U_1["_"] ? T_7 extends {
                $type: infer U;
            } ? U : T_7["data"] : never : never;
            driverParam: U_1["_"]["driverParam"];
            notNull: U_1["_"] extends infer T_8 ? T_8 extends U_1["_"] ? T_8 extends {
                notNull: true;
            } ? true : false : never : never;
            hasDefault: U_1["_"] extends infer T_9 ? T_9 extends U_1["_"] ? T_9 extends {
                hasDefault: true;
            } ? true : false : never : never;
            isPrimaryKey: U_1["_"] extends infer T_10 ? T_10 extends U_1["_"] ? T_10 extends {
                isPrimaryKey: true;
            } ? true : false : never : never;
            isAutoincrement: U_1["_"] extends infer T_11 ? T_11 extends U_1["_"] ? T_11 extends {
                isAutoincrement: true;
            } ? true : false : never : never;
            hasRuntimeDefault: U_1["_"] extends infer T_12 ? T_12 extends U_1["_"] ? T_12 extends {
                hasRuntimeDefault: true;
            } ? true : false : never : never;
            enumValues: U_1["_"]["enumValues"];
            baseColumn: U_1["_"] extends infer T_13 ? T_13 extends U_1["_"] ? T_13 extends {
                baseBuilder: infer U_1 extends ColumnBuilderBase<drizzle_orm.ColumnBuilderBaseConfig<drizzle_orm.ColumnDataType, string>, object>;
            } ? drizzle_orm.Column<any, object, object> : never : never : never;
            identity: U_1["_"] extends infer T_14 ? T_14 extends U_1["_"] ? T_14 extends {
                identity: "always";
            } ? "always" : T_14 extends {
                identity: "byDefault";
            } ? "byDefault" : undefined : never : never;
            generated: U_1["_"] extends infer T_15 ? T_15 extends U_1["_"] ? T_15 extends {
                generated: infer G;
            } ? unknown extends G ? undefined : G extends undefined ? undefined : G : undefined : never : never;
        }, object, object> : never : never : never;
        identity: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_16 ? T_16 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_16 extends {
            identity: "always";
        } ? "always" : T_16 extends {
            identity: "byDefault";
        } ? "byDefault" : undefined : never : never;
        generated: Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } extends infer T_17 ? T_17 extends Omit<columns[Key]["_"], "name"> & {
            name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
        } ? T_17 extends {
            generated: infer G;
        } ? unknown extends G ? undefined : G extends undefined ? undefined : G : undefined : never : never;
    }, {}, {}>; };
    extra: extra;
    dialect: "pg";
}>;
declare class OnchainSchema<schema extends string> extends PgSchema<schema> {
    table: <name extends string, columns extends Record<string, PgColumnBuilderBase<drizzle_orm.ColumnBuilderBaseConfig<drizzle_orm.ColumnDataType, string>, object>>, extra extends PgTableExtraConfig | undefined = undefined>(name: name, columns: columns | ((columnTypes: PgColumnsBuilders) => columns), extraConfig?: ((self: BuildExtraConfigColumns<columns>) => extra) | undefined) => OnchainTable<{
        name: name;
        schema: schema;
        columns: { [Key in keyof columns]: PgColumn<{
            name: (Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            })["name"];
            tableName: name;
            dataType: (Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            })["dataType"];
            columnType: (Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            })["columnType"];
            data: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T ? T extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T extends {
                $type: infer U;
            } ? U : T["data"] : never : never;
            driverParam: (Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            })["driverParam"];
            notNull: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_1 ? T_1 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_1 extends {
                notNull: true;
            } ? true : false : never : never;
            hasDefault: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_2 ? T_2 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_2 extends {
                hasDefault: true;
            } ? true : false : never : never;
            isPrimaryKey: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_3 ? T_3 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_3 extends {
                isPrimaryKey: true;
            } ? true : false : never : never;
            isAutoincrement: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_4 ? T_4 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_4 extends {
                isAutoincrement: true;
            } ? true : false : never : never;
            hasRuntimeDefault: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_5 ? T_5 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_5 extends {
                hasRuntimeDefault: true;
            } ? true : false : never : never;
            enumValues: (Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            })["enumValues"];
            baseColumn: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_6 ? T_6 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_6 extends {
                baseBuilder: infer U_1 extends ColumnBuilderBase<drizzle_orm.ColumnBuilderBaseConfig<drizzle_orm.ColumnDataType, string>, object>;
            } ? drizzle_orm.Column<{
                name: U_1["_"]["name"];
                tableName: name;
                dataType: U_1["_"]["dataType"];
                columnType: U_1["_"]["columnType"];
                data: U_1["_"] extends infer T_7 ? T_7 extends U_1["_"] ? T_7 extends {
                    $type: infer U;
                } ? U : T_7["data"] : never : never;
                driverParam: U_1["_"]["driverParam"];
                notNull: U_1["_"] extends infer T_8 ? T_8 extends U_1["_"] ? T_8 extends {
                    notNull: true;
                } ? true : false : never : never;
                hasDefault: U_1["_"] extends infer T_9 ? T_9 extends U_1["_"] ? T_9 extends {
                    hasDefault: true;
                } ? true : false : never : never;
                isPrimaryKey: U_1["_"] extends infer T_10 ? T_10 extends U_1["_"] ? T_10 extends {
                    isPrimaryKey: true;
                } ? true : false : never : never;
                isAutoincrement: U_1["_"] extends infer T_11 ? T_11 extends U_1["_"] ? T_11 extends {
                    isAutoincrement: true;
                } ? true : false : never : never;
                hasRuntimeDefault: U_1["_"] extends infer T_12 ? T_12 extends U_1["_"] ? T_12 extends {
                    hasRuntimeDefault: true;
                } ? true : false : never : never;
                enumValues: U_1["_"]["enumValues"];
                baseColumn: U_1["_"] extends infer T_13 ? T_13 extends U_1["_"] ? T_13 extends {
                    baseBuilder: infer U_1 extends ColumnBuilderBase<drizzle_orm.ColumnBuilderBaseConfig<drizzle_orm.ColumnDataType, string>, object>;
                } ? drizzle_orm.Column<any, object, object> : never : never : never;
                identity: U_1["_"] extends infer T_14 ? T_14 extends U_1["_"] ? T_14 extends {
                    identity: "always";
                } ? "always" : T_14 extends {
                    identity: "byDefault";
                } ? "byDefault" : undefined : never : never;
                generated: U_1["_"] extends infer T_15 ? T_15 extends U_1["_"] ? T_15 extends {
                    generated: infer G;
                } ? unknown extends G ? undefined : G extends undefined ? undefined : G : undefined : never : never;
            }, object, object> : never : never : never;
            identity: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_16 ? T_16 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_16 extends {
                identity: "always";
            } ? "always" : T_16 extends {
                identity: "byDefault";
            } ? "byDefault" : undefined : never : never;
            generated: Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } extends infer T_17 ? T_17 extends Omit<columns[Key]["_"], "name"> & {
                name: columns[Key]["_"]["name"] extends "" ? drizzle_orm.Assume<Key, string> : columns[Key]["_"]["name"];
            } ? T_17 extends {
                generated: infer G;
            } ? unknown extends G ? undefined : G extends undefined ? undefined : G : undefined : never : never;
        }, {}, {}>; };
        extra: extra;
        dialect: "pg";
    }>;
    enum: <U extends string, T extends readonly [U, ...U[]]>(enumName: string, values: T | Writable<T>) => OnchainEnum<Writable<T>> & {
        [onchain]: true;
    };
}
/**
 * Define the database schema for onchain tables.
 *
 * @example
 * import { onchainSchema } from "@ponder/core";
 *
 * export const schema = onchainSchema("ponder");
 *
 * export const account = schema.table("account", (p) => ({
 *   address: p.hex().primaryKey(),
 *   balance: p.bigint().notNull(),
 * }));
 *
 * @param name - The schema for onchain tables.
 * @returns The onchain schema.
 */
declare const onchainSchema: <T extends string>(name: T) => OnchainSchema<T>;
declare const isPgEnumSym: unique symbol;
interface OnchainEnum<TValues extends [string, ...string[]]> {
    (): PgEnumColumnBuilderInitial<"", TValues>;
    <TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;
    <TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, TValues>;
    readonly enumName: string;
    readonly enumValues: TValues;
    readonly schema: string | undefined;
    /** @internal */
    [isPgEnumSym]: true;
}
declare const onchainEnum: <U extends string, T extends readonly [U, ...U[]]>(enumName: string, values: T | Writable<T>) => OnchainEnum<Writable<T>> & {
    [onchain]: true;
};

/**
 * Fix issue with Array.isArray not checking readonly arrays
 * {@link https://github.com/microsoft/TypeScript/issues/17002}
 */
declare global {
    interface ArrayConstructor {
        isArray(arg: ReadonlyArray<any> | any): arg is ReadonlyArray<any>;
    }
}

type ApiRegistry<schema extends Schema> = {
    get: HandlerInterface<schema>;
    post: HandlerInterface<schema>;
    use: MiddlewareHandlerInterface<schema>;
    hono: Hono<{
        Variables: {
            db: Drizzle<schema>;
        };
    }>;
};

type Context<schema extends Schema = Schema, path extends string = string, input extends Input = {}> = {
    db: Drizzle<schema>;
} & {
    /**
     * Hono request object.
     *
     * @see https://hono.dev/docs/api/context#req
     */
    req: Context$1<Env, path, input>["req"];
    /**
     * Hono response object.
     *
     * @see https://hono.dev/docs/api/context#res
     */
    res: Context$1<Env, path, input>["req"];
    /**
     * Return the HTTP response.
     *
     * @see https://hono.dev/docs/api/context#body
     */
    body: Context$1<Env, path, input>["body"];
    /**
     * Render text as `Content-Type:text/plain`.
     *
     * @see https://hono.dev/docs/api/context#text
     */
    text: Context$1<Env, path, input>["text"];
    /**
     * Render JSON as `Content-Type:application/json`.
     *
     * @see https://hono.dev/docs/api/context#json
     */
    json: Context$1<Env, path, input>["json"];
    /**
     * Hono redirect.
     *
     * @see https://hono.dev/docs/api/context#redirect
     */
    redirect: Context$1<Env, path, input>["redirect"];
};
type MiddlewareContext<schema extends Schema = Schema, path extends string = string, input extends Input = {}> = {
    db: Drizzle<schema>;
} & Context$1<Env, path, input>;

type Handler<schema extends Schema = Schema, path extends string = any, input extends Input$1 = BlankInput, response extends HandlerResponse<any> = any> = (c: Context<schema, path, input>) => response;
type MiddlewareHandler<schema extends Schema = Schema, path extends string = string, input extends Input$1 = {}> = (c: MiddlewareContext<schema, path, input>, next: Next) => Promise<Response | void>;
type BasePath = "/";
type HandlerInterface<schema extends Schema> = {
    <path extends string = BasePath, input extends Input$1 = BlankInput, response extends HandlerResponse<any> = any>(handler: Handler<schema, path, input, response>): ApiRegistry<schema>;
    <path extends string = BasePath, input extends Input$1 = BlankInput, input2 extends Input$1 = input, response extends HandlerResponse<any> = any>(...handlers: [
        Handler<schema, path, input>,
        Handler<schema, path, input2, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput>(path: path, handler: Handler<schema, path, input, response>): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        Handler<schema, path, input3, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        Handler<schema, path, input2, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        Handler<schema, path, input4, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        Handler<schema, path, input3, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        Handler<schema, path, input5, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        Handler<schema, path, input4, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        Handler<schema, path, input6, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        Handler<schema, path, input5, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        Handler<schema, path, input7, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        Handler<schema, path, input6, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6, input8 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        MiddlewareHandler<schema, path, input7>,
        Handler<schema, path, input8, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        Handler<schema, path, input7, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6, input8 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7, input9 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7 & input8>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        MiddlewareHandler<schema, path, input7>,
        MiddlewareHandler<schema, path, input8>,
        Handler<schema, path, input9, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6, input8 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        MiddlewareHandler<schema, path, input7>,
        Handler<schema, path, input8, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6, input8 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7, input9 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7 & input8, input10 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7 & input8 & input9>(...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        MiddlewareHandler<schema, path, input7>,
        MiddlewareHandler<schema, path, input8>,
        MiddlewareHandler<schema, path, input9>,
        Handler<schema, path, input10, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6, input8 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7, input9 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7 & input8>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        MiddlewareHandler<schema, path, input7>,
        MiddlewareHandler<schema, path, input8>,
        Handler<schema, path, input9, response>
    ]): ApiRegistry<schema>;
    <path extends string, response extends HandlerResponse<any> = any, input extends Input$1 = BlankInput, input2 extends Input$1 = input, input3 extends Input$1 = input & input2, input4 extends Input$1 = input & input2 & input3, input5 extends Input$1 = input & input2 & input3 & input4, input6 extends Input$1 = input & input2 & input3 & input4 & input5, input7 extends Input$1 = input & input2 & input3 & input4 & input5 & input6, input8 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7, input9 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7 & input8, input10 extends Input$1 = input & input2 & input3 & input4 & input5 & input6 & input7 & input8 & input9>(path: path, ...handlers: [
        MiddlewareHandler<schema, path, input>,
        MiddlewareHandler<schema, path, input2>,
        MiddlewareHandler<schema, path, input3>,
        MiddlewareHandler<schema, path, input4>,
        MiddlewareHandler<schema, path, input5>,
        MiddlewareHandler<schema, path, input6>,
        MiddlewareHandler<schema, path, input7>,
        MiddlewareHandler<schema, path, input8>,
        MiddlewareHandler<schema, path, input9>,
        Handler<schema, path, input10, response>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath, input extends Input$1 = BlankInput, response extends HandlerResponse<any> = any>(...handlers: Handler<schema, path, input, response>[]): ApiRegistry<schema>;
    <path extends string, input extends Input$1 = BlankInput, response extends HandlerResponse<any> = any>(path: path, ...handlers: Handler<schema, path, input, response>[]): ApiRegistry<schema>;
    <path extends string>(path: path): ApiRegistry<schema>;
};
interface MiddlewareHandlerInterface<schema extends Schema> {
    (...handlers: MiddlewareHandler<schema, BasePath>[]): ApiRegistry<schema>;
    (handler: MiddlewareHandler<schema, BasePath>): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, handler: MiddlewareHandler<schema, path>): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string = BasePath>(...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: [
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>,
        MiddlewareHandler<schema, path>
    ]): ApiRegistry<schema>;
    <path extends string>(path: path, ...handlers: MiddlewareHandler<schema, path>[]): ApiRegistry<schema>;
}

type Db<schema extends Schema> = {
    /**
     * Find a row
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#find
     *
     * @example
     * ```ts twoslash
     * const result = await db.find(table, { id: 10 });
     * ```
     *
     * @param table - The table to select from.
     * @param key - The primary key.
     * @returns The row if it exists or undefined if it doesn't.
     */
    find: Find;
    /**
     * Create new rows
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#insert
     *
     * @example
     * ```ts twoslash
     * await db.insert(table).values({ id: 10, name: "joe" });
     * ```
     *
     * @example
     * ```ts twoslash
     * await db.insert(table).values([
     *   { id: 10, name: "joe" },
     *   { id: 3, name: "rob" }
     * ]);
     * ```
     *
     * @example
     * ```ts twoslash
     * await db.insert(table).values({ id: 10, name: "joe" }).onConflictDoNothing();
     * ```
     *
     * @example
     * ```ts twoslash
     * await db
     *   .insert(table)
     *   .values({ id: 10, name: "joe" })
     *   .onConflictDoUpdate((row) => ({ age: row.age + 3 }));
     * ```
     *
     * @param table - The table to insert into.
     */
    insert: Insert;
    /**
     * Update a row
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#update
     *
     * @example
     * ```ts twoslash
     * await db
     *   .update(table, { id: 10 })
     *   .set({ age: 19 });
     * ```
     *
     * @example
     * ```ts twoslash
     * await db
     *   .update(table, { id: 10 })
     *   .set((row) => ({ age: row.age + 3 }));
     * ```
     *
     * @param table - The table to select from.
     * @param key - The primary key.
     */
    update: Update;
    /**
     * Delete a row
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#delete
     *
     * @example
     * ```ts twoslash
     * const deleted = await db.delete(table, { id: 10 });
     * ```
     *
     * @param table - The table to select from.
     * @param key - The primary key.
     * @returns `true` if the row existed.
     */
    delete: Delete;
    /**
     * Access the raw drizzle object
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#raw-sql
     */
    sql: Prettify<Omit<Drizzle<schema>, "refreshMaterializedView" | "_">>;
};
type InferPrimaryKey<table extends Table, columns extends Record<string, Column> = table["_"]["columns"], columnNames extends keyof columns & string = keyof columns & string> = columnNames extends columnNames ? columns[columnNames]["_"]["isPrimaryKey"] extends true ? columnNames : never : never;
type Key<table extends Table, compositePrimaryKey extends keyof table["_"]["columns"] = InferCompositePrimaryKey<table>, primaryKey extends keyof table["_"]["columns"] = [
    compositePrimaryKey
] extends [never] ? InferPrimaryKey<table> : compositePrimaryKey> = {
    [columnName in primaryKey]: GetColumnData<table["_"]["columns"][columnName]>;
};
type InferCompositePrimaryKey<table extends OnchainTable<TableConfig & {
    extra: PgTableExtraConfig | undefined;
}>, extra extends PgTableExtraConfig | undefined = table["_"]["config"]["extra"], builders = extra[keyof extra]> = builders extends builders ? builders extends PrimaryKeyBuilder ? builders["columnNames"] : never : never;
type Find = <table extends Table>(table: table extends {
    [onchain]: true;
} ? table : PonderTypeError<`db.find() can only be used with onchain tables, and '${table["_"]["name"]}' is an offchain table.`>, key: Key<table>) => Promise<InferSelectModel<table> | null>;
type Insert = <table extends Table, insertModel = InferInsertModel<table>, selectModel = InferSelectModel<table>, updateModel = Prettify<Omit<insertModel, keyof Key<table>>>, updateFn = (row: selectModel) => Partial<updateModel>>(table: table extends {
    [onchain]: true;
} ? table : PonderTypeError<`Indexing functions can only write to onchain tables, and '${table["_"]["name"]}' is an offchain table.`>) => {
    /**
     * Create new rows
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#insert
     *
     * @example
     * ```ts twoslash
     * await db.insert(table).values({ id: 10, name: "joe" });
     * ```
     *
     * @example
     * ```ts twoslash
     * await db.insert(table).values([
     *   { id: 10, name: "joe" },
     *   { id: 3, name: "rob" }
     * ]);
     * ```
     * @param table - The table to insert into.
     */
    values: <values extends insertModel | insertModel[]>(values: values) => Promise<values extends unknown[] ? selectModel[] : selectModel> & {
        /**
         * Create new rows, cancelling the insert if there is a conflict
         *
         * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#upsert--conflict-resolution
         * @example
         * ```ts twoslash
         * await db.insert(table).values({ id: 10, name: "joe" }).onConflictDoNothing();
         * ```
         * @param table - The table to insert into.
         */
        onConflictDoNothing: () => Promise<values extends unknown[] ? (selectModel | null)[] : selectModel | null>;
        /**
         * Create new rows, updating the row if there is a conflict
         *
         * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#upsert--conflict-resolution
         *
         * @example
         * ```ts twoslash
         * await db
         *   .insert(table)
         *   .values({ id: 10, name: "joe" })
         *   .onConflictDoUpdate({ age: 24 });
         * ```
         *
         * @example
         * ```ts twoslash
         * await db
         *   .insert(table)
         *   .values({ id: 10, name: "joe" })
         *   .onConflictDoUpdate((row) => ({ age: row.age + 3 }));
         * ```
         *
         * @param table - The table to insert into.
         */
        onConflictDoUpdate: (values: Partial<updateModel> | updateFn) => Promise<values extends unknown[] ? selectModel[] : selectModel>;
    };
};
type Update = <table extends Table, insertModel = InferInsertModel<table>, selectModel = InferSelectModel<table>, insertValues = Prettify<Omit<insertModel, keyof Key<table>>>, updateFn = (row: selectModel) => Partial<insertModel>>(table: table extends {
    [onchain]: true;
} ? table : PonderTypeError<`Indexing functions can only write to onchain tables, and '${table["_"]["name"]}' is an offchain table.`>, key: Key<table>) => {
    /**
     * Update a row
     *
     * - Docs: https://ponder.sh/docs/indexing/write-to-the-database#update
     *
     * @example
     * ```ts twoslash
     * await db
     *   .update(table, { id: 10 })
     *   .set({ age: 19 });
     * ```
     *
     * @example
     * ```ts twoslash
     * await db
     *   .update(table, { id: 10 })
     *   .set((row) => ({ age: row.age + 3 }));
     * ```
     *
     * @param table - The table to select from.
     * @param key - The primary key.
     */
    set: (values: Partial<insertValues> | updateFn) => Promise<selectModel>;
};
type Delete = <table extends Table>(table: table extends {
    [onchain]: true;
} ? table : PonderTypeError<`Indexing functions can only write to onchain tables, and '${table["_"]["name"]}' is an offchain table.`>, key: Key<table>) => Promise<boolean>;

type BlockOptions = {
    cache?: undefined;
    blockNumber?: undefined;
} | {
    cache: "immutable";
    blockNumber?: undefined;
} | {
    cache?: undefined;
    blockNumber: bigint;
};
type PonderActions = {
    getBalance: (args: Omit<GetBalanceParameters, "blockTag" | "blockNumber"> & BlockOptions) => Promise<GetBalanceReturnType>;
    getCode: (args: Omit<GetCodeParameters, "blockTag" | "blockNumber"> & BlockOptions) => Promise<GetCodeReturnType>;
    getStorageAt: (args: Omit<GetStorageAtParameters, "blockTag" | "blockNumber"> & BlockOptions) => Promise<GetStorageAtReturnType>;
    multicall: <const contracts extends readonly unknown[], allowFailure extends boolean = true>(args: Omit<MulticallParameters<contracts, allowFailure>, "blockTag" | "blockNumber"> & BlockOptions) => Promise<MulticallReturnType<contracts, allowFailure>>;
    readContract: <const abi extends Abi$1 | readonly unknown[], functionName extends ContractFunctionName<abi, "pure" | "view">, const args extends ContractFunctionArgs<abi, "pure" | "view", functionName>>(args: Omit<ReadContractParameters<abi, functionName, args>, "blockTag" | "blockNumber"> & BlockOptions) => Promise<ReadContractReturnType<abi, functionName, args>>;
    getEnsName: (args: Omit<GetEnsNameParameters, "blockTag" | "blockNumber"> & BlockOptions) => Promise<GetEnsNameReturnType>;
};
type ReadOnlyClient<transport extends Transport = Transport, chain extends Chain | undefined = Chain | undefined> = Prettify<Client<transport, chain, undefined, PublicRpcSchema, PonderActions>>;

declare namespace Virtual {
    type Setup = "setup";
    type _FormatEventNames<contract extends Config["contracts"][string], safeEventNames = SafeEventNames<contract["abi"]>> = string extends safeEventNames ? never : contract extends {
        filter: {
            event: infer event extends string | readonly string[];
        };
    } ? event extends safeEventNames ? event : event[number] extends safeEventNames ? event[number] : safeEventNames : safeEventNames;
    type _FormatFunctionNames<contract extends Config["contracts"][string], safeFunctionNames = SafeFunctionNames<contract["abi"]>> = string extends safeFunctionNames ? never : safeFunctionNames;
    /** "{ContractName}:{EventName}" | "{ContractName}.{FunctionName}()" | "{SourceName}:block" . */
    export type FormatEventNames<contracts extends Config["contracts"], blocks extends Config["blocks"]> = {
        [name in keyof contracts]: `${name & string}:${_FormatEventNames<contracts[name]> | Setup}`;
    }[keyof contracts] | {
        [name in keyof blocks]: `${name & string}:block`;
    }[keyof blocks] | {
        [name in keyof contracts]: true extends ExtractOverridenProperty<contracts[name], "includeCallTraces"> ? `${name & string}.${_FormatFunctionNames<contracts[name]>}` : never;
    }[keyof contracts];
    type FormatTransactionReceipts<contract extends Config["contracts"][string], includeTxr = ExtractOverridenProperty<contract, "includeTransactionReceipts">> = includeTxr extends includeTxr ? includeTxr extends true ? {
        transactionReceipt: Prettify<TransactionReceipt>;
    } : {
        transactionReceipt?: never;
    } : never;
    export type ExtractEventName<name extends string> = name extends `${string}:${infer EventName extends string}` ? EventName : name extends `${string}.${infer EventName extends string}` ? EventName : never;
    export type ExtractSourceName<name extends string> = name extends `${infer SourceName extends string}:${string}` ? SourceName : name extends `${infer SourceName extends string}.${string}` ? SourceName : never;
    export type EventNames<config extends Config> = FormatEventNames<config["contracts"], config["blocks"]>;
    export type Event<config extends Config, name extends EventNames<config>, contractName extends ExtractSourceName<name> = ExtractSourceName<name>, eventName extends ExtractEventName<name> = ExtractEventName<name>> = name extends `${string}:block` ? {
        block: Prettify<Block>;
    } : name extends `${string}.${string}` ? Prettify<{
        args: FormatFunctionArgs<config["contracts"][contractName]["abi"], eventName>;
        result: FormatFunctionResult<config["contracts"][contractName]["abi"], eventName>;
        trace: Prettify<CallTrace>;
        block: Prettify<Block>;
        transaction: Prettify<Transaction>;
    } & FormatTransactionReceipts<config["contracts"][contractName]>> : eventName extends Setup ? never : Prettify<{
        name: eventName;
        args: FormatEventArgs<config["contracts"][contractName]["abi"], eventName>;
        log: Prettify<Log>;
        block: Prettify<Block>;
        transaction: Prettify<Transaction>;
    } & FormatTransactionReceipts<config["contracts"][contractName]>>;
    type ContextContractProperty = Exclude<keyof Config["contracts"][string], "abi" | "network" | "filter" | "factory">;
    type ExtractOverridenProperty<contract extends Config["contracts"][string], property extends ContextContractProperty, base = Extract<contract, {
        [p in property]: unknown;
    }>[property], override = Extract<contract["network"][keyof contract["network"]], {
        [p in property]: unknown;
    }>[property]> = ([base] extends [never] ? undefined : base) | override;
    export type Context<config extends Config, schema extends Schema, name extends EventNames<config>, sourceName extends ExtractSourceName<name> = ExtractSourceName<name>, sourceNetwork = sourceName extends sourceName ? (unknown extends config["contracts"][sourceName]["network"] ? never : config["contracts"][sourceName]["network"]) | (unknown extends config["blocks"][sourceName]["network"] ? never : config["blocks"][sourceName]["network"]) : never> = {
        contracts: {
            [_contractName in keyof config["contracts"]]: {
                abi: config["contracts"][_contractName]["abi"];
                address: ExtractOverridenProperty<config["contracts"][_contractName], "address">;
                startBlock: ExtractOverridenProperty<config["contracts"][_contractName], "startBlock">;
                endBlock: ExtractOverridenProperty<config["contracts"][_contractName], "endBlock">;
            };
        };
        network: sourceNetwork extends string ? {
            name: sourceNetwork;
            chainId: config["networks"][sourceNetwork]["chainId"];
        } : {
            [key in keyof sourceNetwork]: {
                name: key;
                chainId: config["networks"][key & keyof config["networks"]]["chainId"];
            };
        }[keyof sourceNetwork];
        client: Prettify<Omit<ReadOnlyClient, "extend" | "key" | "batch" | "cacheTime" | "account" | "type" | "uid" | "chain" | "name" | "pollingInterval" | "transport" | "ccipRead">>;
        db: Db<schema>;
    };
    export type IndexingFunctionArgs<config extends Config, schema extends Schema, name extends EventNames<config>> = {
        event: Event<config, name>;
        context: Context<config, schema, name>;
    };
    export type Registry<config extends Config, schema extends Schema> = {
        on: <name extends EventNames<config>>(_name: name, indexingFunction: (args: {
            event: Event<config, name>;
        } & {
            context: Prettify<Context<config, schema, name>>;
        }) => Promise<void> | void) => void;
    } & ApiRegistry<schema>;
    export type ApiContext<schema extends Schema> = {
        db: Drizzle<schema>;
    };
    export {  };
}

/**
 * Middleware for GraphQL with an interactive web view.
 *
 * - Docs: https://ponder.sh/docs/query/api-functions#register-graphql-middleware
 *
 * @example
 * import { ponder } from "@/generated";
 * import { graphql } from "@ponder/core";
 *
 * ponder.use("/graphql", graphql());
 *
 */
declare const graphql: ({ maxOperationTokens, maxOperationDepth, maxOperationAliases, }?: {
    maxOperationTokens?: number | undefined;
    maxOperationDepth?: number | undefined;
    maxOperationAliases?: number | undefined;
}) => hono.MiddlewareHandler<any, string, {}>;

type ContractConfig = Prettify<Config["contracts"][string]>;
type NetworkConfig = Prettify<Config["networks"][string]>;
type BlockConfig = Prettify<Config["blocks"][string]>;
type DatabaseConfig = Prettify<Config["database"]>;

export { type Block, type BlockConfig, type ContractConfig, type DatabaseConfig, type Log, type NetworkConfig, type Transaction, type TransactionReceipt, Virtual, bigint, createConfig, graphql, hex, onchainEnum, onchainSchema, onchainTable, primaryKey };

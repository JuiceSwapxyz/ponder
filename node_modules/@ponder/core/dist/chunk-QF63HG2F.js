// src/drizzle/index.ts
import {
  Table,
  getTableColumns,
  getTableName,
  is as is2
} from "drizzle-orm";
import {
  PgEnumColumnBuilder,
  PgSchema as PgSchema2,
  PgTable as PgTable2,
  primaryKey as drizzlePrimaryKey,
  getTableConfig as getTableConfig2
} from "drizzle-orm/pg-core";
import {
  getPgColumnBuilders
} from "drizzle-orm/pg-core/columns/all";

// src/drizzle/bigint.ts
import {
  entityKind
} from "drizzle-orm";
import {
  PgColumn,
  PgColumnBuilder
} from "drizzle-orm/pg-core";
var PgBigintBuilder = class extends PgColumnBuilder {
  static [entityKind] = "PgEvmBigintBuilder";
  constructor(name) {
    super(name, "bigint", "PgEvmBigint");
  }
  /** @internal */
  // @ts-ignore
  build(table) {
    return new PgBigint(
      table,
      this.config
    );
  }
};
var PgBigint = class extends PgColumn {
  static [entityKind] = "PgEvmBigint";
  getSQLType() {
    return "numeric(78)";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
};

// src/drizzle/hex.ts
import {
  entityKind as entityKind2
} from "drizzle-orm";
import {
  PgColumn as PgColumn2,
  PgColumnBuilder as PgColumnBuilder2
} from "drizzle-orm/pg-core";
var PgHexBuilder = class extends PgColumnBuilder2 {
  static [entityKind2] = "PgHexBuilder";
  constructor(name) {
    super(name, "string", "PgHex");
  }
  /** @internal */
  // @ts-ignore
  build(table) {
    return new PgHex(
      table,
      this.config
    );
  }
};
var PgHex = class extends PgColumn2 {
  static [entityKind2] = "PgHex";
  getSQLType() {
    return "text";
  }
  mapToDriverValue(value) {
    if (value.length % 2 === 0)
      return value.toLowerCase();
    return `0x0${value.slice(2)}`.toLowerCase();
  }
};

// src/drizzle/kit/index.ts
import { SQL, is } from "drizzle-orm";
import { CasingCache, toCamelCase, toSnakeCase } from "drizzle-orm/casing";
import {
  PgDialect,
  PgEnumColumn,
  PgMaterializedView,
  PgSchema,
  PgTable,
  PgView,
  getTableConfig,
  integer,
  isPgEnum,
  isPgSequence,
  pgTable,
  serial,
  varchar
} from "drizzle-orm/pg-core";
var getSql = (schema, instanceId) => {
  const { tables, enums, schemas } = prepareFromExports(schema);
  const json = generatePgSnapshot(tables, enums, schemas, "snake_case");
  const squashed = squashPgScheme(json);
  const jsonCreateIndexesForCreatedTables = Object.values(
    squashed.tables
  ).flatMap((it) => {
    return preparePgCreateIndexesJson(it.name, it.schema, it.indexes);
  });
  const jsonCreateEnums = Object.values(squashed.enums).map((it) => {
    return prepareCreateEnumJson(it.name, it.schema, it.values);
  }) ?? [];
  const jsonCreateSchemas = prepareCreateSchemasJson(
    Object.values(squashed.schemas)
  );
  const jsonCreateTables = Object.values(squashed.tables).map((it) => {
    return preparePgCreateTableJson(it, json);
  });
  const fromJson = (statements) => statements.flatMap((statement) => {
    const filtered = convertors.filter((it) => {
      return it.can(statement, "postgresql");
    });
    const convertor = filtered.length === 1 ? filtered[0] : void 0;
    if (!convertor) {
      return "";
    }
    return convertor.convert(statement);
  }).filter((it) => it !== "");
  const combinedTables = jsonCreateTables.flatMap((statement) => [
    {
      ...statement,
      tableName: userToSqlTableName(
        sqlToUserTableName(statement.tableName),
        instanceId
      )
    },
    createReorgTableStatement(statement, instanceId)
  ]);
  return {
    schema: { sql: fromJson(jsonCreateSchemas), json: jsonCreateSchemas },
    tables: {
      sql: fromJson(combinedTables),
      json: combinedTables
    },
    enums: { sql: fromJson(jsonCreateEnums), json: jsonCreateEnums },
    indexes: {
      sql: fromJson(jsonCreateIndexesForCreatedTables),
      json: jsonCreateIndexesForCreatedTables
    }
  };
};
var createReorgTableStatement = (statement, instance_id) => {
  const reorgStatement = structuredClone(statement);
  reorgStatement.compositePkName = void 0;
  reorgStatement.compositePKs = [];
  for (const column of reorgStatement.columns) {
    column.primaryKey = false;
  }
  const reorgColumns = Object.values(
    squashPgScheme(
      generatePgSnapshot(
        [
          pgTable("", {
            operation_id: serial("operation_id").notNull().primaryKey(),
            operation: integer("operation").notNull(),
            checkpoint: varchar("checkpoint", {
              length: 75
            }).notNull()
          })
        ],
        [],
        [],
        "snake_case"
      )
    ).tables
    //@ts-ignore
  )[0].columns;
  reorgStatement.columns.push(...Object.values(reorgColumns));
  reorgStatement.tableName = `${instance_id}_reorg__${reorgStatement.tableName.slice(6)}`;
  return reorgStatement;
};
var PgSquasher = {
  squashIdx: (idx) => {
    return `${idx.name};${idx.columns.map(
      (c) => `${c.expression}--${c.isExpression}--${c.asc}--${c.nulls}--${c.opclass && ""}`
    ).join(
      ",,"
    )};${idx.isUnique};${idx.concurrently};${idx.method};${idx.where};${JSON.stringify(idx.with)}`;
  },
  unsquashIdx: (input) => {
    const [
      name,
      columnsString,
      isUnique,
      concurrently,
      method,
      where,
      idxWith
    ] = input.split(";");
    const columnString = columnsString.split(",,");
    const columns = [];
    for (const column of columnString) {
      const [expression, isExpression, asc2, nulls, opclass] = column.split("--");
      columns.push({
        nulls,
        isExpression: isExpression === "true",
        asc: asc2 === "true",
        expression,
        opclass: opclass === "undefined" ? void 0 : opclass
      });
    }
    return {
      name,
      columns,
      isUnique: isUnique === "true",
      concurrently: concurrently === "true",
      method,
      where: where === "undefined" ? void 0 : where,
      with: !idxWith || idxWith === "undefined" ? void 0 : JSON.parse(idxWith)
    };
  },
  squashPK: (pk) => {
    return `${pk.columns.join(",")};${pk.name}`;
  },
  unsquashPK: (pk) => {
    const splitted = pk.split(";");
    return { name: splitted[1], columns: splitted[0].split(",") };
  }
};
var parseType = (schemaPrefix, type) => {
  const pgNativeTypes = [
    "uuid",
    "smallint",
    "integer",
    "bigint",
    "boolean",
    "text",
    "varchar",
    "serial",
    "bigserial",
    "decimal",
    "numeric",
    "real",
    "json",
    "jsonb",
    "time",
    "time with time zone",
    "time without time zone",
    "time",
    "timestamp",
    "timestamp with time zone",
    "timestamp without time zone",
    "date",
    "interval",
    "bigint",
    "bigserial",
    "double precision",
    "interval year",
    "interval month",
    "interval day",
    "interval hour",
    "interval minute",
    "interval second",
    "interval year to month",
    "interval day to hour",
    "interval day to minute",
    "interval day to second",
    "interval hour to minute",
    "interval hour to second",
    "interval minute to second"
  ];
  const arrayDefinitionRegex = /\[\d*(?:\[\d*\])*\]/g;
  const arrayDefinition = (type.match(arrayDefinitionRegex) ?? []).join("");
  const withoutArrayDefinition = type.replace(arrayDefinitionRegex, "");
  return pgNativeTypes.some((it) => type.startsWith(it)) ? `${withoutArrayDefinition}${arrayDefinition}` : `${schemaPrefix}"${withoutArrayDefinition}"${arrayDefinition}`;
};
var Convertor = class {
};
var PgCreateTableConvertor = class extends Convertor {
  can(statement, dialect) {
    return statement.type === "create_table" && dialect === "postgresql";
  }
  convert(st) {
    const { tableName, schema, columns, compositePKs } = st;
    let statement = "";
    const name = schema ? `"${schema}"."${tableName}"` : `"${tableName}"`;
    statement += `CREATE TABLE ${name} (
`;
    for (let i = 0; i < columns.length; i++) {
      const column = columns[i];
      const primaryKeyStatement = column.primaryKey ? " PRIMARY KEY" : "";
      const notNullStatement = column.notNull && !column.identity ? " NOT NULL" : "";
      const defaultStatement = column.default !== void 0 ? ` DEFAULT ${column.default}` : "";
      const schemaPrefix = column.typeSchema && column.typeSchema !== "public" ? `"${column.typeSchema}".` : "";
      const type = parseType(schemaPrefix, column.type);
      statement += `	"${column.name}" ${type}${primaryKeyStatement}${defaultStatement}${notNullStatement}`;
      statement += i === columns.length - 1 ? "" : ",\n";
    }
    if (typeof compositePKs !== "undefined" && compositePKs.length > 0) {
      statement += ",\n";
      const compositePK = PgSquasher.unsquashPK(compositePKs[0]);
      statement += `	CONSTRAINT "${st.compositePkName}" PRIMARY KEY("${compositePK.columns.join(`","`)}")`;
    }
    statement += "\n);";
    statement += "\n";
    return statement;
  }
};
var CreateTypeEnumConvertor = class extends Convertor {
  can(statement) {
    return statement.type === "create_type_enum";
  }
  convert(st) {
    const { name, values, schema } = st;
    const enumNameWithSchema = schema ? `"${schema}"."${name}"` : `"${name}"`;
    let valuesStatement = "(";
    valuesStatement += values.map((it) => `'${it}'`).join(", ");
    valuesStatement += ")";
    const statement = `CREATE TYPE ${enumNameWithSchema} AS ENUM${valuesStatement};`;
    return statement;
  }
};
var CreatePgIndexConvertor = class extends Convertor {
  can(statement, dialect) {
    return statement.type === "create_index_pg" && dialect === "postgresql";
  }
  convert(statement) {
    const {
      name,
      columns,
      isUnique,
      concurrently,
      with: withMap,
      method,
      where
    } = statement.data;
    const indexPart = isUnique ? "UNIQUE INDEX" : "INDEX";
    const value = columns.map(
      (it) => `${it.isExpression ? it.expression : `"${it.expression}"`}${it.opclass ? ` ${it.opclass}` : it.asc ? "" : " DESC"}${it.asc && it.nulls && it.nulls === "last" || it.opclass ? "" : ` NULLS ${it.nulls.toUpperCase()}`}`
    ).join(",");
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    function reverseLogic(mappedWith) {
      let reversedString = "";
      for (const key in mappedWith) {
        if (mappedWith.hasOwnProperty(key)) {
          reversedString += `${key}=${mappedWith[key]},`;
        }
      }
      reversedString = reversedString.slice(0, -1);
      return reversedString;
    }
    return `CREATE ${indexPart}${concurrently ? " CONCURRENTLY" : ""} IF NOT EXISTS "${name}" ON ${tableNameWithSchema} USING ${method} (${value})${Object.keys(withMap).length !== 0 ? ` WITH (${reverseLogic(withMap)})` : ""}${where ? ` WHERE ${where}` : ""};`;
  }
};
var PgCreateSchemaConvertor = class extends Convertor {
  can(statement, dialect) {
    return statement.type === "create_schema" && dialect === "postgresql";
  }
  convert(statement) {
    const { name } = statement;
    return `CREATE SCHEMA IF NOT EXISTS"${name}";
`;
  }
};
var convertors = [];
convertors.push(new PgCreateTableConvertor());
convertors.push(new CreateTypeEnumConvertor());
convertors.push(new CreatePgIndexConvertor());
convertors.push(new PgCreateSchemaConvertor());
var preparePgCreateTableJson = (table, json) => {
  const { name, schema, columns, compositePrimaryKeys } = table;
  const tableKey = `${schema || "public"}.${name}`;
  const compositePkName = Object.values(compositePrimaryKeys).length > 0 ? json.tables[tableKey].compositePrimaryKeys[`${PgSquasher.unsquashPK(Object.values(compositePrimaryKeys)[0]).name}`].name : "";
  return {
    type: "create_table",
    tableName: name,
    schema,
    columns: Object.values(columns),
    compositePKs: Object.values(compositePrimaryKeys),
    compositePkName
  };
};
var preparePgCreateIndexesJson = (tableName, schema, indexes) => {
  return Object.values(indexes).map((indexData) => {
    return {
      type: "create_index_pg",
      tableName,
      data: PgSquasher.unsquashIdx(indexData),
      schema
    };
  });
};
var prepareCreateSchemasJson = (values) => {
  return values.map((it) => {
    return {
      type: "create_schema",
      name: it
    };
  });
};
var prepareCreateEnumJson = (name, schema, values) => {
  return {
    type: "create_type_enum",
    name,
    schema,
    values
  };
};
var prepareFromExports = (exports) => {
  const tables = [];
  const enums = [];
  const schemas = [];
  const sequences = [];
  const views = [];
  const matViews = [];
  const i0values = Object.values(exports);
  i0values.forEach((t) => {
    if (isPgEnum(t)) {
      enums.push(t);
      return;
    }
    if (is(t, PgTable)) {
      tables.push(t);
    }
    if (is(t, PgSchema)) {
      schemas.push(t);
    }
    if (is(t, PgView)) {
      views.push(t);
    }
    if (is(t, PgMaterializedView)) {
      matViews.push(t);
    }
    if (isPgSequence(t)) {
      sequences.push(t);
    }
  });
  return { tables, enums, schemas, sequences, views, matViews };
};
function getColumnCasing(column, casing) {
  if (!column.name)
    return "";
  return !column.keyAsName || casing === void 0 ? column.name : casing === "camelCase" ? toCamelCase(column.name) : toSnakeCase(column.name);
}
var sqlToStr = (sql, casing) => {
  return sql.toQuery({
    escapeName: () => {
      throw new Error("we don't support params for `sql` default values");
    },
    escapeParam: () => {
      throw new Error("we don't support params for `sql` default values");
    },
    escapeString: () => {
      throw new Error("we don't support params for `sql` default values");
    },
    casing: new CasingCache(casing)
  }).sql;
};
function isPgArrayType(sqlType) {
  return sqlType.match(/.*\[\d*\].*|.*\[\].*/g) !== null;
}
function buildArrayString(array, sqlType) {
  sqlType = sqlType.split("[")[0];
  const values = array.map((value) => {
    if (typeof value === "number" || typeof value === "bigint") {
      return value.toString();
    } else if (typeof value === "boolean") {
      return value ? "true" : "false";
    } else if (Array.isArray(value)) {
      return buildArrayString(value, sqlType);
    } else if (value instanceof Date) {
      if (sqlType === "date") {
        return `"${value.toISOString().split("T")[0]}"`;
      } else if (sqlType === "timestamp") {
        return `"${value.toISOString().replace("T", " ").slice(0, 23)}"`;
      } else {
        return `"${value.toISOString()}"`;
      }
    } else if (typeof value === "object") {
      return `"${JSON.stringify(value).replaceAll('"', '\\"')}"`;
    }
    return `"${value}"`;
  }).join(",");
  return `{${values}}`;
}
var indexName = (tableName, columns) => {
  return `${tableName}_${columns.join("_")}_index`;
};
var generatePgSnapshot = (tables, enums, schemas, casing) => {
  const dialect = new PgDialect({ casing });
  const result = {};
  const indexesInSchema = {};
  for (const table of tables) {
    const {
      name: tableName,
      columns,
      indexes,
      schema,
      primaryKeys
    } = getTableConfig(table);
    const columnsObject = {};
    const indexesObject = {};
    const primaryKeysObject = {};
    columns.forEach((column) => {
      const name = getColumnCasing(column, casing);
      const notNull = column.notNull;
      const primaryKey2 = column.primary;
      const sqlTypeLowered = column.getSQLType().toLowerCase();
      const typeSchema = is(column, PgEnumColumn) ? column.enum.schema || "public" : void 0;
      const columnToSet = {
        name,
        type: column.getSQLType(),
        typeSchema,
        primaryKey: primaryKey2,
        notNull
      };
      if (column.default !== void 0) {
        if (is(column.default, SQL)) {
          columnToSet.default = sqlToStr(column.default, casing);
        } else {
          if (typeof column.default === "string") {
            columnToSet.default = `'${column.default}'`;
          } else {
            if (sqlTypeLowered === "jsonb" || sqlTypeLowered === "json") {
              columnToSet.default = `'${JSON.stringify(column.default)}'::${sqlTypeLowered}`;
            } else if (column.default instanceof Date) {
              if (sqlTypeLowered === "date") {
                columnToSet.default = `'${column.default.toISOString().split("T")[0]}'`;
              } else if (sqlTypeLowered === "timestamp") {
                columnToSet.default = `'${column.default.toISOString().replace("T", " ").slice(0, 23)}'`;
              } else {
                columnToSet.default = `'${column.default.toISOString()}'`;
              }
            } else if (isPgArrayType(sqlTypeLowered) && Array.isArray(column.default)) {
              columnToSet.default = `'${buildArrayString(column.default, sqlTypeLowered)}'`;
            } else {
              columnToSet.default = column.default;
            }
          }
        }
      }
      columnsObject[name] = columnToSet;
    });
    primaryKeys.map((pk) => {
      const originalColumnNames = pk.columns.map((c) => c.name);
      const columnNames = pk.columns.map((c) => getColumnCasing(c, casing));
      let name = pk.getName();
      if (casing !== void 0) {
        for (let i = 0; i < originalColumnNames.length; i++) {
          name = name.replace(originalColumnNames[i], columnNames[i]);
        }
      }
      primaryKeysObject[name] = {
        name,
        columns: columnNames
      };
    });
    indexes.forEach((value) => {
      const columns2 = value.config.columns;
      const indexColumnNames = [];
      columns2.forEach((it) => {
        const name2 = getColumnCasing(it, casing);
        indexColumnNames.push(name2);
      });
      const name = value.config.name ? value.config.name : indexName(tableName, indexColumnNames);
      const indexColumns = columns2.map(
        (it) => {
          if (is(it, SQL)) {
            return {
              expression: dialect.sqlToQuery(it, "indexes").sql,
              asc: true,
              isExpression: true,
              nulls: "last"
            };
          } else {
            it = it;
            return {
              expression: getColumnCasing(it, casing),
              isExpression: false,
              // @ts-ignore
              asc: it.indexConfig?.order === "asc",
              // @ts-ignore
              nulls: it.indexConfig?.nulls ? (
                // @ts-ignore
                it.indexConfig?.nulls
              ) : (
                // @ts-ignore
                it.indexConfig?.order === "desc" ? "first" : "last"
              ),
              // @ts-ignore
              opclass: it.indexConfig?.opClass
            };
          }
        }
      );
      if (typeof indexesInSchema[schema ?? "public"] !== "undefined") {
        indexesInSchema[schema ?? "public"].push(name);
      } else {
        indexesInSchema[schema ?? "public"] = [name];
      }
      indexesObject[name] = {
        name,
        columns: indexColumns,
        isUnique: value.config.unique ?? false,
        where: value.config.where ? dialect.sqlToQuery(value.config.where).sql : void 0,
        concurrently: value.config.concurrently ?? false,
        method: value.config.method ?? "btree",
        with: value.config.with ?? {}
      };
    });
    const tableKey = `${schema ?? "public"}.${tableName}`;
    result[tableKey] = {
      name: tableName,
      schema: schema ?? "",
      columns: columnsObject,
      indexes: indexesObject,
      compositePrimaryKeys: primaryKeysObject
    };
  }
  const enumsToReturn = enums.reduce((map, obj) => {
    const enumSchema = obj.schema || "public";
    const key = `${enumSchema}.${obj.enumName}`;
    map[key] = {
      name: obj.enumName,
      schema: enumSchema,
      values: obj.enumValues
    };
    return map;
  }, {});
  const schemasObject = Object.fromEntries(
    schemas.filter((it) => {
      return it.schemaName !== "public";
    }).map((it) => [it.schemaName, it.schemaName])
  );
  return {
    version: "7",
    dialect: "postgresql",
    tables: result,
    enums: enumsToReturn,
    schemas: schemasObject
  };
};
var mapValues = (obj, map) => {
  const result = Object.keys(obj).reduce(
    (result2, key) => {
      result2[key] = map(obj[key]);
      return result2;
    },
    {}
  );
  return result;
};
var squashPgScheme = (json) => {
  const mappedTables = Object.fromEntries(
    Object.entries(json.tables).map((it) => {
      const squashedIndexes = mapValues(it[1].indexes, (index) => {
        return PgSquasher.squashIdx(index);
      });
      const squashedPKs = mapValues(it[1].compositePrimaryKeys, (pk) => {
        return PgSquasher.squashPK(pk);
      });
      const mappedColumns = Object.fromEntries(
        Object.entries(it[1].columns).map((it2) => {
          return [
            it2[0],
            {
              ...it2[1],
              identity: void 0
            }
          ];
        })
      );
      return [
        it[0],
        {
          name: it[1].name,
          schema: it[1].schema,
          columns: mappedColumns,
          indexes: squashedIndexes,
          compositePrimaryKeys: squashedPKs
        }
      ];
    })
  );
  return {
    version: "7",
    dialect: json.dialect,
    tables: mappedTables,
    enums: json.enums,
    schemas: json.schemas,
    views: json.views
  };
};

// src/drizzle/index.ts
function hex(columnName) {
  return new PgHexBuilder(columnName ?? "");
}
function bigint(columnName) {
  return new PgBigintBuilder(columnName ?? "");
}
var onchain = Symbol.for("ponder:onchain");
var userToSqlTableName = (tableName, instanceId) => `${instanceId}__${tableName}`;
var sqlToUserTableName = (tableName) => tableName.slice(6);
var userToReorgTableName = (tableName, instanceId) => `${instanceId}_reorg__${tableName}`;
var getTableNames = (schema, instanceId) => {
  const tableNames = Object.entries(schema).filter(([, table]) => is2(table, PgTable2)).map(([js, table]) => {
    const tableName = getTableName(table);
    const user = sqlToUserTableName(tableName);
    return {
      user,
      sql: userToSqlTableName(user, instanceId),
      reorg: userToReorgTableName(user, instanceId),
      trigger: userToReorgTableName(user, instanceId),
      triggerFn: `operation_${instanceId}_reorg__${user}()`,
      js
    };
  });
  return tableNames;
};
var getPrimaryKeyColumns = (table) => {
  const primaryKeys = getTableConfig2(table).primaryKeys;
  const findJsName = (column) => {
    const name = column.name;
    for (const [js, column2] of Object.entries(getTableColumns(table))) {
      if (column2.name === name)
        return js;
    }
    throw "unreachable";
  };
  if (primaryKeys.length > 0) {
    return primaryKeys[0].columns.map((column) => ({
      sql: getColumnCasing(column, "snake_case"),
      js: findJsName(column)
    }));
  }
  const pkColumn = Object.values(getTableColumns(table)).find(
    (c) => c.primary
  );
  return [
    {
      sql: getColumnCasing(pkColumn, "snake_case"),
      js: findJsName(pkColumn)
    }
  ];
};
var primaryKey = ({
  name,
  columns
}) => drizzlePrimaryKey({ name, columns });
var onchainTable = (name, columns, extraConfig) => {
  const instanceId = process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ?? // @ts-ignore
  globalThis.__PONDER_INSTANCE_ID;
  if (instanceId === void 0) {
    const table2 = pgTableWithSchema(
      name,
      columns,
      extraConfig,
      void 0
    );
    table2[onchain] = true;
    return table2;
  }
  const table = pgTableWithSchema(
    userToSqlTableName(name, instanceId),
    columns,
    extraConfig,
    void 0
  );
  table[onchain] = true;
  return table;
};
var OnchainSchema = class extends PgSchema2 {
  table = (name, columns, extraConfig) => {
    const instanceId = process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ?? // @ts-ignore
    globalThis.__PONDER_INSTANCE_ID;
    if (instanceId === void 0) {
      const table2 = pgTableWithSchema(
        name,
        columns,
        extraConfig,
        this.schemaName
      );
      table2[onchain] = true;
      return table2;
    }
    const table = pgTableWithSchema(
      // @ts-ignore
      userToSqlTableName(name, instanceId),
      columns,
      extraConfig,
      this.schemaName
    );
    table[onchain] = true;
    return table;
  };
  enum = (enumName, values) => {
    const instanceId = process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ?? // @ts-ignore
    globalThis.__PONDER_INSTANCE_ID;
    if (instanceId === void 0) {
      const e2 = pgEnumWithSchema(enumName, values, this.schemaName);
      e2[onchain] = true;
      return e2;
    }
    const e = pgEnumWithSchema(
      userToSqlTableName(enumName, instanceId),
      values,
      this.schemaName
    );
    e[onchain] = true;
    return e;
  };
};
var onchainSchema = (name) => new OnchainSchema(name);
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
var onchainEnum = (enumName, values) => {
  const instanceId = globalThis.__PONDER_INSTANCE_ID;
  if (instanceId === void 0) {
    const e2 = pgEnumWithSchema(enumName, values, void 0);
    e2[onchain] = true;
    return e2;
  }
  const e = pgEnumWithSchema(
    // @ts-ignore
    userToSqlTableName(enumName, instanceId),
    values,
    void 0
  );
  e[onchain] = true;
  return e;
};
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable2(name, schema, baseName);
  const { bigint: int8, ...restColumns } = getPgColumnBuilders();
  const parsedColumns = typeof columns === "function" ? columns({ ...restColumns, int8, hex, bigint }) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(
        ...colBuilder.buildForeignKeys(column, rawTable)
      );
      return [name2, column];
    })
  );
  const builtColumnsForExtraConfig = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.buildExtraConfigColumn(rawTable);
      return [name2, column];
    })
  );
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable2.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable2.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
function pgEnumWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign(
    (name) => new PgEnumColumnBuilder(name ?? "", enumInstance),
    {
      enumName,
      enumValues: values,
      schema,
      [isPgEnumSym]: true
    }
  );
  return enumInstance;
}

// src/ui/graphiql.html.ts
var graphiQLHtml = (path) => `<!--
 *  Copyright (c) 2021 GraphQL Contributors
 *  All rights reserved.
 *
 *  This source code is licensed under the license found in the
 *  LICENSE file in the root directory of this source tree.
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Ponder Playground</title>
    <style>
      body {
        height: 100%;
        margin: 0;
        width: 100%;
        overflow: hidden;
      }
      #graphiql {
        height: 100vh;
      }
      *::-webkit-scrollbar {
        height: 0.3rem;
        width: 0.5rem;
      }
      *::-webkit-scrollbar-track {
        -ms-overflow-style: none;
        overflow: -moz-scrollbars-none;
      }
      *::-webkit-scrollbar-thumb {
        -ms-overflow-style: none;
        overflow: -moz-scrollbars-none;
      }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/graphiql@3.7.2/graphiql.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/@graphiql/plugin-explorer@3.2.3/dist/style.css" />
  </head>
  <body>
    <div id="graphiql">Loading...</div>
    <script crossorigin src="https://unpkg.com/react@18.3.1/umd/react.development.js"></script>1
    <script crossorigin src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/graphiql@3.7.2/graphiql.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@graphiql/plugin-explorer@3.2.3/dist/index.umd.js" crossorigin="anonymous"></script>
    <script>
      const fetcher = GraphiQL.createFetcher({ url: "${path}" });
      const explorerPlugin = GraphiQLPluginExplorer.explorerPlugin();
      const root = ReactDOM.createRoot(document.getElementById("graphiql"));
      root.render(
        React.createElement(GraphiQL, {
          fetcher,
          plugins: [explorerPlugin],
          defaultEditorToolsVisibility: false,
        })
      );
    </script>
  </body>
</html>`;

// src/graphql/middleware.ts
import { maxAliasesPlugin } from "@escape.tech/graphql-armor-max-aliases";
import { maxDepthPlugin } from "@escape.tech/graphql-armor-max-depth";
import { maxTokensPlugin } from "@escape.tech/graphql-armor-max-tokens";
import { createYoga } from "graphql-yoga";
import { createMiddleware } from "hono/factory";

// src/utils/never.ts
var never = (_x) => {
  throw "unreachable";
};

// src/utils/serialize.ts
function serialize(value) {
  return JSON.stringify(
    value,
    (_, v) => typeof v === "bigint" ? { __type: "bigint", value: v.toString() } : v
  );
}
function deserialize(value) {
  return JSON.parse(
    value,
    (_, value_) => value_?.__type === "bigint" ? BigInt(value_.value) : value_
  );
}

// src/graphql/index.ts
import DataLoader from "dataloader";
import {
  Many,
  One,
  and,
  arrayContained,
  arrayContains,
  asc,
  count,
  createTableRelationsHelpers,
  desc,
  eq,
  extractTablesRelationalConfig,
  getTableColumns as getTableColumns2,
  gt,
  gte,
  inArray,
  is as is3,
  like,
  lt,
  lte,
  ne,
  not,
  notInArray,
  notLike,
  or
} from "drizzle-orm";
import {
  PgInteger,
  PgSerial,
  isPgEnum as isPgEnum2
} from "drizzle-orm/pg-core";
import {
  GraphQLBoolean,
  GraphQLEnumType,
  GraphQLFloat,
  GraphQLInputObjectType,
  GraphQLInt,
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLScalarType as GraphQLScalarType2,
  GraphQLSchema,
  GraphQLString
} from "graphql";

// src/graphql/json.ts
import {
  GraphQLScalarType,
  Kind,
  print
} from "graphql";
var GraphQLJSON = new GraphQLScalarType({
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: (x) => x,
  parseValue: (x) => x,
  parseLiteral: (ast, variables) => {
    if (ast.kind !== Kind.OBJECT) {
      throw new TypeError(
        `JSONObject cannot represent non-object value: ${print(ast)}`
      );
    }
    return parseObject(ast, variables);
  }
});
var parseLiteral = (ast, variables) => {
  switch (ast.kind) {
    case Kind.STRING:
    case Kind.BOOLEAN:
      return ast.value;
    case Kind.INT:
    case Kind.FLOAT:
      return Number.parseFloat(ast.value);
    case Kind.OBJECT:
      return parseObject(ast, variables);
    case Kind.LIST:
      return ast.values.map((n) => parseLiteral(n, variables));
    case Kind.NULL:
      return null;
    case Kind.VARIABLE:
      return variables ? variables[ast.name.value] : void 0;
    default:
      throw new TypeError(`JSON cannot represent value: ${print(ast)}`);
  }
};
var parseObject = (ast, variables) => {
  const value = /* @__PURE__ */ Object.create(null);
  ast.fields.forEach((field) => {
    value[field.name.value] = parseLiteral(field.value, variables);
  });
  return value;
};

// src/graphql/index.ts
var DEFAULT_LIMIT = 50;
var MAX_LIMIT = 1e3;
function buildGraphQLSchema(schema) {
  const tablesConfig = extractTablesRelationalConfig(
    schema,
    createTableRelationsHelpers
  );
  const tables = Object.values(tablesConfig.tables);
  const enums = Object.entries(schema).filter(
    (el) => isPgEnum2(el[1])
  );
  const enumTypes = {};
  for (const [enumTsName, enumObject] of enums) {
    enumTypes[enumObject.enumName] = new GraphQLEnumType({
      name: enumTsName,
      values: enumObject.enumValues.reduce(
        (acc, cur) => ({ ...acc, [cur]: {} }),
        {}
      )
    });
  }
  const entityFilterTypes = {};
  for (const table of tables) {
    const filterType = new GraphQLInputObjectType({
      name: `${table.tsName}Filter`,
      fields: () => {
        const filterFields = {
          // Logical operators
          AND: { type: new GraphQLList(filterType) },
          OR: { type: new GraphQLList(filterType) }
        };
        for (const [columnName, column] of Object.entries(table.columns)) {
          const type = columnToGraphQLCore(column, enumTypes);
          if (type instanceof GraphQLList) {
            const baseType = innerType(type);
            conditionSuffixes.universal.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type: new GraphQLList(baseType)
              };
            });
            conditionSuffixes.plural.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = { type: baseType };
            });
          }
          if (type instanceof GraphQLScalarType2 || type instanceof GraphQLEnumType) {
            if (type.name === "JSON")
              continue;
            conditionSuffixes.universal.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type
              };
            });
            conditionSuffixes.singular.forEach((suffix) => {
              filterFields[`${columnName}${suffix}`] = {
                type: new GraphQLList(type)
              };
            });
            if (["String", "ID"].includes(type.name)) {
              conditionSuffixes.string.forEach((suffix) => {
                filterFields[`${columnName}${suffix}`] = {
                  type
                };
              });
            }
            if (["Int", "Float", "BigInt"].includes(type.name)) {
              conditionSuffixes.numeric.forEach((suffix) => {
                filterFields[`${columnName}${suffix}`] = {
                  type
                };
              });
            }
          }
        }
        return filterFields;
      }
    });
    entityFilterTypes[table.tsName] = filterType;
  }
  const entityTypes = {};
  const entityPageTypes = {};
  for (const table of tables) {
    entityTypes[table.tsName] = new GraphQLObjectType({
      name: table.tsName,
      fields: () => {
        const fieldConfigMap = {};
        for (const [columnName, column] of Object.entries(table.columns)) {
          const type = columnToGraphQLCore(column, enumTypes);
          fieldConfigMap[columnName] = {
            type: column.notNull ? new GraphQLNonNull(type) : type
          };
        }
        const relations = Object.entries(table.relations);
        for (const [relationName, relation] of relations) {
          const referencedTable = tables.find(
            (table2) => table2.dbName === relation.referencedTableName
          );
          if (!referencedTable)
            throw new Error(
              `Internal error: Referenced table "${relation.referencedTableName}" not found`
            );
          const referencedEntityType = entityTypes[referencedTable.tsName];
          const referencedEntityPageType = entityPageTypes[referencedTable.tsName];
          const referencedEntityFilterType = entityFilterTypes[referencedTable.tsName];
          if (referencedEntityType === void 0 || referencedEntityPageType === void 0 || referencedEntityFilterType === void 0)
            throw new Error(
              `Internal error: Referenced entity types not found for table "${referencedTable.tsName}" `
            );
          if (is3(relation, One)) {
            const fields = relation.config?.fields ?? [];
            const references = relation.config?.references ?? [];
            if (fields.length !== references.length) {
              throw new Error(
                "Internal error: Fields and references arrays must be the same length"
              );
            }
            fieldConfigMap[relationName] = {
              // Note: There is a `relation.isNullable` field here but it appears
              // to be internal / incorrect. Until we have support for foriegn
              // key constraints, all `one` relations must be nullable.
              type: referencedEntityType,
              resolve: (parent, _args, context) => {
                const loader = context.getDataLoader({
                  table: referencedTable
                });
                const rowFragment = {};
                for (let i = 0; i < references.length; i++) {
                  const referenceColumn = references[i];
                  const fieldColumn = fields[i];
                  const fieldColumnTsName = getColumnTsName(fieldColumn);
                  const referenceColumnTsName = getColumnTsName(referenceColumn);
                  rowFragment[referenceColumnTsName] = parent[fieldColumnTsName];
                }
                const encodedId = encodeRowFragment(rowFragment);
                return loader.load(encodedId);
              }
            };
          } else if (is3(relation, Many)) {
            const oneRelation = Object.values(referencedTable.relations).find(
              (relation2) => relation2.relationName === relationName || is3(relation2, One) && relation2.referencedTableName === table.dbName
            );
            if (!oneRelation)
              throw new Error(
                `Internal error: Relation "${relationName}" not found in table "${referencedTable.tsName}"`
              );
            const fields = oneRelation.config?.fields ?? [];
            const references = oneRelation.config?.references ?? [];
            fieldConfigMap[relationName] = {
              type: referencedEntityPageType,
              args: {
                where: { type: referencedEntityFilterType },
                orderBy: { type: GraphQLString },
                orderDirection: { type: GraphQLString },
                before: { type: GraphQLString },
                after: { type: GraphQLString },
                limit: { type: GraphQLInt }
              },
              resolve: (parent, args, context, info) => {
                const relationalConditions = [];
                for (let i = 0; i < references.length; i++) {
                  const column = fields[i];
                  const value = parent[references[i].name];
                  relationalConditions.push(eq(column, value));
                }
                const includeTotalCount = selectionIncludesField(
                  info,
                  "totalCount"
                );
                return executePluralQuery(
                  referencedTable,
                  context.drizzle,
                  args,
                  includeTotalCount,
                  relationalConditions
                );
              }
            };
          } else {
            throw new Error(
              `Internal error: Relation "${relationName}" is unsupported, expected One or Many`
            );
          }
        }
        return fieldConfigMap;
      }
    });
    entityPageTypes[table.tsName] = new GraphQLObjectType({
      name: `${table.tsName}Page`,
      fields: () => ({
        items: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(entityTypes[table.tsName]))
          )
        },
        pageInfo: { type: new GraphQLNonNull(GraphQLPageInfo) },
        totalCount: { type: new GraphQLNonNull(GraphQLInt) }
      })
    });
  }
  const queryFields = {};
  for (const table of tables) {
    const entityType = entityTypes[table.tsName];
    const entityPageType = entityPageTypes[table.tsName];
    const entityFilterType = entityFilterTypes[table.tsName];
    const singularFieldName = table.tsName.charAt(0).toLowerCase() + table.tsName.slice(1);
    const pluralFieldName = `${singularFieldName}s`;
    queryFields[singularFieldName] = {
      type: entityType,
      // Find the primary key columns and GraphQL core types and include them
      // as arguments to the singular query type.
      args: Object.fromEntries(
        table.primaryKey.map((column) => [
          getColumnTsName(column),
          {
            type: new GraphQLNonNull(
              columnToGraphQLCore(column, enumTypes)
            )
          }
        ])
      ),
      resolve: async (_parent, args, context) => {
        const loader = context.getDataLoader({ table });
        const encodedId = encodeRowFragment(args);
        return loader.load(encodedId);
      }
    };
    queryFields[pluralFieldName] = {
      type: new GraphQLNonNull(entityPageType),
      args: {
        where: { type: entityFilterType },
        orderBy: { type: GraphQLString },
        orderDirection: { type: GraphQLString },
        before: { type: GraphQLString },
        after: { type: GraphQLString },
        limit: { type: GraphQLInt }
      },
      resolve: async (_parent, args, context, info) => {
        const includeTotalCount = selectionIncludesField(info, "totalCount");
        return executePluralQuery(
          table,
          context.drizzle,
          args,
          includeTotalCount
        );
      }
    };
  }
  queryFields._meta = {
    type: GraphQLMeta,
    resolve: async (_source, _args, context) => {
      const status = await context.metadataStore.getStatus();
      return { status };
    }
  };
  return new GraphQLSchema({
    // Include these here so they are listed first in the printed schema.
    types: [GraphQLJSON, GraphQLBigInt, GraphQLPageInfo, GraphQLMeta],
    query: new GraphQLObjectType({
      name: "Query",
      fields: queryFields
    })
  });
}
var GraphQLPageInfo = new GraphQLObjectType({
  name: "PageInfo",
  fields: {
    hasNextPage: { type: new GraphQLNonNull(GraphQLBoolean) },
    hasPreviousPage: { type: new GraphQLNonNull(GraphQLBoolean) },
    startCursor: { type: GraphQLString },
    endCursor: { type: GraphQLString }
  }
});
var GraphQLBigInt = new GraphQLScalarType2({
  name: "BigInt",
  serialize: (value) => String(value),
  parseValue: (value) => BigInt(value),
  parseLiteral: (value) => {
    if (value.kind === "StringValue") {
      return BigInt(value.value);
    } else {
      throw new Error(
        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`
      );
    }
  }
});
var GraphQLMeta = new GraphQLObjectType({
  name: "Meta",
  fields: { status: { type: GraphQLJSON } }
});
var columnToGraphQLCore = (column, enumTypes) => {
  if (column.columnType === "PgEvmBigint") {
    return GraphQLBigInt;
  }
  if (column.columnType === "PgEnumColumn") {
    const enumObject = column?.enum;
    if (enumObject === void 0) {
      throw new Error(
        `Internal error: Expected enum column "${getColumnTsName(column)}" to have an "enum" property`
      );
    }
    const enumType = enumTypes[enumObject.enumName];
    if (enumType === void 0) {
      throw new Error(
        `Internal error: Expected to find a GraphQL enum named "${enumObject.enumName}"`
      );
    }
    return enumType;
  }
  switch (column.dataType) {
    case "boolean":
      return GraphQLBoolean;
    case "json":
      return GraphQLJSON;
    case "date":
      return GraphQLString;
    case "string":
      return GraphQLString;
    case "bigint":
      return GraphQLString;
    case "number":
      return is3(column, PgInteger) || is3(column, PgSerial) ? GraphQLInt : GraphQLFloat;
    case "buffer":
      return new GraphQLList(new GraphQLNonNull(GraphQLInt));
    case "array": {
      if (column.columnType === "PgVector") {
        return new GraphQLList(new GraphQLNonNull(GraphQLFloat));
      }
      if (column.columnType === "PgGeometry") {
        return new GraphQLList(new GraphQLNonNull(GraphQLFloat));
      }
      const innerType2 = columnToGraphQLCore(
        column.baseColumn,
        enumTypes
      );
      return new GraphQLList(new GraphQLNonNull(innerType2));
    }
    default:
      throw new Error(`Type ${column.dataType} is not implemented`);
  }
};
var innerType = (type) => {
  if (type instanceof GraphQLScalarType2 || type instanceof GraphQLEnumType)
    return type;
  if (type instanceof GraphQLList || type instanceof GraphQLNonNull)
    return innerType(type.ofType);
  throw new Error(`Type ${type.toString()} is not implemented`);
};
async function executePluralQuery(table, drizzle, args, includeTotalCount, extraConditions = []) {
  const rawTable = drizzle._.fullSchema[table.tsName];
  const baseQuery = drizzle.query[table.tsName];
  if (rawTable === void 0 || baseQuery === void 0)
    throw new Error(`Internal error: Table "${table.tsName}" not found in RQB`);
  const limit = args.limit ?? DEFAULT_LIMIT;
  if (limit > MAX_LIMIT) {
    throw new Error(`Invalid limit. Got ${limit}, expected <=${MAX_LIMIT}.`);
  }
  const orderBySchema = buildOrderBySchema(table, args);
  const orderBy = orderBySchema.map(([columnName, direction]) => {
    const column = table.columns[columnName];
    if (column === void 0) {
      throw new Error(
        `Unknown column "${columnName}" used in orderBy argument`
      );
    }
    return direction === "asc" ? asc(column) : desc(column);
  });
  const orderByReversed = orderBySchema.map(([columnName, direction]) => {
    const column = table.columns[columnName];
    if (column === void 0) {
      throw new Error(
        `Unknown column "${columnName}" used in orderBy argument`
      );
    }
    return direction === "asc" ? desc(column) : asc(column);
  });
  const whereConditions = buildWhereConditions(args.where, table.columns);
  const after = args.after ?? null;
  const before = args.before ?? null;
  if (after !== null && before !== null) {
    throw new Error("Cannot specify both before and after cursors.");
  }
  let startCursor = null;
  let endCursor = null;
  let hasPreviousPage = false;
  let hasNextPage = false;
  const totalCountPromise = includeTotalCount ? drizzle.select({ count: count() }).from(rawTable).where(and(...whereConditions, ...extraConditions)).then((rows2) => rows2[0]?.count ?? null) : Promise.resolve(null);
  if (after === null && before === null) {
    const [rows2, totalCount2] = await Promise.all([
      baseQuery.findMany({
        where: and(...whereConditions, ...extraConditions),
        orderBy,
        limit: limit + 1
      }),
      totalCountPromise
    ]);
    if (rows2.length === limit + 1) {
      rows2.pop();
      hasNextPage = true;
    }
    startCursor = rows2.length > 0 ? encodeCursor(orderBySchema, rows2[0]) : null;
    endCursor = rows2.length > 0 ? encodeCursor(orderBySchema, rows2[rows2.length - 1]) : null;
    return {
      items: rows2,
      totalCount: totalCount2,
      pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor }
    };
  }
  if (after !== null) {
    const cursorObject2 = decodeCursor(after);
    const cursorCondition2 = buildCursorCondition(
      table,
      orderBySchema,
      "after",
      cursorObject2
    );
    const [rows2, totalCount2] = await Promise.all([
      baseQuery.findMany({
        where: and(...whereConditions, cursorCondition2, ...extraConditions),
        orderBy,
        limit: limit + 2
      }),
      totalCountPromise
    ]);
    if (rows2.length === 0) {
      return {
        items: rows2,
        totalCount: totalCount2,
        pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor }
      };
    }
    if (encodeCursor(orderBySchema, rows2[0]) === after) {
      rows2.shift();
      hasPreviousPage = true;
    } else {
      rows2.pop();
    }
    if (rows2.length === limit + 1) {
      rows2.pop();
      hasNextPage = true;
    }
    startCursor = rows2.length > 0 ? encodeCursor(orderBySchema, rows2[0]) : null;
    endCursor = rows2.length > 0 ? encodeCursor(orderBySchema, rows2[rows2.length - 1]) : null;
    return {
      items: rows2,
      totalCount: totalCount2,
      pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor }
    };
  }
  const cursorObject = decodeCursor(before);
  const cursorCondition = buildCursorCondition(
    table,
    orderBySchema,
    "before",
    cursorObject
  );
  const [rows, totalCount] = await Promise.all([
    baseQuery.findMany({
      where: and(...whereConditions, cursorCondition, ...extraConditions),
      orderBy: orderByReversed,
      limit: limit + 2
    }).then((rows2) => rows2.reverse()),
    totalCountPromise
  ]);
  if (rows.length === 0) {
    return {
      items: rows,
      totalCount,
      pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor }
    };
  }
  if (encodeCursor(orderBySchema, rows[rows.length - 1]) === before) {
    rows.pop();
    hasNextPage = true;
  } else {
    rows.shift();
  }
  if (rows.length === limit + 1) {
    rows.shift();
    hasPreviousPage = true;
  }
  startCursor = rows.length > 0 ? encodeCursor(orderBySchema, rows[0]) : null;
  endCursor = rows.length > 0 ? encodeCursor(orderBySchema, rows[rows.length - 1]) : null;
  return {
    items: rows,
    totalCount,
    pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor }
  };
}
var conditionSuffixes = {
  universal: ["", "_not"],
  singular: ["_in", "_not_in"],
  plural: ["_has", "_not_has"],
  numeric: ["_gt", "_lt", "_gte", "_lte"],
  string: [
    "_contains",
    "_not_contains",
    "_starts_with",
    "_ends_with",
    "_not_starts_with",
    "_not_ends_with"
  ]
};
var conditionSuffixesByLengthDesc = Object.values(conditionSuffixes).flat().sort((a, b) => b.length - a.length);
function buildWhereConditions(where, columns) {
  const conditions = [];
  if (where === void 0)
    return conditions;
  for (const [whereKey, rawValue] of Object.entries(where)) {
    if (whereKey === "AND" || whereKey === "OR") {
      if (!Array.isArray(rawValue)) {
        throw new Error(
          `Invalid query: Expected an array for the ${whereKey} operator. Got: ${rawValue}`
        );
      }
      const nestedConditions = rawValue.flatMap(
        (subWhere) => buildWhereConditions(subWhere, columns)
      );
      if (nestedConditions.length > 0) {
        conditions.push(
          whereKey === "AND" ? and(...nestedConditions) : or(...nestedConditions)
        );
      }
      continue;
    }
    const conditionSuffix = conditionSuffixesByLengthDesc.find(
      (s) => whereKey.endsWith(s)
    );
    if (conditionSuffix === void 0) {
      throw new Error(
        `Invariant violation: Condition suffix not found for where key ${whereKey}`
      );
    }
    const columnName = whereKey.slice(
      0,
      whereKey.length - conditionSuffix.length
    );
    const column = columns[columnName];
    if (column === void 0) {
      throw new Error(
        `Invalid query: Where clause contains unknown column ${columnName}`
      );
    }
    switch (conditionSuffix) {
      case "":
        if (column.columnType === "PgArray") {
          conditions.push(
            and(
              arrayContains(column, rawValue),
              arrayContained(column, rawValue)
            )
          );
        } else {
          conditions.push(eq(column, rawValue));
        }
        break;
      case "_not":
        if (column.columnType === "PgArray") {
          conditions.push(
            not(
              and(
                arrayContains(column, rawValue),
                arrayContained(column, rawValue)
              )
            )
          );
        } else {
          conditions.push(ne(column, rawValue));
        }
        break;
      case "_in":
        conditions.push(inArray(column, rawValue));
        break;
      case "_not_in":
        conditions.push(notInArray(column, rawValue));
        break;
      case "_has":
        conditions.push(arrayContains(column, [rawValue]));
        break;
      case "_not_has":
        conditions.push(not(arrayContains(column, [rawValue])));
        break;
      case "_gt":
        conditions.push(gt(column, rawValue));
        break;
      case "_lt":
        conditions.push(lt(column, rawValue));
        break;
      case "_gte":
        conditions.push(gte(column, rawValue));
        break;
      case "_lte":
        conditions.push(lte(column, rawValue));
        break;
      case "_contains":
        conditions.push(like(column, `%${rawValue}%`));
        break;
      case "_not_contains":
        conditions.push(notLike(column, `%${rawValue}%`));
        break;
      case "_starts_with":
        conditions.push(like(column, `${rawValue}%`));
        break;
      case "_ends_with":
        conditions.push(like(column, `%${rawValue}`));
        break;
      case "_not_starts_with":
        conditions.push(notLike(column, `${rawValue}%`));
        break;
      case "_not_ends_with":
        conditions.push(notLike(column, `%${rawValue}`));
        break;
      default:
        never(conditionSuffix);
    }
  }
  return conditions;
}
function buildOrderBySchema(table, args) {
  const userDirection = args.orderDirection ?? "asc";
  const userColumns = args.orderBy !== void 0 ? [[args.orderBy, userDirection]] : [];
  const pkColumns = table.primaryKey.map((column) => [
    getColumnTsName(column),
    userDirection
  ]);
  const missingPkColumns = pkColumns.filter(
    (pkColumn) => !userColumns.some((userColumn) => userColumn[0] === pkColumn[0])
  );
  return [...userColumns, ...missingPkColumns];
}
function encodeCursor(orderBySchema, row) {
  const cursorObject = Object.fromEntries(
    orderBySchema.map(([columnName, _]) => [columnName, row[columnName]])
  );
  return encodeRowFragment(cursorObject);
}
function decodeCursor(cursor) {
  return decodeRowFragment(cursor);
}
function encodeRowFragment(rowFragment) {
  return Buffer.from(serialize(rowFragment)).toString("base64");
}
function decodeRowFragment(encodedRowFragment) {
  return deserialize(Buffer.from(encodedRowFragment, "base64").toString());
}
function buildCursorCondition(table, orderBySchema, direction, cursorObject) {
  const cursorColumns = orderBySchema.map(([columnName, orderDirection]) => {
    const column = table.columns[columnName];
    if (column === void 0)
      throw new Error(
        `Unknown column "${columnName}" used in orderBy argument`
      );
    const value = cursorObject[columnName];
    let comparator;
    let comparatorOrEquals;
    if (direction === "after") {
      [comparator, comparatorOrEquals] = orderDirection === "asc" ? [gt, gte] : [lt, lte];
    } else {
      [comparator, comparatorOrEquals] = orderDirection === "asc" ? [lt, lte] : [gt, gte];
    }
    return { column, value, comparator, comparatorOrEquals };
  });
  const buildCondition = (index) => {
    if (index === cursorColumns.length - 1) {
      const { column, value, comparatorOrEquals } = cursorColumns[index];
      return comparatorOrEquals(column, value);
    }
    const currentColumn = cursorColumns[index];
    const nextCondition = buildCondition(index + 1);
    return or(
      currentColumn.comparator(currentColumn.column, currentColumn.value),
      and(eq(currentColumn.column, currentColumn.value), nextCondition)
    );
  };
  return buildCondition(0);
}
function buildDataLoaderCache({
  drizzle
}) {
  const dataLoaderMap = /* @__PURE__ */ new Map();
  return ({ table }) => {
    const baseQuery = drizzle.query[table.tsName];
    if (baseQuery === void 0)
      throw new Error(
        `Internal error: Unknown table "${table.tsName}" in data loader cache`
      );
    let dataLoader = dataLoaderMap.get(table);
    if (dataLoader === void 0) {
      dataLoader = new DataLoader(
        async (encodedIds) => {
          const decodedRowFragments = encodedIds.map(decodeRowFragment);
          const idConditions = decodedRowFragments.map(
            (decodedRowFragment) => and(...buildWhereConditions(decodedRowFragment, table.columns))
          );
          const rows = await baseQuery.findMany({
            where: or(...idConditions),
            limit: encodedIds.length
          });
          return decodedRowFragments.map((decodedRowFragment) => {
            return rows.find(
              (row) => Object.entries(decodedRowFragment).every(
                ([col, val]) => row[col] === val
              )
            );
          });
        },
        { maxBatchSize: 1e3 }
      );
      dataLoaderMap.set(table, dataLoader);
    }
    return dataLoader;
  };
}
function getColumnTsName(column) {
  const tableColumns = getTableColumns2(column.table);
  return Object.entries(tableColumns).find(
    ([_, c]) => c.name === column.name
  )[0];
}
function selectionIncludesField(info, fieldName) {
  for (const fieldNode of info.fieldNodes) {
    for (const selection of fieldNode.selectionSet?.selections ?? []) {
      if (selection.kind === "Field" && selection.name.value === fieldName) {
        return true;
      }
    }
  }
  return false;
}

// src/graphql/middleware.ts
var graphql = ({
  maxOperationTokens = 1e3,
  maxOperationDepth = 100,
  maxOperationAliases = 30
} = {
  // Default limits are from Apollo:
  // https://www.apollographql.com/blog/prevent-graph-misuse-with-operation-size-and-complexity-limit
  maxOperationTokens: 1e3,
  maxOperationDepth: 100,
  maxOperationAliases: 30
}) => {
  let yoga = void 0;
  return createMiddleware(async (c) => {
    if (c.req.method === "GET") {
      return c.html(graphiQLHtml(c.req.path));
    }
    if (yoga === void 0) {
      const metadataStore = c.get("metadataStore");
      const graphqlSchema = c.get("graphqlSchema");
      const drizzle = c.get("db");
      yoga = createYoga({
        schema: graphqlSchema,
        context: () => {
          const getDataLoader = buildDataLoaderCache({ drizzle });
          return { drizzle, metadataStore, getDataLoader };
        },
        graphqlEndpoint: c.req.path,
        maskedErrors: process.env.NODE_ENV === "production",
        logging: false,
        graphiql: false,
        parserAndValidationCache: false,
        plugins: [
          maxTokensPlugin({ n: maxOperationTokens }),
          maxDepthPlugin({ n: maxOperationDepth, ignoreIntrospection: false }),
          maxAliasesPlugin({ n: maxOperationAliases, allowList: [] })
        ]
      });
    }
    const response = await yoga.handle(c.req.raw);
    response.status = 200;
    response.statusText = "OK";
    return response;
  });
};

export {
  getSql,
  getColumnCasing,
  hex,
  bigint,
  onchain,
  userToSqlTableName,
  userToReorgTableName,
  getTableNames,
  getPrimaryKeyColumns,
  primaryKey,
  onchainTable,
  onchainSchema,
  isPgEnumSym,
  onchainEnum,
  never,
  serialize,
  buildGraphQLSchema,
  graphql
};
//# sourceMappingURL=chunk-QF63HG2F.js.map
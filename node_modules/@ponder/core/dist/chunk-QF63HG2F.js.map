{"version":3,"sources":["../src/drizzle/index.ts","../src/drizzle/bigint.ts","../src/drizzle/hex.ts","../src/drizzle/kit/index.ts","../src/ui/graphiql.html.ts","../src/graphql/middleware.ts","../src/utils/never.ts","../src/utils/serialize.ts","../src/graphql/index.ts","../src/graphql/json.ts"],"sourcesContent":["import {\n  type BuildColumns,\n  type ColumnBuilderBase,\n  Table,\n  type Writable,\n  getTableColumns,\n  getTableName,\n  is,\n} from \"drizzle-orm\";\nimport type { NodePgDatabase } from \"drizzle-orm/node-postgres\";\nimport {\n  type AnyPgColumn,\n  type PrimaryKeyBuilder as DrizzlePrimaryKeyBuilder,\n  type ExtraConfigColumn,\n  type PgColumn,\n  type PgColumnBuilder,\n  type PgColumnBuilderBase,\n  PgEnumColumnBuilder,\n  type PgEnumColumnBuilderInitial,\n  PgSchema,\n  PgTable,\n  type PgTableExtraConfig,\n  type PgTableWithColumns,\n  type TableConfig,\n  primaryKey as drizzlePrimaryKey,\n  getTableConfig,\n} from \"drizzle-orm/pg-core\";\nimport {\n  type PgColumnsBuilders as _PgColumnsBuilders,\n  getPgColumnBuilders,\n} from \"drizzle-orm/pg-core/columns/all\";\nimport type { PgliteDatabase } from \"drizzle-orm/pglite\";\nimport { PgBigintBuilder, type PgBigintBuilderInitial } from \"./bigint.js\";\nimport { PgHexBuilder, type PgHexBuilderInitial } from \"./hex.js\";\nimport { getColumnCasing } from \"./kit/index.js\";\n\n// @ts-ignore\nexport function hex(): PgHexBuilderInitial<\"\">;\nexport function hex<name extends string>(\n  columnName: name,\n): PgHexBuilderInitial<name>;\nexport function hex(columnName?: string) {\n  return new PgHexBuilder(columnName ?? \"\");\n}\n\n// @ts-ignore\nexport function bigint(): PgBigintBuilderInitial<\"\">;\nexport function bigint<name extends string>(\n  columnName: name,\n): PgBigintBuilderInitial<name>;\nexport function bigint(columnName?: string) {\n  return new PgBigintBuilder(columnName ?? \"\");\n}\n\nexport const onchain = Symbol.for(\"ponder:onchain\");\n\nexport type Drizzle<TSchema extends Schema = { [name: string]: never }> =\n  | NodePgDatabase<TSchema>\n  | PgliteDatabase<TSchema>;\n\nexport type Schema = { [name: string]: unknown };\n\nexport const userToSqlTableName = (tableName: string, instanceId: string) =>\n  `${instanceId}__${tableName}`;\n\nexport const sqlToUserTableName = (tableName: string) => tableName.slice(6);\n\nexport const userToReorgTableName = (tableName: string, instanceId: string) =>\n  `${instanceId}_reorg__${tableName}`;\n\nexport const getTableNames = (schema: Schema, instanceId: string) => {\n  const tableNames = Object.entries(schema)\n    .filter(([, table]) => is(table, PgTable))\n    .map(([js, table]) => {\n      const tableName = getTableName(table as PgTable);\n      const user = sqlToUserTableName(tableName);\n\n      return {\n        user,\n        sql: userToSqlTableName(user, instanceId),\n        reorg: userToReorgTableName(user, instanceId),\n        trigger: userToReorgTableName(user, instanceId),\n        triggerFn: `operation_${instanceId}_reorg__${user}()`,\n        js,\n      } as const;\n    });\n\n  return tableNames;\n};\n\nexport const getPrimaryKeyColumns = (\n  table: PgTable,\n): { sql: string; js: string }[] => {\n  const primaryKeys = getTableConfig(table).primaryKeys;\n\n  const findJsName = (column: PgColumn): string => {\n    const name = column.name;\n    for (const [js, column] of Object.entries(getTableColumns(table))) {\n      if (column.name === name) return js;\n    }\n\n    throw \"unreachable\";\n  };\n\n  if (primaryKeys.length > 0) {\n    return primaryKeys[0]!.columns.map((column) => ({\n      sql: getColumnCasing(column, \"snake_case\"),\n      js: findJsName(column),\n    }));\n  }\n\n  const pkColumn = Object.values(getTableColumns(table)).find(\n    (c) => c.primary,\n  )!;\n\n  return [\n    {\n      sql: getColumnCasing(pkColumn, \"snake_case\"),\n      js: findJsName(pkColumn),\n    },\n  ];\n};\n\nexport type PrimaryKeyBuilder<columnNames extends string = string> =\n  DrizzlePrimaryKeyBuilder & { columnNames: columnNames };\n\nexport const primaryKey = <\n  tableName extends string,\n  column extends AnyPgColumn<{ tableName: tableName }> & { \" name\": string },\n  columns extends (AnyPgColumn<{ tableName: tableName }> & {\n    \" name\": string;\n  })[],\n>({\n  name,\n  columns,\n}: { name?: string; columns: [column, ...columns] }) =>\n  drizzlePrimaryKey({ name, columns }) as PrimaryKeyBuilder<\n    column[\" name\"] | columns[number][\" name\"]\n  >;\n\nexport type OnchainTable<\n  T extends TableConfig & {\n    extra: PgTableExtraConfig | undefined;\n  } = TableConfig & { extra: PgTableExtraConfig | undefined },\n> = PgTable<T> & {\n  [Key in keyof T[\"columns\"]]: T[\"columns\"][Key];\n} & { [onchain]: true } & {\n  enableRLS: () => Omit<OnchainTable<T>, \"enableRLS\">;\n};\n\ntype BuildExtraConfigColumns<\n  columns extends Record<string, ColumnBuilderBase>,\n> = {\n  [key in keyof columns]: ExtraConfigColumn & {\n    \" name\": key;\n  };\n};\n\ntype PgColumnsBuilders = Omit<\n  _PgColumnsBuilders,\n  \"bigint\" | \"serial\" | \"smallserial\" | \"bigserial\"\n> & {\n  /**\n   * Create an 8 byte number column.\n   */\n  int8: _PgColumnsBuilders[\"bigint\"];\n  /**\n   * Create a column for hex strings.\n   *\n   * - Docs: https://ponder.sh/docs/api-reference/schema#onchaintable\n   *\n   * @example\n   * import { hex, onchainTable } from \"@ponder/core\";\n   *\n   * export const account = onchainTable(\"account\", (p) => ({\n   *   address: p.hex(),\n   * }));\n   */\n  hex: typeof hex;\n  /**\n   * Create a column for hex strings\n   *\n   * - Docs: https://ponder.sh/docs/api-reference/schema#onchaintable\n   *\n   * @example\n   * import { hex, onchainTable } from \"@ponder/core\";\n   *\n   * export const account = onchainTable(\"account\", (p) => ({\n   *   balance: p.bigint(),\n   * }));\n   */\n  bigint: typeof bigint;\n};\n/**\n * Create an onchain table.\n *\n * - Docs: https://ponder.sh/docs/api-reference/schema#onchaintable\n *\n * @example\n * import { onchainTable } from \"@ponder/core\";\n *\n * export const account = onchainTable(\"account\", (p) => ({\n *   address: p.hex().primaryKey(),\n *   balance: p.bigint().notNull(),\n * }));\n *\n * @param name - The table name in the database.\n * @param columns - The table columns.\n * @param extra - Config such as indexes or composite primary keys.\n * @returns The onchain table.\n */\nexport const onchainTable = <\n  name extends string,\n  columns extends Record<string, PgColumnBuilderBase>,\n  extra extends PgTableExtraConfig | undefined = undefined,\n>(\n  name: name,\n  columns: columns | ((columnTypes: PgColumnsBuilders) => columns),\n  extraConfig?: (self: BuildExtraConfigColumns<columns>) => extra,\n): OnchainTable<{\n  name: name;\n  schema: undefined;\n  columns: BuildColumns<name, columns, \"pg\">;\n  extra: extra;\n  dialect: \"pg\";\n}> => {\n  const instanceId: string | undefined =\n    process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n    // @ts-ignore\n    globalThis.__PONDER_INSTANCE_ID;\n  if (instanceId === undefined) {\n    const table = pgTableWithSchema(\n      name,\n      columns,\n      extraConfig as any,\n      undefined,\n    );\n\n    // @ts-ignore\n    table[onchain] = true;\n\n    // @ts-ignore\n    return table;\n  }\n\n  const table = pgTableWithSchema(\n    userToSqlTableName(name, instanceId),\n    columns,\n    extraConfig as any,\n    undefined,\n  );\n\n  // @ts-ignore\n  table[onchain] = true;\n\n  // @ts-ignore\n  return table;\n};\n\nclass OnchainSchema<schema extends string> extends PgSchema<schema> {\n  override table = <\n    name extends string,\n    columns extends Record<string, PgColumnBuilderBase>,\n    extra extends PgTableExtraConfig | undefined = undefined,\n  >(\n    name: name,\n    columns: columns | ((columnTypes: PgColumnsBuilders) => columns),\n    extraConfig?: (self: BuildExtraConfigColumns<columns>) => extra,\n  ): OnchainTable<{\n    name: name;\n    schema: schema;\n    columns: BuildColumns<name, columns, \"pg\">;\n    extra: extra;\n    dialect: \"pg\";\n  }> => {\n    const instanceId: string | undefined =\n      process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n      // @ts-ignore\n      globalThis.__PONDER_INSTANCE_ID;\n    if (instanceId === undefined) {\n      const table = pgTableWithSchema(\n        name,\n        columns,\n        extraConfig as any,\n        this.schemaName,\n      );\n\n      // @ts-ignore\n      table[onchain] = true;\n\n      // @ts-ignore\n      return table;\n    }\n\n    const table = pgTableWithSchema(\n      // @ts-ignore\n      userToSqlTableName(name, instanceId),\n      columns,\n      extraConfig as any,\n      this.schemaName,\n    );\n\n    // @ts-ignore\n    table[onchain] = true;\n\n    // @ts-ignore\n    return table;\n  };\n\n  override enum = <U extends string, T extends Readonly<[U, ...U[]]>>(\n    enumName: string,\n    values: T | Writable<T>,\n  ): OnchainEnum<Writable<T>> & { [onchain]: true } => {\n    const instanceId: string | undefined =\n      process.env.PONDER_EXPERIMENTAL_INSTANCE_ID ??\n      // @ts-ignore\n      globalThis.__PONDER_INSTANCE_ID;\n    if (instanceId === undefined) {\n      const e = pgEnumWithSchema(enumName, values, this.schemaName);\n\n      // @ts-ignore\n      e[onchain] = true;\n\n      // @ts-ignore\n      return e;\n    }\n\n    const e = pgEnumWithSchema(\n      userToSqlTableName(enumName, instanceId),\n      values,\n      this.schemaName,\n    );\n\n    // @ts-ignore\n    e[onchain] = true;\n\n    // @ts-ignore\n    return e;\n  };\n}\n\n/**\n * Define the database schema for onchain tables.\n *\n * @example\n * import { onchainSchema } from \"@ponder/core\";\n *\n * export const schema = onchainSchema(\"ponder\");\n *\n * export const account = schema.table(\"account\", (p) => ({\n *   address: p.hex().primaryKey(),\n *   balance: p.bigint().notNull(),\n * }));\n *\n * @param name - The schema for onchain tables.\n * @returns The onchain schema.\n */\nexport const onchainSchema = <T extends string>(name: T) =>\n  new OnchainSchema(name);\n\nexport const isPgEnumSym = Symbol.for(\"drizzle:isPgEnum\");\n\nexport interface OnchainEnum<TValues extends [string, ...string[]]> {\n  (): PgEnumColumnBuilderInitial<\"\", TValues>;\n  <TName extends string>(\n    name: TName,\n  ): PgEnumColumnBuilderInitial<TName, TValues>;\n  <TName extends string>(\n    name?: TName,\n  ): PgEnumColumnBuilderInitial<TName, TValues>;\n\n  readonly enumName: string;\n  readonly enumValues: TValues;\n  readonly schema: string | undefined;\n  /** @internal */\n  [isPgEnumSym]: true;\n}\n\nexport const onchainEnum = <U extends string, T extends Readonly<[U, ...U[]]>>(\n  enumName: string,\n  values: T | Writable<T>,\n): OnchainEnum<Writable<T>> & { [onchain]: true } => {\n  // @ts-ignore\n  const instanceId: string | undefined = globalThis.__PONDER_INSTANCE_ID;\n  if (instanceId === undefined) {\n    const e = pgEnumWithSchema(enumName, values, undefined);\n\n    // @ts-ignore\n    e[onchain] = true;\n\n    // @ts-ignore\n    return e;\n  }\n\n  const e = pgEnumWithSchema(\n    // @ts-ignore\n    userToSqlTableName(enumName, instanceId),\n    values,\n    undefined,\n  );\n\n  // @ts-ignore\n  e[onchain] = true;\n\n  // @ts-ignore\n  return e;\n};\n\nconst InlineForeignKeys = Symbol.for(\"drizzle:PgInlineForeignKeys\");\n\n/** @see https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/pg-core/table.ts#L51 */\nfunction pgTableWithSchema<\n  name extends string,\n  schema extends string | undefined,\n  columns extends Record<string, PgColumnBuilderBase>,\n>(\n  name: name,\n  columns: columns | ((columnTypes: PgColumnsBuilders) => columns),\n  extraConfig:\n    | ((self: BuildExtraConfigColumns<columns>) => PgTableExtraConfig)\n    | undefined,\n  schema: schema,\n  baseName = name,\n): PgTableWithColumns<{\n  name: name;\n  schema: schema;\n  columns: BuildColumns<name, columns, \"pg\">;\n  dialect: \"pg\";\n}> {\n  const rawTable = new PgTable<{\n    name: name;\n    schema: schema;\n    columns: BuildColumns<name, columns, \"pg\">;\n    dialect: \"pg\";\n  }>(name, schema, baseName);\n\n  const { bigint: int8, ...restColumns } = getPgColumnBuilders();\n\n  const parsedColumns: columns =\n    typeof columns === \"function\"\n      ? columns({ ...restColumns, int8, hex, bigint })\n      : columns;\n\n  const builtColumns = Object.fromEntries(\n    Object.entries(parsedColumns).map(([name, colBuilderBase]) => {\n      const colBuilder = colBuilderBase;\n      //@ts-ignore\n      colBuilder.setName(name);\n      //@ts-ignore\n      const column = colBuilder.build(rawTable);\n      // @ts-ignore\n      rawTable[InlineForeignKeys].push(\n        //@ts-ignore\n        ...colBuilder.buildForeignKeys(column, rawTable),\n      );\n      return [name, column];\n    }),\n  ) as unknown as BuildColumns<name, columns, \"pg\">;\n\n  const builtColumnsForExtraConfig = Object.fromEntries(\n    Object.entries(parsedColumns).map(([name, colBuilderBase]) => {\n      const colBuilder = colBuilderBase as PgColumnBuilder;\n      //@ts-ignore\n      colBuilder.setName(name);\n      //@ts-ignore\n      const column = colBuilder.buildExtraConfigColumn(rawTable);\n      return [name, column];\n    }),\n  ) as unknown as BuildExtraConfigColumns<columns>;\n\n  const table = Object.assign(rawTable, builtColumns);\n\n  //@ts-ignore\n  table[Table.Symbol.Columns] = builtColumns;\n  //@ts-ignore\n  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n\n  if (extraConfig) {\n    //@ts-ignore\n    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n  }\n\n  return Object.assign(table, {\n    enableRLS: () => {\n      // @ts-ignore\n      table[PgTable.Symbol.EnableRLS] = true;\n      return table as PgTableWithColumns<{\n        name: name;\n        schema: schema;\n        columns: BuildColumns<name, columns, \"pg\">;\n        dialect: \"pg\";\n      }>;\n    },\n  });\n}\n\nfunction pgEnumWithSchema<U extends string, T extends Readonly<[U, ...U[]]>>(\n  enumName: string,\n  values: T | Writable<T>,\n  schema?: string,\n): OnchainEnum<Writable<T>> {\n  const enumInstance: OnchainEnum<Writable<T>> = Object.assign(\n    <TName extends string>(\n      name?: TName,\n    ): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n      new PgEnumColumnBuilder(name ?? (\"\" as TName), enumInstance),\n    {\n      enumName,\n      enumValues: values,\n      schema,\n      [isPgEnumSym]: true,\n    } as const,\n  );\n\n  return enumInstance;\n}\n","import {\n  type ColumnBaseConfig,\n  type ColumnBuilderBaseConfig,\n  type ColumnBuilderRuntimeConfig,\n  type MakeColumnConfig,\n  entityKind,\n} from \"drizzle-orm\";\nimport {\n  type AnyPgTable,\n  PgColumn,\n  PgColumnBuilder,\n} from \"drizzle-orm/pg-core\";\n\nexport type PgBigintBuilderInitial<TName extends string> = PgBigintBuilder<{\n  name: TName;\n  dataType: \"bigint\";\n  columnType: \"PgEvmBigint\";\n  data: bigint;\n  driverParam: string;\n  enumValues: undefined;\n  generated: undefined;\n}>;\n\nexport class PgBigintBuilder<\n  T extends ColumnBuilderBaseConfig<\"bigint\", \"PgEvmBigint\">,\n> extends PgColumnBuilder<T> {\n  static readonly [entityKind]: string = \"PgEvmBigintBuilder\";\n\n  constructor(name: T[\"name\"]) {\n    super(name, \"bigint\", \"PgEvmBigint\");\n  }\n\n  /** @internal */\n  // @ts-ignore\n  override build<TTableName extends string>(\n    table: AnyPgTable<{ name: TTableName }>,\n  ): PgBigint<MakeColumnConfig<T, TTableName>> {\n    return new PgBigint<MakeColumnConfig<T, TTableName>>(\n      table,\n      this.config as ColumnBuilderRuntimeConfig<any, any>,\n    );\n  }\n}\n\nexport class PgBigint<\n  T extends ColumnBaseConfig<\"bigint\", \"PgEvmBigint\">,\n> extends PgColumn<T> {\n  static readonly [entityKind]: string = \"PgEvmBigint\";\n\n  getSQLType(): string {\n    return \"numeric(78)\";\n  }\n\n  override mapFromDriverValue(value: string): bigint {\n    return BigInt(value);\n  }\n}\n","import {\n  type ColumnBaseConfig,\n  type ColumnBuilderBaseConfig,\n  type ColumnBuilderRuntimeConfig,\n  type MakeColumnConfig,\n  entityKind,\n} from \"drizzle-orm\";\nimport {\n  type AnyPgTable,\n  PgColumn,\n  PgColumnBuilder,\n} from \"drizzle-orm/pg-core\";\n\nexport type PgHexBuilderInitial<TName extends string> = PgHexBuilder<{\n  name: TName;\n  dataType: \"string\";\n  columnType: \"PgHex\";\n  data: `0x${string}`;\n  driverParam: string;\n  enumValues: undefined;\n  generated: undefined;\n}>;\n\nexport class PgHexBuilder<\n  T extends ColumnBuilderBaseConfig<\"string\", \"PgHex\">,\n> extends PgColumnBuilder<T> {\n  static readonly [entityKind]: string = \"PgHexBuilder\";\n\n  constructor(name: T[\"name\"]) {\n    super(name, \"string\", \"PgHex\");\n  }\n\n  /** @internal */\n  // @ts-ignore\n  override build<TTableName extends string>(\n    table: AnyPgTable<{ name: TTableName }>,\n  ): PgHex<MakeColumnConfig<T, TTableName>> {\n    return new PgHex<MakeColumnConfig<T, TTableName>>(\n      table,\n      this.config as ColumnBuilderRuntimeConfig<any, any>,\n    );\n  }\n}\n\nexport class PgHex<\n  T extends ColumnBaseConfig<\"string\", \"PgHex\">,\n> extends PgColumn<T> {\n  static readonly [entityKind]: string = \"PgHex\";\n\n  getSQLType(): string {\n    return \"text\";\n  }\n\n  override mapToDriverValue(value: `0x${string}`) {\n    if (value.length % 2 === 0) return value.toLowerCase() as `0x${string}`;\n    return `0x0${value.slice(2)}`.toLowerCase() as `0x${string}`;\n  }\n}\n","import { SQL, is } from \"drizzle-orm\";\nimport { CasingCache, toCamelCase, toSnakeCase } from \"drizzle-orm/casing\";\nimport {\n  type AnyPgTable,\n  PgDialect,\n  type PgEnum,\n  PgEnumColumn,\n  PgMaterializedView,\n  PgSchema,\n  type PgSequence,\n  PgTable,\n  PgView,\n  getTableConfig,\n  integer,\n  isPgEnum,\n  isPgSequence,\n  pgTable,\n  serial,\n  varchar,\n} from \"drizzle-orm/pg-core\";\nimport {\n  type Schema,\n  sqlToUserTableName,\n  userToSqlTableName,\n} from \"../index.js\";\n\ntype Dialect = \"postgresql\";\ntype CasingType = \"snake_case\" | \"camelCase\";\n\nexport type SqlStatements = {\n  schema: {\n    sql: string[];\n    json: JsonCreateSchema[];\n  };\n  tables: {\n    sql: string[];\n    json: JsonCreateTableStatement[];\n  };\n  enums: {\n    sql: string[];\n    json: JsonCreateEnumStatement[];\n  };\n  indexes: { sql: string[]; json: JsonPgCreateIndexStatement[] };\n};\n\nexport const getSql = (schema: Schema, instanceId: string): SqlStatements => {\n  const { tables, enums, schemas } = prepareFromExports(schema);\n  const json = generatePgSnapshot(tables, enums, schemas, \"snake_case\");\n  const squashed = squashPgScheme(json);\n\n  const jsonCreateIndexesForCreatedTables = Object.values(\n    squashed.tables,\n  ).flatMap((it) => {\n    // @ts-ignore\n    return preparePgCreateIndexesJson(it.name, it.schema, it.indexes);\n  });\n\n  const jsonCreateEnums =\n    Object.values(squashed.enums).map((it) => {\n      // @ts-ignore\n      return prepareCreateEnumJson(it.name, it.schema, it.values);\n    }) ?? [];\n\n  const jsonCreateSchemas = prepareCreateSchemasJson(\n    Object.values(squashed.schemas),\n  );\n\n  const jsonCreateTables = Object.values(squashed.tables).map((it: any) => {\n    return preparePgCreateTableJson(it, json);\n  });\n\n  const fromJson = (statements: any[]) =>\n    statements\n      .flatMap((statement) => {\n        const filtered = convertors.filter((it) => {\n          return it.can(statement, \"postgresql\");\n        });\n\n        const convertor = filtered.length === 1 ? filtered[0] : undefined;\n\n        if (!convertor) {\n          return \"\";\n        }\n\n        return convertor.convert(statement);\n      })\n      .filter((it) => it !== \"\");\n\n  const combinedTables = jsonCreateTables.flatMap((statement) => [\n    {\n      ...statement,\n      tableName: userToSqlTableName(\n        sqlToUserTableName(statement.tableName),\n        instanceId,\n      ),\n    },\n    createReorgTableStatement(statement, instanceId),\n  ]);\n\n  return {\n    schema: { sql: fromJson(jsonCreateSchemas), json: jsonCreateSchemas },\n    tables: {\n      sql: fromJson(combinedTables),\n      json: combinedTables,\n    },\n    enums: { sql: fromJson(jsonCreateEnums), json: jsonCreateEnums },\n    indexes: {\n      sql: fromJson(jsonCreateIndexesForCreatedTables),\n      json: jsonCreateIndexesForCreatedTables,\n    },\n  };\n};\n\nconst createReorgTableStatement = (\n  statement: JsonCreateTableStatement,\n  instance_id: string,\n) => {\n  const reorgStatement: JsonCreateTableStatement = structuredClone(statement);\n\n  reorgStatement.compositePkName = undefined;\n  reorgStatement.compositePKs = [];\n\n  for (const column of reorgStatement.columns) {\n    column.primaryKey = false;\n  }\n\n  const reorgColumns = Object.values(\n    squashPgScheme(\n      generatePgSnapshot(\n        [\n          pgTable(\"\", {\n            operation_id: serial(\"operation_id\").notNull().primaryKey(),\n            operation: integer(\"operation\").notNull(),\n            checkpoint: varchar(\"checkpoint\", {\n              length: 75,\n            }).notNull(),\n          }),\n        ],\n        [],\n        [],\n        \"snake_case\",\n      ),\n    ).tables,\n    //@ts-ignore\n  )[0]!.columns;\n\n  reorgStatement.columns.push(...Object.values(reorgColumns));\n\n  reorgStatement.tableName = `${instance_id}_reorg__${reorgStatement.tableName.slice(6)}`;\n\n  return reorgStatement;\n};\n\n////////\n// Serializer\n////////\n\ntype Index = any;\ntype Column = any;\ntype PgSchemaSquashed = any;\ntype Table = any;\ntype Enum = any;\ntype PrimaryKey = any;\ntype IndexedColumn = any;\ntype IndexColumnType = any;\n\nconst PgSquasher = {\n  squashIdx: (idx: Index) => {\n    return `${idx.name};${idx.columns\n      .map(\n        (c: {\n          expression: any;\n          isExpression: any;\n          asc: any;\n          nulls: any;\n          opclass: any;\n        }) =>\n          `${c.expression}--${c.isExpression}--${c.asc}--${c.nulls}--${\n            c.opclass && \"\"\n          }`,\n      )\n      .join(\n        \",,\",\n      )};${idx.isUnique};${idx.concurrently};${idx.method};${idx.where};${JSON.stringify(idx.with)}`;\n  },\n  unsquashIdx: (input: string): Index => {\n    const [\n      name,\n      columnsString,\n      isUnique,\n      concurrently,\n      method,\n      where,\n      idxWith,\n    ] = input.split(\";\");\n\n    const columnString = columnsString!.split(\",,\");\n    const columns: IndexColumnType[] = [];\n\n    for (const column of columnString) {\n      const [expression, isExpression, asc, nulls, opclass] =\n        column.split(\"--\");\n      columns.push({\n        nulls: nulls as IndexColumnType[\"nulls\"],\n        isExpression: isExpression === \"true\",\n        asc: asc === \"true\",\n        expression: expression,\n        opclass: opclass === \"undefined\" ? undefined : opclass,\n      });\n    }\n\n    return {\n      name,\n      columns,\n      isUnique: isUnique === \"true\",\n      concurrently: concurrently === \"true\",\n      method,\n      where: where === \"undefined\" ? undefined : where,\n      with:\n        !idxWith || idxWith === \"undefined\" ? undefined : JSON.parse(idxWith),\n    };\n  },\n  squashPK: (pk: PrimaryKey) => {\n    return `${pk.columns.join(\",\")};${pk.name}`;\n  },\n  unsquashPK: (pk: string): PrimaryKey => {\n    const splitted = pk.split(\";\");\n    return { name: splitted[1], columns: splitted[0]!.split(\",\") };\n  },\n};\n\n////////\n// JSON\n////////\n\ninterface JsonCreateTableStatement {\n  type: \"create_table\";\n  tableName: string;\n  schema: string;\n  columns: Column[];\n  compositePKs: string[];\n  compositePkName?: string;\n  uniqueConstraints?: string[];\n  checkConstraints?: string[];\n}\n\ninterface JsonCreateEnumStatement {\n  type: \"create_type_enum\";\n  name: string;\n  schema: string;\n  values: string[];\n}\n\ninterface JsonCreateIndexStatement {\n  type: \"create_index\";\n  tableName: string;\n  data: string;\n  schema: string;\n}\n\ninterface JsonPgCreateIndexStatement {\n  type: \"create_index_pg\";\n  tableName: string;\n  data: Index;\n  schema: string;\n}\n\ninterface JsonCreateUniqueConstraint {\n  type: \"create_unique_constraint\";\n  tableName: string;\n  data: string;\n  schema?: string;\n  constraintName?: string;\n}\n\ninterface JsonCreateCheckConstraint {\n  type: \"create_check_constraint\";\n  tableName: string;\n  data: string;\n  schema?: string;\n}\n\ninterface JsonCreateCompositePK {\n  type: \"create_composite_pk\";\n  tableName: string;\n  data: string;\n  schema?: string;\n  constraintName?: string;\n}\n\ninterface JsonCreateSchema {\n  type: \"create_schema\";\n  name: string;\n}\n\ninterface JsonCreateReferenceStatement {\n  type: \"create_reference\";\n  data: string;\n  schema: string;\n  tableName: string;\n  isMulticolumn?: boolean;\n  columnNotNull?: boolean;\n  columnDefault?: string;\n  columnType?: string;\n}\n\ntype JsonStatement =\n  | JsonCreateTableStatement\n  | JsonCreateEnumStatement\n  | JsonCreateIndexStatement\n  | JsonPgCreateIndexStatement\n  | JsonCreateReferenceStatement\n  | JsonCreateCompositePK\n  | JsonCreateUniqueConstraint\n  | JsonCreateSchema\n  | JsonCreateCheckConstraint;\n\n////////\n// Generator\n////////\n\nconst parseType = (schemaPrefix: string, type: string) => {\n  const pgNativeTypes = [\n    \"uuid\",\n    \"smallint\",\n    \"integer\",\n    \"bigint\",\n    \"boolean\",\n    \"text\",\n    \"varchar\",\n    \"serial\",\n    \"bigserial\",\n    \"decimal\",\n    \"numeric\",\n    \"real\",\n    \"json\",\n    \"jsonb\",\n    \"time\",\n    \"time with time zone\",\n    \"time without time zone\",\n    \"time\",\n    \"timestamp\",\n    \"timestamp with time zone\",\n    \"timestamp without time zone\",\n    \"date\",\n    \"interval\",\n    \"bigint\",\n    \"bigserial\",\n    \"double precision\",\n    \"interval year\",\n    \"interval month\",\n    \"interval day\",\n    \"interval hour\",\n    \"interval minute\",\n    \"interval second\",\n    \"interval year to month\",\n    \"interval day to hour\",\n    \"interval day to minute\",\n    \"interval day to second\",\n    \"interval hour to minute\",\n    \"interval hour to second\",\n    \"interval minute to second\",\n  ];\n\n  const arrayDefinitionRegex = /\\[\\d*(?:\\[\\d*\\])*\\]/g;\n  const arrayDefinition = (type.match(arrayDefinitionRegex) ?? []).join(\"\");\n  const withoutArrayDefinition = type.replace(arrayDefinitionRegex, \"\");\n  return pgNativeTypes.some((it) => type.startsWith(it))\n    ? `${withoutArrayDefinition}${arrayDefinition}`\n    : `${schemaPrefix}\"${withoutArrayDefinition}\"${arrayDefinition}`;\n};\n\nabstract class Convertor {\n  abstract can(statement: JsonStatement, dialect: Dialect): boolean;\n  abstract convert(\n    statement: JsonStatement,\n    action?: \"push\",\n  ): string | string[];\n}\n\nclass PgCreateTableConvertor extends Convertor {\n  can(statement: JsonStatement, dialect: Dialect): boolean {\n    return statement.type === \"create_table\" && dialect === \"postgresql\";\n  }\n\n  convert(st: JsonCreateTableStatement) {\n    const { tableName, schema, columns, compositePKs } = st;\n\n    let statement = \"\";\n    const name = schema ? `\"${schema}\".\"${tableName}\"` : `\"${tableName}\"`;\n\n    statement += `CREATE TABLE ${name} (\\n`;\n    for (let i = 0; i < columns.length; i++) {\n      const column = columns[i];\n\n      const primaryKeyStatement = column.primaryKey ? \" PRIMARY KEY\" : \"\";\n      const notNullStatement =\n        column.notNull && !column.identity ? \" NOT NULL\" : \"\";\n      const defaultStatement =\n        column.default !== undefined ? ` DEFAULT ${column.default}` : \"\";\n\n      // const uniqueConstraint = column.isUnique\n      //   ? ` CONSTRAINT \"${column.uniqueName}\" UNIQUE${column.nullsNotDistinct ? \" NULLS NOT DISTINCT\" : \"\"}`\n      //   : \"\";\n\n      const schemaPrefix =\n        column.typeSchema && column.typeSchema !== \"public\"\n          ? `\"${column.typeSchema}\".`\n          : \"\";\n\n      const type = parseType(schemaPrefix, column.type);\n      // const generated = column.generated;\n\n      // const generatedStatement = generated\n      //   ? ` GENERATED ALWAYS AS (${generated?.as}) STORED`\n      //   : \"\";\n\n      // const unsquashedIdentity = column.identity\n      //   ? PgSquasher.unsquashIdentity(column.identity)\n      //   : undefined;\n\n      // const identityWithSchema = schema\n      //   ? `\"${schema}\".\"${unsquashedIdentity?.name}\"`\n      //   : `\"${unsquashedIdentity?.name}\"`;\n\n      // const identity = unsquashedIdentity\n      //   ? ` GENERATED ${\n      //       unsquashedIdentity.type === \"always\" ? \"ALWAYS\" : \"BY DEFAULT\"\n      //     } AS IDENTITY (sequence name ${identityWithSchema}${\n      //       unsquashedIdentity.increment\n      //         ? ` INCREMENT BY ${unsquashedIdentity.increment}`\n      //         : \"\"\n      //     }${\n      //       unsquashedIdentity.minValue\n      //         ? ` MINVALUE ${unsquashedIdentity.minValue}`\n      //         : \"\"\n      //     }${\n      //       unsquashedIdentity.maxValue\n      //         ? ` MAXVALUE ${unsquashedIdentity.maxValue}`\n      //         : \"\"\n      //     }${\n      //       unsquashedIdentity.startWith\n      //         ? ` START WITH ${unsquashedIdentity.startWith}`\n      //         : \"\"\n      //     }${unsquashedIdentity.cache ? ` CACHE ${unsquashedIdentity.cache}` : \"\"}${\n      //       unsquashedIdentity.cycle ? \" CYCLE\" : \"\"\n      //     })`\n      //   : \"\";\n\n      statement += `\\t\"${column.name}\" ${type}${primaryKeyStatement}${defaultStatement}${notNullStatement}`;\n      statement += i === columns.length - 1 ? \"\" : \",\\n\";\n    }\n\n    if (typeof compositePKs !== \"undefined\" && compositePKs.length > 0) {\n      statement += \",\\n\";\n      const compositePK = PgSquasher.unsquashPK(compositePKs[0]!);\n      statement += `\\tCONSTRAINT \"${st.compositePkName}\" PRIMARY KEY(\\\"${compositePK.columns.join(`\",\"`)}\\\")`;\n      // statement += `\\n`;\n    }\n\n    // if (\n    //   typeof uniqueConstraints !== \"undefined\" &&\n    //   uniqueConstraints.length > 0\n    // ) {\n    //   for (const uniqueConstraint of uniqueConstraints) {\n    //     statement += \",\\n\";\n    //     const unsquashedUnique = PgSquasher.unsquashUnique(uniqueConstraint);\n    //     statement += `\\tCONSTRAINT \"${unsquashedUnique.name}\" UNIQUE${\n    //       unsquashedUnique.nullsNotDistinct ? \" NULLS NOT DISTINCT\" : \"\"\n    //     }(\\\"${unsquashedUnique.columns.join(`\",\"`)}\\\")`;\n    //     // statement += `\\n`;\n    //   }\n    // }\n\n    // if (\n    //   typeof checkConstraints !== \"undefined\" &&\n    //   checkConstraints.length > 0\n    // ) {\n    //   for (const checkConstraint of checkConstraints) {\n    //     statement += \",\\n\";\n    //     const unsquashedCheck = PgSquasher.unsquashCheck(checkConstraint);\n    //     statement += `\\tCONSTRAINT \"${unsquashedCheck.name}\" CHECK (${unsquashedCheck.value})`;\n    //   }\n    // }\n\n    statement += \"\\n);\";\n    statement += \"\\n\";\n\n    return statement;\n  }\n}\n\nclass CreateTypeEnumConvertor extends Convertor {\n  can(statement: JsonStatement): boolean {\n    return statement.type === \"create_type_enum\";\n  }\n\n  convert(st: JsonCreateEnumStatement) {\n    const { name, values, schema } = st;\n\n    const enumNameWithSchema = schema ? `\"${schema}\".\"${name}\"` : `\"${name}\"`;\n\n    let valuesStatement = \"(\";\n    valuesStatement += values.map((it) => `'${it}'`).join(\", \");\n    valuesStatement += \")\";\n\n    // TODO do we need this?\n    // let statement = 'DO $$ BEGIN';\n    // statement += '\\n';\n    const statement = `CREATE TYPE ${enumNameWithSchema} AS ENUM${valuesStatement};`;\n    // statement += '\\n';\n    // statement += 'EXCEPTION';\n    // statement += '\\n';\n    // statement += ' WHEN duplicate_object THEN null;';\n    // statement += '\\n';\n    // statement += 'END $$;';\n    // statement += '\\n';\n    return statement;\n  }\n}\n\nclass CreatePgIndexConvertor extends Convertor {\n  can(statement: JsonStatement, dialect: Dialect): boolean {\n    return statement.type === \"create_index_pg\" && dialect === \"postgresql\";\n  }\n\n  convert(statement: JsonPgCreateIndexStatement): string {\n    const {\n      name,\n      columns,\n      isUnique,\n      concurrently,\n      with: withMap,\n      method,\n      where,\n    } = statement.data;\n    // // since postgresql 9.5\n    const indexPart = isUnique ? \"UNIQUE INDEX\" : \"INDEX\";\n    const value = columns\n      .map(\n        (it: {\n          isExpression: any;\n          expression: any;\n          opclass: any;\n          asc: any;\n          nulls: string;\n        }) =>\n          `${it.isExpression ? it.expression : `\"${it.expression}\"`}${\n            it.opclass ? ` ${it.opclass}` : it.asc ? \"\" : \" DESC\"\n          }${\n            (it.asc && it.nulls && it.nulls === \"last\") || it.opclass\n              ? \"\"\n              : ` NULLS ${it.nulls!.toUpperCase()}`\n          }`,\n      )\n      .join(\",\");\n\n    const tableNameWithSchema = statement.schema\n      ? `\"${statement.schema}\".\"${statement.tableName}\"`\n      : `\"${statement.tableName}\"`;\n\n    function reverseLogic(mappedWith: Record<string, string>): string {\n      let reversedString = \"\";\n      for (const key in mappedWith) {\n        // biome-ignore lint/suspicious/noPrototypeBuiltins: <explanation>\n        if (mappedWith.hasOwnProperty(key)) {\n          reversedString += `${key}=${mappedWith[key]},`;\n        }\n      }\n      reversedString = reversedString.slice(0, -1);\n      return reversedString;\n    }\n\n    return `CREATE ${indexPart}${\n      concurrently ? \" CONCURRENTLY\" : \"\"\n    } IF NOT EXISTS \"${name}\" ON ${tableNameWithSchema} USING ${method} (${value})${\n      Object.keys(withMap!).length !== 0\n        ? ` WITH (${reverseLogic(withMap!)})`\n        : \"\"\n    }${where ? ` WHERE ${where}` : \"\"};`;\n  }\n}\n\nclass PgCreateSchemaConvertor extends Convertor {\n  can(statement: JsonStatement, dialect: Dialect): boolean {\n    return statement.type === \"create_schema\" && dialect === \"postgresql\";\n  }\n\n  convert(statement: JsonCreateSchema) {\n    const { name } = statement;\n    return `CREATE SCHEMA IF NOT EXISTS\"${name}\";\\n`;\n  }\n}\n\nconst convertors: Convertor[] = [];\nconvertors.push(new PgCreateTableConvertor());\nconvertors.push(new CreateTypeEnumConvertor());\nconvertors.push(new CreatePgIndexConvertor());\nconvertors.push(new PgCreateSchemaConvertor());\n\nconst preparePgCreateTableJson = (\n  table: Table,\n  json: PgSchemaSquashed,\n): JsonCreateTableStatement => {\n  const { name, schema, columns, compositePrimaryKeys } = table;\n  const tableKey = `${schema || \"public\"}.${name}`;\n\n  // TODO: @AndriiSherman. We need this, will add test cases\n  const compositePkName =\n    Object.values(compositePrimaryKeys).length > 0\n      ? json.tables[tableKey].compositePrimaryKeys[\n          `${PgSquasher.unsquashPK(Object.values(compositePrimaryKeys)[0]! as string).name}`\n        ].name\n      : \"\";\n\n  return {\n    type: \"create_table\",\n    tableName: name,\n    schema,\n    columns: Object.values(columns),\n    compositePKs: Object.values(compositePrimaryKeys),\n    compositePkName: compositePkName,\n  };\n};\n\nconst preparePgCreateIndexesJson = (\n  tableName: string,\n  schema: string,\n  indexes: Record<string, string>,\n): JsonPgCreateIndexStatement[] => {\n  return Object.values(indexes).map((indexData) => {\n    return {\n      type: \"create_index_pg\",\n      tableName,\n      data: PgSquasher.unsquashIdx(indexData),\n      schema,\n    };\n  });\n};\n\nconst prepareCreateSchemasJson = (values: string[]): JsonCreateSchema[] => {\n  return values.map((it) => {\n    return {\n      type: \"create_schema\",\n      name: it,\n    } as JsonCreateSchema;\n  });\n};\n\nconst prepareCreateEnumJson = (\n  name: string,\n  schema: string,\n  values: string[],\n): JsonCreateEnumStatement => {\n  return {\n    type: \"create_type_enum\",\n    name: name,\n    schema: schema,\n    values,\n  };\n};\n\nconst prepareFromExports = (exports: Record<string, unknown>) => {\n  const tables: AnyPgTable[] = [];\n  const enums: PgEnum<any>[] = [];\n  const schemas: PgSchema[] = [];\n  const sequences: PgSequence[] = [];\n  const views: PgView[] = [];\n  const matViews: PgMaterializedView[] = [];\n\n  const i0values = Object.values(exports);\n  i0values.forEach((t) => {\n    if (isPgEnum(t)) {\n      enums.push(t);\n      return;\n    }\n    if (is(t, PgTable)) {\n      tables.push(t);\n    }\n\n    if (is(t, PgSchema)) {\n      schemas.push(t);\n    }\n\n    if (is(t, PgView)) {\n      views.push(t);\n    }\n\n    if (is(t, PgMaterializedView)) {\n      matViews.push(t);\n    }\n\n    if (isPgSequence(t)) {\n      sequences.push(t);\n    }\n  });\n\n  return { tables, enums, schemas, sequences, views, matViews };\n};\n\nexport function getColumnCasing(\n  column: { keyAsName: boolean; name: string | undefined },\n  casing: CasingType | undefined,\n) {\n  if (!column.name) return \"\";\n  return !column.keyAsName || casing === undefined\n    ? column.name\n    : casing === \"camelCase\"\n      ? toCamelCase(column.name)\n      : toSnakeCase(column.name);\n}\n\nconst sqlToStr = (sql: SQL, casing: CasingType | undefined) => {\n  return sql.toQuery({\n    escapeName: () => {\n      throw new Error(\"we don't support params for `sql` default values\");\n    },\n    escapeParam: () => {\n      throw new Error(\"we don't support params for `sql` default values\");\n    },\n    escapeString: () => {\n      throw new Error(\"we don't support params for `sql` default values\");\n    },\n    casing: new CasingCache(casing),\n  }).sql;\n};\n\nfunction isPgArrayType(sqlType: string) {\n  return sqlType.match(/.*\\[\\d*\\].*|.*\\[\\].*/g) !== null;\n}\n\nfunction buildArrayString(array: readonly any[], sqlType: string): string {\n  sqlType = sqlType.split(\"[\")[0]!;\n  const values = array\n    .map((value) => {\n      if (typeof value === \"number\" || typeof value === \"bigint\") {\n        return value.toString();\n      } else if (typeof value === \"boolean\") {\n        return value ? \"true\" : \"false\";\n      } else if (Array.isArray(value)) {\n        return buildArrayString(value, sqlType);\n      } else if (value instanceof Date) {\n        if (sqlType === \"date\") {\n          return `\"${value.toISOString().split(\"T\")[0]}\"`;\n        } else if (sqlType === \"timestamp\") {\n          return `\"${value.toISOString().replace(\"T\", \" \").slice(0, 23)}\"`;\n        } else {\n          return `\"${value.toISOString()}\"`;\n        }\n      } else if (typeof value === \"object\") {\n        return `\"${JSON.stringify(value).replaceAll('\"', '\\\\\"')}\"`;\n      }\n\n      return `\"${value}\"`;\n    })\n    .join(\",\");\n\n  return `{${values}}`;\n}\n\nconst indexName = (tableName: string, columns: string[]) => {\n  return `${tableName}_${columns.join(\"_\")}_index`;\n};\n\nconst generatePgSnapshot = (\n  tables: AnyPgTable[],\n  enums: PgEnum<any>[],\n  schemas: PgSchema[],\n  casing: CasingType | undefined,\n) => {\n  const dialect = new PgDialect({ casing });\n  const result: Record<string, Table> = {};\n\n  // This object stores unique names for indexes and will be used to detect if you have the same names for indexes\n  // within the same PostgreSQL schema\n  const indexesInSchema: Record<string, string[]> = {};\n\n  for (const table of tables) {\n    const {\n      name: tableName,\n      columns,\n      indexes,\n      schema,\n      primaryKeys,\n    } = getTableConfig(table);\n\n    const columnsObject: Record<string, Column> = {};\n    const indexesObject: Record<string, Index> = {};\n    const primaryKeysObject: Record<string, PrimaryKey> = {};\n\n    columns.forEach((column) => {\n      const name = getColumnCasing(column, casing);\n      const notNull: boolean = column.notNull;\n      const primaryKey: boolean = column.primary;\n      const sqlTypeLowered = column.getSQLType().toLowerCase();\n\n      const typeSchema = is(column, PgEnumColumn)\n        ? column.enum.schema || \"public\"\n        : undefined;\n\n      const columnToSet: Column = {\n        name,\n        type: column.getSQLType(),\n        typeSchema: typeSchema,\n        primaryKey,\n        notNull,\n      };\n\n      if (column.default !== undefined) {\n        if (is(column.default, SQL)) {\n          columnToSet.default = sqlToStr(column.default, casing);\n        } else {\n          if (typeof column.default === \"string\") {\n            columnToSet.default = `'${column.default}'`;\n          } else {\n            if (sqlTypeLowered === \"jsonb\" || sqlTypeLowered === \"json\") {\n              columnToSet.default = `'${JSON.stringify(column.default)}'::${sqlTypeLowered}`;\n            } else if (column.default instanceof Date) {\n              if (sqlTypeLowered === \"date\") {\n                columnToSet.default = `'${column.default.toISOString().split(\"T\")[0]}'`;\n              } else if (sqlTypeLowered === \"timestamp\") {\n                columnToSet.default = `'${column.default.toISOString().replace(\"T\", \" \").slice(0, 23)}'`;\n              } else {\n                columnToSet.default = `'${column.default.toISOString()}'`;\n              }\n            } else if (\n              isPgArrayType(sqlTypeLowered) &&\n              Array.isArray(column.default)\n            ) {\n              columnToSet.default = `'${buildArrayString(column.default, sqlTypeLowered)}'`;\n            } else {\n              // Should do for all types\n              // columnToSet.default = `'${column.default}'::${sqlTypeLowered}`;\n              columnToSet.default = column.default;\n            }\n          }\n        }\n      }\n      columnsObject[name] = columnToSet;\n    });\n\n    primaryKeys.map((pk) => {\n      const originalColumnNames = pk.columns.map((c) => c.name);\n      const columnNames = pk.columns.map((c) => getColumnCasing(c, casing));\n\n      let name = pk.getName();\n      if (casing !== undefined) {\n        for (let i = 0; i < originalColumnNames.length; i++) {\n          name = name.replace(originalColumnNames[i]!, columnNames[i]!);\n        }\n      }\n\n      primaryKeysObject[name] = {\n        name,\n        columns: columnNames,\n      };\n    });\n\n    indexes.forEach((value) => {\n      const columns = value.config.columns;\n\n      const indexColumnNames: string[] = [];\n      columns.forEach((it) => {\n        const name = getColumnCasing(it as IndexedColumn, casing);\n\n        indexColumnNames.push(name);\n      });\n\n      const name = value.config.name\n        ? value.config.name\n        : indexName(tableName, indexColumnNames);\n\n      const indexColumns: IndexColumnType[] = columns.map(\n        (it): IndexColumnType => {\n          if (is(it, SQL)) {\n            return {\n              expression: dialect.sqlToQuery(it, \"indexes\").sql,\n              asc: true,\n              isExpression: true,\n              nulls: \"last\",\n            };\n          } else {\n            it = it as IndexedColumn;\n            return {\n              expression: getColumnCasing(it as IndexedColumn, casing),\n              isExpression: false,\n              // @ts-ignore\n              asc: it.indexConfig?.order === \"asc\",\n              // @ts-ignore\n              nulls: it.indexConfig?.nulls\n                ? // @ts-ignore\n                  it.indexConfig?.nulls\n                : // @ts-ignore\n                  it.indexConfig?.order === \"desc\"\n                  ? \"first\"\n                  : \"last\",\n              // @ts-ignore\n              opclass: it.indexConfig?.opClass,\n            };\n          }\n        },\n      );\n\n      // check for index names duplicates\n      if (typeof indexesInSchema[schema ?? \"public\"] !== \"undefined\") {\n        indexesInSchema[schema ?? \"public\"]!.push(name);\n      } else {\n        indexesInSchema[schema ?? \"public\"] = [name];\n      }\n\n      indexesObject[name] = {\n        name,\n        columns: indexColumns,\n        isUnique: value.config.unique ?? false,\n        where: value.config.where\n          ? dialect.sqlToQuery(value.config.where).sql\n          : undefined,\n        concurrently: value.config.concurrently ?? false,\n        method: value.config.method ?? \"btree\",\n        with: value.config.with ?? {},\n      };\n    });\n\n    const tableKey = `${schema ?? \"public\"}.${tableName}`;\n\n    result[tableKey] = {\n      name: tableName,\n      schema: schema ?? \"\",\n      columns: columnsObject,\n      indexes: indexesObject,\n      compositePrimaryKeys: primaryKeysObject,\n    };\n  }\n\n  const enumsToReturn: Record<string, Enum> = enums.reduce<{\n    [key: string]: Enum;\n  }>((map, obj) => {\n    const enumSchema = obj.schema || \"public\";\n    const key = `${enumSchema}.${obj.enumName}`;\n    map[key] = {\n      name: obj.enumName,\n      schema: enumSchema,\n      values: obj.enumValues,\n    };\n    return map;\n  }, {});\n\n  const schemasObject = Object.fromEntries(\n    schemas\n      .filter((it) => {\n        return it.schemaName !== \"public\";\n      })\n      .map((it) => [it.schemaName, it.schemaName]),\n  );\n\n  return {\n    version: \"7\",\n    dialect: \"postgresql\",\n    tables: result,\n    enums: enumsToReturn,\n    schemas: schemasObject,\n  };\n};\n\nconst mapValues = <IN, OUT>(\n  obj: Record<string, IN>,\n  map: (input: IN) => OUT,\n): Record<string, OUT> => {\n  const result = Object.keys(obj).reduce(\n    (result, key) => {\n      result[key] = map(obj[key]!);\n      return result;\n    },\n    {} as Record<string, OUT>,\n  );\n  return result;\n};\n\nconst squashPgScheme = (json: PgSchemaSquashed): PgSchemaSquashed => {\n  const mappedTables = Object.fromEntries(\n    Object.entries(json.tables).map((it: [string, any]) => {\n      const squashedIndexes = mapValues(it[1]!.indexes, (index) => {\n        return PgSquasher.squashIdx(index);\n      });\n\n      const squashedPKs = mapValues(it[1]!.compositePrimaryKeys, (pk) => {\n        return PgSquasher.squashPK(pk);\n      });\n\n      const mappedColumns = Object.fromEntries(\n        Object.entries(it[1]!.columns).map((it) => {\n          return [\n            it[0],\n            {\n              ...it[1]!,\n              identity: undefined,\n            },\n          ];\n        }),\n      );\n\n      return [\n        it[0],\n        {\n          name: it[1]!.name,\n          schema: it[1]!.schema,\n          columns: mappedColumns,\n          indexes: squashedIndexes,\n          compositePrimaryKeys: squashedPKs,\n        },\n      ];\n    }),\n  );\n\n  return {\n    version: \"7\",\n    dialect: json.dialect,\n    tables: mappedTables,\n    enums: json.enums,\n    schemas: json.schemas,\n    views: json.views,\n  };\n};\n","// https://github.com/graphql/graphiql/blob/main/examples/graphiql-cdn/index.html\n\nexport const graphiQLHtml = (path: string) => `<!--\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n-->\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Ponder Playground</title>\n    <style>\n      body {\n        height: 100%;\n        margin: 0;\n        width: 100%;\n        overflow: hidden;\n      }\n      #graphiql {\n        height: 100vh;\n      }\n      *::-webkit-scrollbar {\n        height: 0.3rem;\n        width: 0.5rem;\n      }\n      *::-webkit-scrollbar-track {\n        -ms-overflow-style: none;\n        overflow: -moz-scrollbars-none;\n      }\n      *::-webkit-scrollbar-thumb {\n        -ms-overflow-style: none;\n        overflow: -moz-scrollbars-none;\n      }\n    </style>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/graphiql@3.7.2/graphiql.min.css\" />\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/@graphiql/plugin-explorer@3.2.3/dist/style.css\" />\n  </head>\n  <body>\n    <div id=\"graphiql\">Loading...</div>\n    <script crossorigin src=\"https://unpkg.com/react@18.3.1/umd/react.development.js\"></script>1\n    <script crossorigin src=\"https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js\"></script>\n    <script src=\"https://unpkg.com/graphiql@3.7.2/graphiql.min.js\" crossorigin=\"anonymous\"></script>\n    <script src=\"https://unpkg.com/@graphiql/plugin-explorer@3.2.3/dist/index.umd.js\" crossorigin=\"anonymous\"></script>\n    <script>\n      const fetcher = GraphiQL.createFetcher({ url: \"${path}\" });\n      const explorerPlugin = GraphiQLPluginExplorer.explorerPlugin();\n      const root = ReactDOM.createRoot(document.getElementById(\"graphiql\"));\n      root.render(\n        React.createElement(GraphiQL, {\n          fetcher,\n          plugins: [explorerPlugin],\n          defaultEditorToolsVisibility: false,\n        })\n      );\n    </script>\n  </body>\n</html>`;\n","import { graphiQLHtml } from \"@/ui/graphiql.html.js\";\nimport { maxAliasesPlugin } from \"@escape.tech/graphql-armor-max-aliases\";\nimport { maxDepthPlugin } from \"@escape.tech/graphql-armor-max-depth\";\nimport { maxTokensPlugin } from \"@escape.tech/graphql-armor-max-tokens\";\nimport { type YogaServerInstance, createYoga } from \"graphql-yoga\";\nimport { createMiddleware } from \"hono/factory\";\nimport { buildDataLoaderCache } from \"./index.js\";\n\n/**\n * Middleware for GraphQL with an interactive web view.\n *\n * - Docs: https://ponder.sh/docs/query/api-functions#register-graphql-middleware\n *\n * @example\n * import { ponder } from \"@/generated\";\n * import { graphql } from \"@ponder/core\";\n *\n * ponder.use(\"/graphql\", graphql());\n *\n */\nexport const graphql = (\n  {\n    maxOperationTokens = 1000,\n    maxOperationDepth = 100,\n    maxOperationAliases = 30,\n  }: {\n    maxOperationTokens?: number;\n    maxOperationDepth?: number;\n    maxOperationAliases?: number;\n  } = {\n    // Default limits are from Apollo:\n    // https://www.apollographql.com/blog/prevent-graph-misuse-with-operation-size-and-complexity-limit\n    maxOperationTokens: 1000,\n    maxOperationDepth: 100,\n    maxOperationAliases: 30,\n  },\n) => {\n  let yoga: YogaServerInstance<any, any> | undefined = undefined;\n\n  return createMiddleware(async (c) => {\n    if (c.req.method === \"GET\") {\n      return c.html(graphiQLHtml(c.req.path));\n    }\n\n    if (yoga === undefined) {\n      const metadataStore = c.get(\"metadataStore\");\n      const graphqlSchema = c.get(\"graphqlSchema\");\n      const drizzle = c.get(\"db\");\n\n      yoga = createYoga({\n        schema: graphqlSchema,\n        context: () => {\n          const getDataLoader = buildDataLoaderCache({ drizzle });\n          return { drizzle, metadataStore, getDataLoader };\n        },\n        graphqlEndpoint: c.req.path,\n        maskedErrors: process.env.NODE_ENV === \"production\",\n        logging: false,\n        graphiql: false,\n        parserAndValidationCache: false,\n        plugins: [\n          maxTokensPlugin({ n: maxOperationTokens }),\n          maxDepthPlugin({ n: maxOperationDepth, ignoreIntrospection: false }),\n          maxAliasesPlugin({ n: maxOperationAliases, allowList: [] }),\n        ],\n      });\n    }\n\n    const response = await yoga.handle(c.req.raw);\n    // TODO: Figure out why Yoga is returning 500 status codes for GraphQL errors.\n    // @ts-expect-error\n    response.status = 200;\n    // @ts-expect-error\n    response.statusText = \"OK\";\n\n    return response;\n  });\n};\n","export const never = (_x: never) => {\n  throw \"unreachable\";\n};\n","/**\n * Serialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to stringify\n * @returns the stringified output\n */\nexport function serialize(value: any) {\n  return JSON.stringify(value, (_, v) =>\n    typeof v === \"bigint\" ? { __type: \"bigint\", value: v.toString() } : v,\n  );\n}\n\n/**\n * Deserialize function that handles BigInt.\n *\n * Forked from https://github.com/wevm/wagmi\n *\n * @param value to parse\n * @returns the output object\n */\nexport function deserialize<type>(value: string): type {\n  return JSON.parse(value, (_, value_) =>\n    value_?.__type === \"bigint\" ? BigInt(value_.value) : value_,\n  );\n}\n","import type { Drizzle, OnchainTable, Schema } from \"@/drizzle/index.js\";\nimport type { MetadataStore } from \"@/indexing-store/metadata.js\";\nimport { never } from \"@/utils/never.js\";\nimport { deserialize, serialize } from \"@/utils/serialize.js\";\nimport DataLoader from \"dataloader\";\nimport {\n  type Column,\n  Many,\n  One,\n  type SQL,\n  type TableRelationalConfig,\n  and,\n  arrayContained,\n  arrayContains,\n  asc,\n  count,\n  createTableRelationsHelpers,\n  desc,\n  eq,\n  extractTablesRelationalConfig,\n  getTableColumns,\n  gt,\n  gte,\n  inArray,\n  is,\n  like,\n  lt,\n  lte,\n  ne,\n  not,\n  notInArray,\n  notLike,\n  or,\n} from \"drizzle-orm\";\nimport {\n  type PgEnum,\n  PgInteger,\n  PgSerial,\n  isPgEnum,\n} from \"drizzle-orm/pg-core\";\nimport {\n  GraphQLBoolean,\n  GraphQLEnumType,\n  type GraphQLFieldConfig,\n  type GraphQLFieldConfigMap,\n  GraphQLFloat,\n  type GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  type GraphQLInputType,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  type GraphQLOutputType,\n  type GraphQLResolveInfo,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLString,\n} from \"graphql\";\nimport { GraphQLJSON } from \"./json.js\";\n\ntype Parent = Record<string, any>;\ntype Context = {\n  getDataLoader: ReturnType<typeof buildDataLoaderCache>;\n  metadataStore: MetadataStore;\n  drizzle: Drizzle<{ [key: string]: OnchainTable }>;\n};\n\ntype PluralArgs = {\n  where?: { [key: string]: number | string };\n  after?: string;\n  before?: string;\n  limit?: number;\n  orderBy?: string;\n  orderDirection?: \"asc\" | \"desc\";\n};\n\nconst DEFAULT_LIMIT = 50 as const;\nconst MAX_LIMIT = 1000 as const;\n\nexport function buildGraphQLSchema(schema: Schema): GraphQLSchema {\n  const tablesConfig = extractTablesRelationalConfig(\n    schema,\n    createTableRelationsHelpers,\n  );\n\n  const tables = Object.values(tablesConfig.tables) as TableRelationalConfig[];\n\n  const enums = Object.entries(schema).filter(\n    (el): el is [string, PgEnum<[string, ...string[]]>] => isPgEnum(el[1]),\n  );\n  const enumTypes: Record<string, GraphQLEnumType> = {};\n  for (const [enumTsName, enumObject] of enums) {\n    // Note that this is keyed by enumName (the SQL name) because that's what is\n    // available on the PgEnumColumn type. See `columnToGraphQLCore` for context.\n    enumTypes[enumObject.enumName] = new GraphQLEnumType({\n      name: enumTsName,\n      values: enumObject.enumValues.reduce(\n        (acc: Record<string, {}>, cur) => ({ ...acc, [cur]: {} }),\n        {},\n      ),\n    });\n  }\n\n  const entityFilterTypes: Record<string, GraphQLInputObjectType> = {};\n  for (const table of tables) {\n    const filterType = new GraphQLInputObjectType({\n      name: `${table.tsName}Filter`,\n      fields: () => {\n        const filterFields: GraphQLInputFieldConfigMap = {\n          // Logical operators\n          AND: { type: new GraphQLList(filterType) },\n          OR: { type: new GraphQLList(filterType) },\n        };\n\n        for (const [columnName, column] of Object.entries(table.columns)) {\n          const type = columnToGraphQLCore(column, enumTypes);\n\n          // List fields => universal, plural\n          if (type instanceof GraphQLList) {\n            const baseType = innerType(type);\n\n            conditionSuffixes.universal.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type: new GraphQLList(baseType),\n              };\n            });\n\n            conditionSuffixes.plural.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = { type: baseType };\n            });\n          }\n\n          // JSON => no filters.\n          // Boolean => universal and singular only.\n          // All other scalar => universal, singular, numeric OR string depending on type\n          if (\n            type instanceof GraphQLScalarType ||\n            type instanceof GraphQLEnumType\n          ) {\n            if (type.name === \"JSON\") continue;\n\n            conditionSuffixes.universal.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type,\n              };\n            });\n\n            conditionSuffixes.singular.forEach((suffix) => {\n              filterFields[`${columnName}${suffix}`] = {\n                type: new GraphQLList(type),\n              };\n            });\n\n            if ([\"String\", \"ID\"].includes(type.name)) {\n              conditionSuffixes.string.forEach((suffix) => {\n                filterFields[`${columnName}${suffix}`] = {\n                  type: type,\n                };\n              });\n            }\n\n            if ([\"Int\", \"Float\", \"BigInt\"].includes(type.name)) {\n              conditionSuffixes.numeric.forEach((suffix) => {\n                filterFields[`${columnName}${suffix}`] = {\n                  type: type,\n                };\n              });\n            }\n          }\n        }\n\n        return filterFields;\n      },\n    });\n    entityFilterTypes[table.tsName] = filterType;\n  }\n\n  const entityTypes: Record<string, GraphQLObjectType<Parent, Context>> = {};\n  const entityPageTypes: Record<string, GraphQLObjectType> = {};\n\n  for (const table of tables) {\n    entityTypes[table.tsName] = new GraphQLObjectType({\n      name: table.tsName,\n      fields: () => {\n        const fieldConfigMap: GraphQLFieldConfigMap<Parent, Context> = {};\n\n        // Scalar fields\n        for (const [columnName, column] of Object.entries(table.columns)) {\n          const type = columnToGraphQLCore(column, enumTypes);\n          fieldConfigMap[columnName] = {\n            type: column.notNull ? new GraphQLNonNull(type) : type,\n          };\n        }\n\n        // Relations\n        const relations = Object.entries(table.relations);\n        for (const [relationName, relation] of relations) {\n          const referencedTable = tables.find(\n            (table) => table.dbName === relation.referencedTableName,\n          );\n          if (!referencedTable)\n            throw new Error(\n              `Internal error: Referenced table \"${relation.referencedTableName}\" not found`,\n            );\n\n          const referencedEntityType = entityTypes[referencedTable.tsName];\n          const referencedEntityPageType =\n            entityPageTypes[referencedTable.tsName];\n          const referencedEntityFilterType =\n            entityFilterTypes[referencedTable.tsName];\n          if (\n            referencedEntityType === undefined ||\n            referencedEntityPageType === undefined ||\n            referencedEntityFilterType === undefined\n          )\n            throw new Error(\n              `Internal error: Referenced entity types not found for table \"${referencedTable.tsName}\" `,\n            );\n\n          if (is(relation, One)) {\n            const fields = relation.config?.fields ?? [];\n            const references = relation.config?.references ?? [];\n\n            if (fields.length !== references.length) {\n              throw new Error(\n                \"Internal error: Fields and references arrays must be the same length\",\n              );\n            }\n\n            fieldConfigMap[relationName] = {\n              // Note: There is a `relation.isNullable` field here but it appears\n              // to be internal / incorrect. Until we have support for foriegn\n              // key constraints, all `one` relations must be nullable.\n              type: referencedEntityType,\n              resolve: (parent, _args, context) => {\n                const loader = context.getDataLoader({\n                  table: referencedTable,\n                });\n\n                const rowFragment: Record<string, unknown> = {};\n                for (let i = 0; i < references.length; i++) {\n                  const referenceColumn = references[i]!;\n                  const fieldColumn = fields[i]!;\n\n                  const fieldColumnTsName = getColumnTsName(fieldColumn);\n                  const referenceColumnTsName =\n                    getColumnTsName(referenceColumn);\n\n                  rowFragment[referenceColumnTsName] =\n                    parent[fieldColumnTsName];\n                }\n                const encodedId = encodeRowFragment(rowFragment);\n\n                return loader.load(encodedId);\n              },\n            };\n          } else if (is(relation, Many)) {\n            // Search the relations of the referenced table for the corresponding `one` relation.\n            // If \"relationName\" is not provided, use the first `one` relation that references this table.\n            const oneRelation = Object.values(referencedTable.relations).find(\n              (relation) =>\n                relation.relationName === relationName ||\n                (is(relation, One) &&\n                  relation.referencedTableName === table.dbName),\n            ) as One | undefined;\n            if (!oneRelation)\n              throw new Error(\n                `Internal error: Relation \"${relationName}\" not found in table \"${referencedTable.tsName}\"`,\n              );\n\n            const fields = oneRelation.config?.fields ?? [];\n            const references = oneRelation.config?.references ?? [];\n\n            fieldConfigMap[relationName] = {\n              type: referencedEntityPageType,\n              args: {\n                where: { type: referencedEntityFilterType },\n                orderBy: { type: GraphQLString },\n                orderDirection: { type: GraphQLString },\n                before: { type: GraphQLString },\n                after: { type: GraphQLString },\n                limit: { type: GraphQLInt },\n              },\n              resolve: (parent, args: PluralArgs, context, info) => {\n                const relationalConditions = [];\n                for (let i = 0; i < references.length; i++) {\n                  const column = fields[i]!;\n                  const value = parent[references[i]!.name];\n                  relationalConditions.push(eq(column, value));\n                }\n\n                const includeTotalCount = selectionIncludesField(\n                  info,\n                  \"totalCount\",\n                );\n\n                return executePluralQuery(\n                  referencedTable,\n                  context.drizzle,\n                  args,\n                  includeTotalCount,\n                  relationalConditions,\n                );\n              },\n            };\n          } else {\n            throw new Error(\n              `Internal error: Relation \"${relationName}\" is unsupported, expected One or Many`,\n            );\n          }\n        }\n\n        return fieldConfigMap;\n      },\n    });\n\n    entityPageTypes[table.tsName] = new GraphQLObjectType({\n      name: `${table.tsName}Page`,\n      fields: () => ({\n        items: {\n          type: new GraphQLNonNull(\n            new GraphQLList(new GraphQLNonNull(entityTypes[table.tsName]!)),\n          ),\n        },\n        pageInfo: { type: new GraphQLNonNull(GraphQLPageInfo) },\n        totalCount: { type: new GraphQLNonNull(GraphQLInt) },\n      }),\n    });\n  }\n\n  const queryFields: Record<string, GraphQLFieldConfig<Parent, Context>> = {};\n  for (const table of tables) {\n    const entityType = entityTypes[table.tsName]!;\n    const entityPageType = entityPageTypes[table.tsName]!;\n    const entityFilterType = entityFilterTypes[table.tsName]!;\n\n    const singularFieldName =\n      table.tsName.charAt(0).toLowerCase() + table.tsName.slice(1);\n    const pluralFieldName = `${singularFieldName}s`;\n\n    queryFields[singularFieldName] = {\n      type: entityType,\n      // Find the primary key columns and GraphQL core types and include them\n      // as arguments to the singular query type.\n      args: Object.fromEntries(\n        table.primaryKey.map((column) => [\n          getColumnTsName(column),\n          {\n            type: new GraphQLNonNull(\n              columnToGraphQLCore(column, enumTypes) as GraphQLInputType,\n            ),\n          },\n        ]),\n      ),\n      resolve: async (_parent, args, context) => {\n        const loader = context.getDataLoader({ table });\n\n        // The `args` object here should be a valid `where` argument that\n        // uses the `eq` shorthand for each primary key column.\n        const encodedId = encodeRowFragment(args);\n\n        return loader.load(encodedId);\n      },\n    };\n\n    queryFields[pluralFieldName] = {\n      type: new GraphQLNonNull(entityPageType),\n      args: {\n        where: { type: entityFilterType },\n        orderBy: { type: GraphQLString },\n        orderDirection: { type: GraphQLString },\n        before: { type: GraphQLString },\n        after: { type: GraphQLString },\n        limit: { type: GraphQLInt },\n      },\n      resolve: async (_parent, args: PluralArgs, context, info) => {\n        const includeTotalCount = selectionIncludesField(info, \"totalCount\");\n\n        return executePluralQuery(\n          table,\n          context.drizzle,\n          args,\n          includeTotalCount,\n        );\n      },\n    };\n  }\n\n  queryFields._meta = {\n    type: GraphQLMeta,\n    resolve: async (_source, _args, context) => {\n      const status = await context.metadataStore.getStatus();\n      return { status };\n    },\n  };\n\n  return new GraphQLSchema({\n    // Include these here so they are listed first in the printed schema.\n    types: [GraphQLJSON, GraphQLBigInt, GraphQLPageInfo, GraphQLMeta],\n    query: new GraphQLObjectType({\n      name: \"Query\",\n      fields: queryFields,\n    }),\n  });\n}\n\nconst GraphQLPageInfo = new GraphQLObjectType({\n  name: \"PageInfo\",\n  fields: {\n    hasNextPage: { type: new GraphQLNonNull(GraphQLBoolean) },\n    hasPreviousPage: { type: new GraphQLNonNull(GraphQLBoolean) },\n    startCursor: { type: GraphQLString },\n    endCursor: { type: GraphQLString },\n  },\n});\n\nconst GraphQLBigInt = new GraphQLScalarType({\n  name: \"BigInt\",\n  serialize: (value) => String(value),\n  parseValue: (value) => BigInt(value as any),\n  parseLiteral: (value) => {\n    if (value.kind === \"StringValue\") {\n      return BigInt(value.value);\n    } else {\n      throw new Error(\n        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`,\n      );\n    }\n  },\n});\n\nconst GraphQLMeta = new GraphQLObjectType({\n  name: \"Meta\",\n  fields: { status: { type: GraphQLJSON } },\n});\n\nconst columnToGraphQLCore = (\n  column: Column,\n  enumTypes: Record<string, GraphQLEnumType>,\n): GraphQLOutputType => {\n  if (column.columnType === \"PgEvmBigint\") {\n    return GraphQLBigInt;\n  }\n\n  if (column.columnType === \"PgEnumColumn\") {\n    const enumObject = (column as any)?.enum as\n      | PgEnum<[string, ...string[]]>\n      | undefined;\n    if (enumObject === undefined) {\n      throw new Error(\n        `Internal error: Expected enum column \"${getColumnTsName(column)}\" to have an \"enum\" property`,\n      );\n    }\n    const enumType = enumTypes[enumObject.enumName];\n    if (enumType === undefined) {\n      throw new Error(\n        `Internal error: Expected to find a GraphQL enum named \"${enumObject.enumName}\"`,\n      );\n    }\n\n    return enumType;\n  }\n\n  switch (column.dataType) {\n    case \"boolean\":\n      return GraphQLBoolean;\n    case \"json\":\n      return GraphQLJSON;\n    case \"date\":\n      return GraphQLString;\n    case \"string\":\n      return GraphQLString;\n    case \"bigint\":\n      return GraphQLString;\n    case \"number\":\n      return is(column, PgInteger) || is(column, PgSerial)\n        ? GraphQLInt\n        : GraphQLFloat;\n    case \"buffer\":\n      return new GraphQLList(new GraphQLNonNull(GraphQLInt));\n    case \"array\": {\n      if (column.columnType === \"PgVector\") {\n        return new GraphQLList(new GraphQLNonNull(GraphQLFloat));\n      }\n\n      if (column.columnType === \"PgGeometry\") {\n        return new GraphQLList(new GraphQLNonNull(GraphQLFloat));\n      }\n\n      const innerType = columnToGraphQLCore(\n        (column as any).baseColumn,\n        enumTypes,\n      );\n\n      return new GraphQLList(new GraphQLNonNull(innerType));\n    }\n    default:\n      throw new Error(`Type ${column.dataType} is not implemented`);\n  }\n};\n\nconst innerType = (\n  type: GraphQLOutputType,\n): GraphQLScalarType | GraphQLEnumType => {\n  if (type instanceof GraphQLScalarType || type instanceof GraphQLEnumType)\n    return type;\n  if (type instanceof GraphQLList || type instanceof GraphQLNonNull)\n    return innerType(type.ofType);\n  throw new Error(`Type ${type.toString()} is not implemented`);\n};\n\nasync function executePluralQuery(\n  table: TableRelationalConfig,\n  drizzle: Drizzle<{ [key: string]: OnchainTable }>,\n  args: PluralArgs,\n  includeTotalCount: boolean,\n  extraConditions: (SQL | undefined)[] = [],\n) {\n  const rawTable = drizzle._.fullSchema[table.tsName];\n  const baseQuery = drizzle.query[table.tsName];\n  if (rawTable === undefined || baseQuery === undefined)\n    throw new Error(`Internal error: Table \"${table.tsName}\" not found in RQB`);\n\n  const limit = args.limit ?? DEFAULT_LIMIT;\n  if (limit > MAX_LIMIT) {\n    throw new Error(`Invalid limit. Got ${limit}, expected <=${MAX_LIMIT}.`);\n  }\n\n  const orderBySchema = buildOrderBySchema(table, args);\n  const orderBy = orderBySchema.map(([columnName, direction]) => {\n    const column = table.columns[columnName];\n    if (column === undefined) {\n      throw new Error(\n        `Unknown column \"${columnName}\" used in orderBy argument`,\n      );\n    }\n    return direction === \"asc\" ? asc(column) : desc(column);\n  });\n  const orderByReversed = orderBySchema.map(([columnName, direction]) => {\n    const column = table.columns[columnName];\n    if (column === undefined) {\n      throw new Error(\n        `Unknown column \"${columnName}\" used in orderBy argument`,\n      );\n    }\n    return direction === \"asc\" ? desc(column) : asc(column);\n  });\n\n  const whereConditions = buildWhereConditions(args.where, table.columns);\n\n  const after = args.after ?? null;\n  const before = args.before ?? null;\n\n  if (after !== null && before !== null) {\n    throw new Error(\"Cannot specify both before and after cursors.\");\n  }\n\n  let startCursor = null;\n  let endCursor = null;\n  let hasPreviousPage = false;\n  let hasNextPage = false;\n\n  const totalCountPromise = includeTotalCount\n    ? drizzle\n        .select({ count: count() })\n        .from(rawTable)\n        .where(and(...whereConditions, ...extraConditions))\n        .then((rows) => rows[0]?.count ?? null)\n    : Promise.resolve(null);\n\n  // Neither cursors are specified, apply the order conditions and execute.\n  if (after === null && before === null) {\n    const [rows, totalCount] = await Promise.all([\n      baseQuery.findMany({\n        where: and(...whereConditions, ...extraConditions),\n        orderBy,\n        limit: limit + 1,\n      }),\n      totalCountPromise,\n    ]);\n\n    if (rows.length === limit + 1) {\n      rows.pop();\n      hasNextPage = true;\n    }\n\n    startCursor =\n      rows.length > 0 ? encodeCursor(orderBySchema, rows[0]!) : null;\n    endCursor =\n      rows.length > 0\n        ? encodeCursor(orderBySchema, rows[rows.length - 1]!)\n        : null;\n\n    return {\n      items: rows,\n      totalCount,\n      pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n    };\n  }\n\n  if (after !== null) {\n    // User specified an 'after' cursor.\n    const cursorObject = decodeCursor(after);\n    const cursorCondition = buildCursorCondition(\n      table,\n      orderBySchema,\n      \"after\",\n      cursorObject,\n    );\n\n    const [rows, totalCount] = await Promise.all([\n      baseQuery.findMany({\n        where: and(...whereConditions, cursorCondition, ...extraConditions),\n        orderBy,\n        limit: limit + 2,\n      }),\n      totalCountPromise,\n    ]);\n\n    if (rows.length === 0) {\n      return {\n        items: rows,\n        totalCount,\n        pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n      };\n    }\n\n    // If the cursor of the first returned record equals the `after` cursor,\n    // `hasPreviousPage` is true. Remove that record.\n    if (encodeCursor(orderBySchema, rows[0]!) === after) {\n      rows.shift();\n      hasPreviousPage = true;\n    } else {\n      // Otherwise, remove the last record.\n      rows.pop();\n    }\n\n    // Now if the length of the records is still equal to limit + 1,\n    // there is a next page.\n    if (rows.length === limit + 1) {\n      rows.pop();\n      hasNextPage = true;\n    }\n\n    // Now calculate the cursors.\n    startCursor =\n      rows.length > 0 ? encodeCursor(orderBySchema, rows[0]!) : null;\n    endCursor =\n      rows.length > 0\n        ? encodeCursor(orderBySchema, rows[rows.length - 1]!)\n        : null;\n\n    return {\n      items: rows,\n      totalCount,\n      pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n    };\n  }\n\n  // User specified a 'before' cursor.\n  const cursorObject = decodeCursor(before!);\n  const cursorCondition = buildCursorCondition(\n    table,\n    orderBySchema,\n    \"before\",\n    cursorObject,\n  );\n\n  // Reverse the order by conditions to get the previous page,\n  // then reverse the results back to the original order.\n  const [rows, totalCount] = await Promise.all([\n    baseQuery\n      .findMany({\n        where: and(...whereConditions, cursorCondition, ...extraConditions),\n        orderBy: orderByReversed,\n        limit: limit + 2,\n      })\n      .then((rows) => rows.reverse()),\n    totalCountPromise,\n  ]);\n\n  if (rows.length === 0) {\n    return {\n      items: rows,\n      totalCount,\n      pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n    };\n  }\n\n  // If the cursor of the last returned record equals the `before` cursor,\n  // `hasNextPage` is true. Remove that record.\n  if (encodeCursor(orderBySchema, rows[rows.length - 1]!) === before) {\n    rows.pop();\n    hasNextPage = true;\n  } else {\n    // Otherwise, remove the first record.\n    rows.shift();\n  }\n\n  // Now if the length of the records is equal to limit + 1, we know\n  // there is a previous page.\n  if (rows.length === limit + 1) {\n    rows.shift();\n    hasPreviousPage = true;\n  }\n\n  // Now calculate the cursors.\n  startCursor = rows.length > 0 ? encodeCursor(orderBySchema, rows[0]!) : null;\n  endCursor =\n    rows.length > 0\n      ? encodeCursor(orderBySchema, rows[rows.length - 1]!)\n      : null;\n\n  return {\n    items: rows,\n    totalCount,\n    pageInfo: { hasNextPage, hasPreviousPage, startCursor, endCursor },\n  };\n}\n\nconst conditionSuffixes = {\n  universal: [\"\", \"_not\"],\n  singular: [\"_in\", \"_not_in\"],\n  plural: [\"_has\", \"_not_has\"],\n  numeric: [\"_gt\", \"_lt\", \"_gte\", \"_lte\"],\n  string: [\n    \"_contains\",\n    \"_not_contains\",\n    \"_starts_with\",\n    \"_ends_with\",\n    \"_not_starts_with\",\n    \"_not_ends_with\",\n  ],\n} as const;\n\nconst conditionSuffixesByLengthDesc = Object.values(conditionSuffixes)\n  .flat()\n  .sort((a, b) => b.length - a.length);\n\nfunction buildWhereConditions(\n  where: Record<string, any> | undefined,\n  columns: Record<string, Column>,\n): (SQL | undefined)[] {\n  const conditions: (SQL | undefined)[] = [];\n\n  if (where === undefined) return conditions;\n\n  for (const [whereKey, rawValue] of Object.entries(where)) {\n    // Handle the `AND` and `OR` operators\n    if (whereKey === \"AND\" || whereKey === \"OR\") {\n      if (!Array.isArray(rawValue)) {\n        throw new Error(\n          `Invalid query: Expected an array for the ${whereKey} operator. Got: ${rawValue}`,\n        );\n      }\n\n      const nestedConditions = rawValue.flatMap((subWhere) =>\n        buildWhereConditions(subWhere, columns),\n      );\n\n      if (nestedConditions.length > 0) {\n        conditions.push(\n          whereKey === \"AND\"\n            ? and(...nestedConditions)\n            : or(...nestedConditions),\n        );\n      }\n      continue;\n    }\n\n    // Search for a valid filter suffix, traversing the list from longest to shortest\n    // to avoid ambiguity between cases like `_not_in` and `_in`.\n    const conditionSuffix = conditionSuffixesByLengthDesc.find((s) =>\n      whereKey.endsWith(s),\n    );\n    if (conditionSuffix === undefined) {\n      throw new Error(\n        `Invariant violation: Condition suffix not found for where key ${whereKey}`,\n      );\n    }\n\n    // Remove the condition suffix and use the remaining string as the column name.\n    const columnName = whereKey.slice(\n      0,\n      whereKey.length - conditionSuffix.length,\n    );\n\n    // Validate that the column name is present in the table.\n    const column = columns[columnName];\n    if (column === undefined) {\n      throw new Error(\n        `Invalid query: Where clause contains unknown column ${columnName}`,\n      );\n    }\n\n    switch (conditionSuffix) {\n      case \"\":\n        if (column.columnType === \"PgArray\") {\n          conditions.push(\n            and(\n              arrayContains(column, rawValue),\n              arrayContained(column, rawValue),\n            ),\n          );\n        } else {\n          conditions.push(eq(column, rawValue));\n        }\n        break;\n      case \"_not\":\n        if (column.columnType === \"PgArray\") {\n          conditions.push(\n            not(\n              and(\n                arrayContains(column, rawValue),\n                arrayContained(column, rawValue),\n              )!,\n            ),\n          );\n        } else {\n          conditions.push(ne(column, rawValue));\n        }\n        break;\n      case \"_in\":\n        conditions.push(inArray(column, rawValue));\n        break;\n      case \"_not_in\":\n        conditions.push(notInArray(column, rawValue));\n        break;\n      case \"_has\":\n        conditions.push(arrayContains(column, [rawValue]));\n        break;\n      case \"_not_has\":\n        conditions.push(not(arrayContains(column, [rawValue])));\n        break;\n      case \"_gt\":\n        conditions.push(gt(column, rawValue));\n        break;\n      case \"_lt\":\n        conditions.push(lt(column, rawValue));\n        break;\n      case \"_gte\":\n        conditions.push(gte(column, rawValue));\n        break;\n      case \"_lte\":\n        conditions.push(lte(column, rawValue));\n        break;\n      case \"_contains\":\n        conditions.push(like(column, `%${rawValue}%`));\n        break;\n      case \"_not_contains\":\n        conditions.push(notLike(column, `%${rawValue}%`));\n        break;\n      case \"_starts_with\":\n        conditions.push(like(column, `${rawValue}%`));\n        break;\n      case \"_ends_with\":\n        conditions.push(like(column, `%${rawValue}`));\n        break;\n      case \"_not_starts_with\":\n        conditions.push(notLike(column, `${rawValue}%`));\n        break;\n      case \"_not_ends_with\":\n        conditions.push(notLike(column, `%${rawValue}`));\n        break;\n      default:\n        never(conditionSuffix);\n    }\n  }\n\n  return conditions;\n}\n\nfunction buildOrderBySchema(table: TableRelationalConfig, args: PluralArgs) {\n  // If the user-provided order by does not include the ALL of the ID columns,\n  // add any missing ID columns to the end of the order by clause (asc).\n  // This ensures a consistent sort order to unblock cursor pagination.\n  const userDirection = args.orderDirection ?? \"asc\";\n  const userColumns: [string, \"asc\" | \"desc\"][] =\n    args.orderBy !== undefined ? [[args.orderBy, userDirection]] : [];\n  const pkColumns = table.primaryKey.map((column) => [\n    getColumnTsName(column),\n    userDirection,\n  ]);\n  const missingPkColumns = pkColumns.filter(\n    (pkColumn) =>\n      !userColumns.some((userColumn) => userColumn[0] === pkColumn[0]),\n  ) as [string, \"asc\" | \"desc\"][];\n  return [...userColumns, ...missingPkColumns];\n}\n\nfunction encodeCursor(\n  orderBySchema: [string, \"asc\" | \"desc\"][],\n  row: { [k: string]: unknown },\n): string {\n  const cursorObject = Object.fromEntries(\n    orderBySchema.map(([columnName, _]) => [columnName, row[columnName]]),\n  );\n  return encodeRowFragment(cursorObject);\n}\nfunction decodeCursor(cursor: string): { [k: string]: unknown } {\n  return decodeRowFragment(cursor);\n}\n\nfunction encodeRowFragment(rowFragment: { [k: string]: unknown }): string {\n  return Buffer.from(serialize(rowFragment)).toString(\"base64\");\n}\nfunction decodeRowFragment(encodedRowFragment: string): {\n  [k: string]: unknown;\n} {\n  return deserialize(Buffer.from(encodedRowFragment, \"base64\").toString());\n}\n\nfunction buildCursorCondition(\n  table: TableRelationalConfig,\n  orderBySchema: [string, \"asc\" | \"desc\"][],\n  direction: \"after\" | \"before\",\n  cursorObject: { [k: string]: unknown },\n): SQL | undefined {\n  const cursorColumns = orderBySchema.map(([columnName, orderDirection]) => {\n    const column = table.columns[columnName];\n    if (column === undefined)\n      throw new Error(\n        `Unknown column \"${columnName}\" used in orderBy argument`,\n      );\n\n    const value = cursorObject[columnName];\n\n    let comparator: typeof gt | typeof lt;\n    let comparatorOrEquals: typeof gte | typeof lte;\n    if (direction === \"after\") {\n      [comparator, comparatorOrEquals] =\n        orderDirection === \"asc\" ? [gt, gte] : [lt, lte];\n    } else {\n      [comparator, comparatorOrEquals] =\n        orderDirection === \"asc\" ? [lt, lte] : [gt, gte];\n    }\n\n    return { column, value, comparator, comparatorOrEquals };\n  });\n\n  const buildCondition = (index: number): SQL | undefined => {\n    if (index === cursorColumns.length - 1) {\n      const { column, value, comparatorOrEquals } = cursorColumns[index]!;\n      return comparatorOrEquals(column, value);\n    }\n\n    const currentColumn = cursorColumns[index]!;\n    const nextCondition = buildCondition(index + 1);\n\n    return or(\n      currentColumn.comparator(currentColumn.column, currentColumn.value),\n      and(eq(currentColumn.column, currentColumn.value), nextCondition),\n    );\n  };\n\n  return buildCondition(0);\n}\n\nexport function buildDataLoaderCache({\n  drizzle,\n}: { drizzle: Drizzle<Schema> }) {\n  const dataLoaderMap = new Map<\n    TableRelationalConfig,\n    DataLoader<string, any> | undefined\n  >();\n  return ({ table }: { table: TableRelationalConfig }) => {\n    const baseQuery = (drizzle as Drizzle<{ [key: string]: OnchainTable }>)\n      .query[table.tsName];\n    if (baseQuery === undefined)\n      throw new Error(\n        `Internal error: Unknown table \"${table.tsName}\" in data loader cache`,\n      );\n\n    let dataLoader = dataLoaderMap.get(table);\n    if (dataLoader === undefined) {\n      dataLoader = new DataLoader(\n        async (encodedIds) => {\n          const decodedRowFragments = encodedIds.map(decodeRowFragment);\n\n          // The decoded row fragments should be valid `where` objects\n          // which use the `eq` object shorthand for each primary key column.\n          const idConditions = decodedRowFragments.map((decodedRowFragment) =>\n            and(...buildWhereConditions(decodedRowFragment, table.columns)),\n          );\n\n          const rows = await baseQuery.findMany({\n            where: or(...idConditions),\n            limit: encodedIds.length,\n          });\n\n          return decodedRowFragments.map((decodedRowFragment) => {\n            return rows.find((row) =>\n              Object.entries(decodedRowFragment).every(\n                ([col, val]) => row[col] === val,\n              ),\n            );\n          });\n        },\n        { maxBatchSize: 1_000 },\n      );\n      dataLoaderMap.set(table, dataLoader);\n    }\n\n    return dataLoader;\n  };\n}\n\nfunction getColumnTsName(column: Column) {\n  const tableColumns = getTableColumns(column.table);\n  return Object.entries(tableColumns).find(\n    ([_, c]) => c.name === column.name,\n  )![0];\n}\n\n/**\n * Returns `true` if the query includes a specific field.\n * Does not consider nested selections; only works one \"layer\" deep.\n */\nfunction selectionIncludesField(\n  info: GraphQLResolveInfo,\n  fieldName: string,\n): boolean {\n  for (const fieldNode of info.fieldNodes) {\n    for (const selection of fieldNode.selectionSet?.selections ?? []) {\n      if (selection.kind === \"Field\" && selection.name.value === fieldName) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","// Modified from https://github.com/taion/graphql-type-json/blob/master/src/index.js\nimport {\n  type GraphQLScalarLiteralParser,\n  GraphQLScalarType,\n  Kind,\n  type ObjectValueNode,\n  type ValueNode,\n  print,\n} from \"graphql\";\n\nexport const GraphQLJSON = new GraphQLScalarType({\n  name: \"JSON\",\n  description:\n    \"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).\",\n  serialize: (x) => x,\n  parseValue: (x) => x,\n  parseLiteral: (ast, variables) => {\n    if (ast.kind !== Kind.OBJECT) {\n      throw new TypeError(\n        `JSONObject cannot represent non-object value: ${print(ast)}`,\n      );\n    }\n\n    return parseObject(ast, variables);\n  },\n});\n\nconst parseLiteral = (\n  ast: ValueNode,\n  variables: Parameters<GraphQLScalarType[\"parseLiteral\"]>[1],\n): ReturnType<GraphQLScalarLiteralParser<unknown>> => {\n  switch (ast.kind) {\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n      return ast.value;\n    case Kind.INT:\n    case Kind.FLOAT:\n      return Number.parseFloat(ast.value);\n    case Kind.OBJECT:\n      return parseObject(ast, variables);\n    case Kind.LIST:\n      return ast.values.map((n) => parseLiteral(n, variables));\n    case Kind.NULL:\n      return null;\n    case Kind.VARIABLE:\n      return variables ? variables[ast.name.value] : undefined;\n    default:\n      throw new TypeError(`JSON cannot represent value: ${print(ast)}`);\n  }\n};\n\nconst parseObject = (\n  ast: ObjectValueNode,\n  variables: Parameters<GraphQLScalarType[\"parseLiteral\"]>[1],\n) => {\n  const value = Object.create(null);\n  ast.fields.forEach((field) => {\n    value[field.name.value] = parseLiteral(field.value, variables);\n  });\n\n  return value;\n};\n"],"mappings":"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","names":["is","PgSchema","PgTable","getTableConfig","entityKind","PgColumn","PgColumnBuilder","asc","primaryKey","columns","name","result","it","is","PgTable","getTableConfig","column","table","PgSchema","e","name","getTableColumns","is","isPgEnum","GraphQLScalarType","isPgEnum","GraphQLScalarType","table","is","relation","innerType","rows","totalCount","cursorObject","cursorCondition","getTableColumns"]}
import { ensureDataDirExist } from '#utils/create-kysely.js';
import { PGlite, } from '@electric-sql/pglite';
import { isObject, isString } from '@sindresorhus/is';
import { PostgresAdapter, PostgresIntrospector, PostgresQueryCompiler, } from 'kysely';
import { PGliteDriver } from './pglite-driver.js';
export class KyselyPGlite {
    client;
    constructor(dataDirOrOptionsOrPGlite, opts) {
        ensureDataDirExist(dataDirOrOptionsOrPGlite);
        let options = { ...opts };
        if (isObject(dataDirOrOptionsOrPGlite) &&
            dataDirOrOptionsOrPGlite instanceof PGlite) {
            // @ts-expect-error
            this.client = dataDirOrOptionsOrPGlite;
            return;
        }
        if (isString(dataDirOrOptionsOrPGlite)) {
            options = {
                dataDir: dataDirOrOptionsOrPGlite,
                ...options,
            };
        }
        else {
            options = dataDirOrOptionsOrPGlite ?? {};
        }
        // @ts-expect-error
        this.client = new PGlite(options);
    }
    static async create(dataDirOrPGliteOptions, options) {
        const resolvedOpts = isString(dataDirOrPGliteOptions)
            ? {
                dataDir: dataDirOrPGliteOptions,
                ...(options ?? {}),
            }
            : (dataDirOrPGliteOptions ?? {});
        const pg = await PGlite.create(resolvedOpts);
        return new KyselyPGlite(pg);
    }
    dialect = {
        createAdapter: () => new PostgresAdapter(),
        createDriver: () => new PGliteDriver(this.client),
        createIntrospector: (db) => new PostgresIntrospector(db),
        createQueryCompiler: () => new PostgresQueryCompiler(),
    };
}
//# sourceMappingURL=kysely-pglite.js.map